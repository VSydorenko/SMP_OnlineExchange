#Область ОписаниеПеременных

Перем Ошибка Экспорт; // ?
Перем ВходящиеДанные Экспорт; // ?

Перем ТипОбъекта; // ?
Перем ОбъектНайден; // ?
Перем СсылкаНаОбъект; // ?
Перем ПерезаписатьОбъект; // ?
Перем Отказ; // ?

Перем ПравилаКонвертации Экспорт; // ?

Перем ОсновнойОбъектСсылка Экспорт;     // Хранит основной объект для сериализации.

Перем ОбработчикиТипов;         // Хранит имена функций для обработки нестандартных типов данных.
Перем мСтандартныеРеквизиты;    // Хранит наборы имен стандартных реквизитов для объектов ссылочного типа.
Перем мПростыеТипыДанных;       // Хранит простые типы данных.
Перем Гнпп;                     // Счетчик для нумерации ссылок.
Перем СтекОбработанныхСсылок;   // Хранит сериализованные ссылки.
Перем СтекОбработанныхОбъектов; // Хранит сериализованные объекты - данные реквизитов и ТЧ основного объекта.
Перем СтекУжеВыгружались;       // Хранит ссылки на элементы справочников которые выгружались в предыдущих сеансах обмена.
								// Для таких элементов выполняется только сериализация ссылки, без полной сериализации объекта.
Перем СтекЕщеНеВыгружались;     // Хранит ссылки на элементы справочников которые сериализуются сейчас полностью для выгрузки.
Перем мТипыДокументов;          // Хранит описание всех типов документов "Документы.ТипВсеСсылки()";
Перем мТипыСправочников;        // Хранит описание всех типов справочников "Справочники.ТипВсеСсылки()";
Перем мТипыПеречислений;        // Хранит описание всех типов перечислений "Перечисления.ТипВсеСсылки()";

Перем сОписаниеВыгружаемыхДанных; // Хранит набор выгружаемых ссылочных типов данных со списком реквизитов и таб. частей.
Перем МассивРезультат;

Перем ПараметрыЗаписиJSON;
Перем НастройкиСериализацииJSON;

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Возвращает массив объектов сериализованных в JSON и готовых к отправке в базу-приемник.
//
// Параметры:
//   Нет.
//
// Возвращаемое значение:
//   Массив из Строка - Массив строк в формате JSON
//
Функция ПолучитьМассивСериализованныхОбъектов() Экспорт
	
	СериализоватьВПростыеТипы(ОсновнойОбъектСсылка, Ложь);
	
	// Регистрируем элементы справочников
	Если СтекЕщеНеВыгружались.Количество() > 0 Тогда
		
		//мПараметры = Новый Массив(2);
		//мПараметры.Установить(0, УчетнаяЗаписьОбмена);
		//мПараметры.Установить(1, СтекЕщеНеВыгружались);
		//ФЗ = ФоновыеЗадания.Выполнить("СМП_ОнлайнОбменСобытия.ЗарегистрироватьВыгруженныеЭлементыСправочников", мПараметры);
		
		// Отладка
		РегистрыСведений.СМП_ВыгруженныеСправочники.ЗарегистрироватьВыгрузкуЭлементовСправочников(
		УчетнаяЗаписьОбмена, СтекЕщеНеВыгружались);
		
	КонецЕсли;
	
	Возврат МассивРезультат;
	
КонецФункции // ПолучитьМассивСериализованныхОбъектов

Функция ЗаписатьДанныеВJSON(Данные) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ПроверятьСтруктуру = Ложь;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	ЗаписатьJSON(ЗаписьJSON, Данные, НастройкиСериализацииJSON);
	ТекстСообщения = ЗаписьJSON.Закрыть();
	
	Возврат ТекстСообщения;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область СериализацияДанныхВJSON

// Функция преобразования сложных типов. Указана при вызове метода "ЗаписатьJSON".
//
// Параметры:
//   Свойство - Строка - имя свойства, если выполняется запись структуры или соответствия.
//   Значение - Произвольный - исходное значение которое нужно конвертировать.
//   ДополнительныеПараметры - Структура - дополнительные параметры, которые указаны в вызове метода ЗаписатьJSON.
//   Отказ - Булево - отказ от записи свойства.
//
// Возвращаемое значение:
//   Структура - подготовленная структура с простыми типами данных.
//
Функция КонвертацияСложныхТиповДляJSON(Свойство, Значение, ДопПараметры, Отказ) Экспорт
	
	//Если НЕ ЗначениеЗаполнено(Свойство) И ДопПараметры.Значение = Значение Тогда // т.е. это выгрузка объекта
	//	ТолькоСсылки = Ложь;
	//Иначе // а это свойства объекта
	//	ТолькоСсылки = ДопПараметры.ТолькоСсылки;
	//КонецЕсли;
	//
	//МассивСсылок = Новый Массив(1);
	//МассивСсылок.Установить(0, Значение); 
	//СтекСсылкиКОбработке.Вставить(УровеньВложенности, МассивСсылок); 
	//
	//Пока НЕ СериализацияЗакончена Цикл
	//	
	//	МассивСсылок = СтекСсылкиКОбработке.Получить(УровеньВложенности);
	//	Если МассивСсылок = Неопределено Тогда
	//		СериализацияЗакончена = Истина;
	//	Иначе
	//		
	//		Для Каждого ЗначениеСсылка Из МассивСсылок Цикл
	//			СериализоватьВПростыеТипы(ЗначениеСсылка, ТолькоСсылки);
	//		КонецЦикла;
	//		
	//		УровеньВложенности = УровеньВложенности + 1;
	//		
	//	КонецЕсли;
	//КонецЦикла;
	//
	//
	//
	//Возврат РезультатКонвертации;
	//
КонецФункции // КонвертацияСложныхТиповДляJSON()

// Сериализует переданное значение в структуру с простыми типами данных.
//
// Параметры:
//   Значение - Произвольный - значение для сериализации.
//
// Возвращаемое значение:
//   Структура - сериализованное значение
//
Функция СериализоватьВПростыеТипы(Значение, Знач ТолькоСсылка = Истина, ЭтоСериализацияРеквизита = Ложь) Экспорт
	
	НовоеЗначение = Неопределено;
	
	Если ЭтоПростойТип(Значение) Тогда
		НовоеЗначение = Значение;
		Возврат НовоеЗначение;
	ИначеЕсли Значение = NULL Тогда
		НовоеЗначение = Неопределено;
		Возврат НовоеЗначение;
	КонецЕсли;
	
	// Проверим, что значение еще не обрабатывалось:
	Если ТолькоСсылка Тогда
		НовоеЗначение = СтекОбработанныхСсылок.Получить(Значение);
		Если НовоеЗначение <> Неопределено Тогда
			Возврат НовоеЗначение;
		КонецЕсли;
	Иначе
		
		// У основного объекта могут быть несколько реквизитов с одинаковыми ссылочными значениями.
		// Например - несколько одинаковых позиций номенклатуры в ТЧ с разными ценами.
		// Если уже выполнялась полная сериализация такого реквизита - значит он 100% есть в "РезультатКонвертации.Объекты".
		НовоеЗначение = СтекОбработанныхОбъектов.Получить(Значение);
		Если НовоеЗначение <> Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	// обработка не ссылочных типов:
	ТипЗначения = ТипЗнч(Значение);
	Обработчик = ОбработчикиТипов.Получить(ТипЗначения);
	
	Если Обработчик <> Неопределено Тогда // это для не ссылочных типов данных
		Выполнить("НовоеЗначение = " + Обработчик);
		Возврат НовоеЗначение;
	КонецЕсли;
	
	МетаданныеЗначения = Метаданные.НайтиПоТипу(ТипЗначения);
	Если МетаданныеЗначения = Неопределено Тогда
		Выполнить("НовоеЗначение = обработчик_ЗначениеВСтрокуВнутр(Значение)");
		Возврат НовоеЗначение;
	КонецЕсли;
	
	Если НЕ мТипыПеречислений.СодержитТип(ТипЗначения) Тогда
		мОписаниеТипаДанных = сОписаниеВыгружаемыхДанных.Получить(ТипЗначения);
		Если мОписаниеТипаДанных = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	// Сериализация ссылочных данных
	Если Метаданные.Справочники.Содержит(МетаданныеЗначения) Тогда
		
		Если ЭтоСериализацияРеквизита И ТолькоСсылка Тогда // Обход реквизитов основного объекта
			НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "СправочникСсылка", ТолькоСсылка, МетаданныеЗначения, мОписаниеТипаДанных);
		ИначеЕсли НЕ ТолькоСсылка И НЕ ЭтотОбъектУжеОтсылался(Значение) Тогда
			НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "СправочникСсылка", ТолькоСсылка, МетаданныеЗначения, мОписаниеТипаДанных);
		КонецЕсли;
		
	ИначеЕсли Метаданные.Документы.Содержит(МетаданныеЗначения) Тогда
		НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "ДокументСсылка", ТолькоСсылка, МетаданныеЗначения, мОписаниеТипаДанных);
		
	ИначеЕсли Метаданные.Перечисления.Содержит(МетаданныеЗначения) Тогда
		НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "ПеречислениеСсылка", Истина, МетаданныеЗначения, Неопределено);
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "ПланВидовХарактеристикСсылка", ТолькоСсылка, МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "ПланСчетовСсылка", ТолькоСсылка, МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "ПланВидовРасчетаСсылка", ТолькоСсылка, МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "БизнесПроцессСсылка", ТолькоСсылка, МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.Задачи.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = СериализоватьПоСсылкеВСтруктуру(Значение, "ЗадачаСсылка", ТолькоСсылка, МетаданныеЗначения);
		НовоеЗначение = Неопределено;
		
	// Сериализация наборов записей регистров:
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = ВыгрузитьНаборЗаписей(Значение, "РегистрСведенийНаборЗаписей", МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = ВыгрузитьНаборЗаписей(Значение, "РегистрНакопленияНаборЗаписей", МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = ВыгрузитьНаборЗаписей(Значение, "РегистрБухгалтерииНаборЗаписей", МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(МетаданныеЗначения) Тогда
		//НовоеЗначение = ВыгрузитьНаборЗаписей(Значение, "РегистрРасчетаНаборЗаписей", МетаданныеЗначения);
		НовоеЗначение = Неопределено;
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(МетаданныеЗначения) Тогда
		НовоеЗначение = Неопределено;
	Иначе
		ВызватьИсключение "Ошика сериализации. Встретился неподдерживаемый тип данных: " + ТипЗначения + " (" + Значение + ")";
	КонецЕсли;
	
	//Если Значение = ОсновнойОбъектСсылка Тогда // Это сериализован основной объект, переданный в обработку.
	//	
	//	РезультатКонвертации.Объекты.Добавить(НовоеЗначение);
	//	Возврат Неопределено;
	//	
	//ИначеЕсли ЗначениеЗаполнено(Значение) 
	//	И НЕ ТолькоСсылка 
	//	И НЕ мТипыПеречислений.СодержитТип(ТипЗначения) Тогда // Это сериализован реквизит основного объекта. Данные реквизита выгружаются полностью.
	//	
	//	РезультатКонвертации.Объекты.Добавить(НовоеЗначение);
	//	СтекОбработанныхОбъектов.Вставить(Значение, НовоеЗначение);
	//	
	//	Возврат Неопределено;
	//	
	//Иначе
	//КонецЕсли;
	
	//Если НЕ ТолькоСсылка И НЕ ЭтоСериализацияРеквизита Тогда // Повышаем уровень вложенности только при сериализации основных объектов
	//	
	//	Если НЕ мТипыПеречислений.СодержитТип(ТипЗначения) Тогда
	//		РезультатКонвертации.Объекты.Добавить(НовоеЗначение);
	//	КонецЕсли;
	//	
	//	Возврат Неопределено;
	//	
	//Иначе
	//	Возврат НовоеЗначение;
	//КонецЕсли;
	
	Если НовоеЗначение <> Неопределено И (НЕ ТолькоСсылка) И (НЕ мТипыПеречислений.СодержитТип(ТипЗначения)) Тогда
		
		Контейнер = Новый Структура("Объекты", Новый Массив());
		Контейнер.Объекты.Добавить(НовоеЗначение);
		СтекОбработанныхОбъектов.Вставить(Значение, НовоеЗначение);
		
		ОбъектJSON = ЗаписатьДанныеВJSON(Контейнер);
		МассивРезультат.Добавить(ОбъектJSON);
		
	КонецЕсли;
	
	Возврат НовоеЗначение;
	
КонецФункции

// Возвращает сериализованный объект ссылочного типа.
//
// Параметры:
//   ЗначениеСсылка - ЛюбаяСсылка - ссылка на объект для сериализации.
//   КоллекцияТипа - Строка - наименование коллекции (СправочникСсылка, ДокументСсылка и т.д.).
//   ТолькоСсылка - Булево - выгружать только ссылку или объект полностью.
//   МетаданныеЗначения - ОбъектМетаданных - метаданные переданной ссылки.
//   ОписаниеТипаДанных - Соответствие:
//							* "_СвойстваПоиска" - Массив из Строка - имена реквизитов поиска
//							* "_Свойства" - Массив из Строка - имена выгружаемых реквизитов (без реквизитов поиска)
//							* "_ТабличныеЧасти" - Соответствие - ключ (имя таб. части), значение (Соответствие с именами реквизитов тч).
//
// Возвращаемое значение:
//   Структура - сериализованный объект, готовый для преобразования в строку JSON.
//
Функция СериализоватьПоСсылкеВСтруктуру(Знач ЗначениеСсылка, КоллекцияТипа, ТолькоСсылка = Ложь, МетаданныеЗначения, ОписаниеТипаДанных = Неопределено)
	
	Если Не ЗначениеЗаполнено(ЗначениеСсылка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Общий нумератор ссылок
	Если Гнпп = 0 Тогда
		Гнпп = 1;
	КонецЕсли;
	
	ТипСтрокой = КоллекцияТипа + "." +  МетаданныеЗначения.Имя;
	СсылкаСтруктурой = Неопределено;
	ЗначениеСтруктурой = Неопределено;
	ТекущийНпп = Гнпп;
	
	// Проверяем, может ссылка уже есть в стеке:
	СсылкаСтруктурой = СтекОбработанныхСсылок.Получить(ЗначениеСсылка);
	Если СсылкаСтруктурой = Неопределено Тогда
		
		СсылкаСтруктурой = СериализоватьСсылку(ЗначениеСсылка, ТипСтрокой, Гнпп);
		
		Если НЕ СтрНачинаетсяС(КоллекцияТипа, "ПеречислениеСсылка") Тогда
			ЗаполнитьСвойстваПоиска(ЗначениеСсылка, СсылкаСтруктурой, ОписаниеТипаДанных["_СвойстваПоиска"]);
		КонецЕсли;
		
		СтекОбработанныхСсылок.Вставить(ЗначениеСсылка, СсылкаСтруктурой);
		
		// Увеличиваем нумератор для обычных ссылок
		Если НЕ СтрНачинаетсяС(КоллекцияТипа, "ПеречислениеСсылка") Тогда
			Гнпп = Гнпп + 1;
		КонецЕсли;
	КонецЕсли;
	
	Если ТолькоСсылка Тогда
		Возврат СсылкаСтруктурой;
	КонецЕсли;
	
	ЗначениеСтруктурой = Новый Структура;
	
	мСтандартныеСвойства = Новый Структура(мСтандартныеРеквизиты[КоллекцияТипа]);
	ЗаполнитьЗначенияСвойств(мСтандартныеСвойства, ЗначениеСсылка);
	
	Если НЕ СтрНачинаетсяС(КоллекцияТипа, "ПеречислениеСсылка") Тогда
		ЗначениеСтруктурой.Вставить("_Гнпп", СсылкаСтруктурой.Гнпп);
	КонецЕсли;
	
	ЗначениеСтруктурой.Вставить("_Тип", ТипСтрокой);
	ЗначениеСтруктурой.Вставить("_Ссылка", СсылкаСтруктурой);
	
	Если СтрНачинаетсяС(КоллекцияТипа, "ДокументСсылка") Тогда
		
		ЗначениеСтруктурой.Вставить("_РежимПроведения", "");
		Если МетаданныеЗначения.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить 
			И МетаданныеЗначения.ОперативноеПроведение = Метаданные.СвойстваОбъектов.ОперативноеПроведение.Разрешить Тогда
			ЗначениеСтруктурой.Вставить("_РежимПроведения", "Оперативный");
		КонецЕсли;
	КонецЕсли;
	
	ЗначениеСтруктурой.Вставить("_Свойства", мСтандартныеСвойства); // Для реквизитов
	ЗначениеСтруктурой.Вставить("_ТабличныеЧасти", Новый Структура); // Для табличных частей
	
	Если НЕ СтрНачинаетсяС(КоллекцияТипа, "ПеречислениеСсылка") Тогда
		
		ВыгрузитьРеквизиты(ЗначениеСсылка, ЗначениеСтруктурой._Свойства, ОписаниеТипаДанных["_Свойства"]);
		ВыгрузитьТабличныеЧасти(ЗначениеСсылка, МетаданныеЗначения, ЗначениеСтруктурой._ТабличныеЧасти, ОписаниеТипаДанных["_ТабличныеЧасти"]);
		
	КонецЕсли;
	
	Возврат ЗначениеСтруктурой;
	
КонецФункции // СериализоватьПоСсылкеВСтруктуру()

// Возвращает сериализованную ссылку на объект.
//
// Параметры:
//   ЗначениеСсылка - ЛюбаяСсылка - ссылка для сериализации.
//   ТипСтрокой - Строка - пример: "ДокументСсылка.ЗаказПокупателя", "СправочникСсылка.Номенклатура"
//
// Возвращаемое значение:
//   Структура - Сериализованные данные ссылки
//
Функция СериализоватьСсылку(ЗначениеСсылка, ТипСтрокой, Нпп)
	
	Если НЕ ЗначениеЗаполнено(ЗначениеСсылка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СсылкаСтруктурой = Новый Структура("Тип", ТипСтрокой);
	
	Если СтрНачинаетсяС(ТипСтрокой, "ПеречислениеСсылка") Тогда
		ИмяЗначения = ПолучитьПолноеИмяПредопределенногоЗначения(ЗначениеСсылка);
		ИмяЗначения = СтрРазделить(ИмяЗначения, ".", Ложь);
		СсылкаСтруктурой.Вставить("Значение", ИмяЗначения[ИмяЗначения.ВГраница()]);
	Иначе
		СсылкаСтруктурой.Вставить("Гнпп", Нпп);
		СсылкаСтруктурой.Вставить("УникальныйИдентификатор", Строка(ЗначениеСсылка.УникальныйИдентификатор()));
	КонецЕсли;
	
	Возврат СсылкаСтруктурой;
	
КонецФункции // СериализоватьСсылкуНаОбъект

// Дополняет данные сериализованной ссылки значениями свойств поиска.
//
// Параметры:
//   ЗначениеСсылка - ЛюбаяСсылка - ссылка на объект, реквизиты которого нужно сериализовать.
//   СсылкаСтруктурой - Структура - данные ссылки объекта.
//   МассивСвойств - Массив из Строка - имена выгружаемых свойств объекта.
//
Процедура ЗаполнитьСвойстваПоиска(ЗначениеСсылка, СсылкаСтруктурой, МассивСвойствПоиска) 
	
	СвойстваПоиска = Новый Структура;
	СсылкаСтруктурой.Вставить("_СвойстваПоиска", СвойстваПоиска);
	
	Если МассивСвойствПоиска.Количество() > 0 Тогда
		ВыгрузитьРеквизиты(ЗначениеСсылка, СвойстваПоиска, МассивСвойствПоиска);
	КонецЕсли;
	
КонецПроцедуры //ЗаполнитьСвойстваПоиска

// Выполняет сериализацию реквизитов объекта.
//
// Параметры:
//   ЗначениеСсылка - ЛюбаяСсылка - ссылка на объект, реквизиты которого нужно сериализовать.
//   СтруктураРеквизитов - Структура - для заполнения сериализованными значениями реквизитов.
//   МассивСвойств - Массив из Строка - имена выгружаемых свойств объекта.
//
// Возвращаемое значение:
//   Неопределено
//
Функция ВыгрузитьРеквизиты(ЗначениеСсылка, СтруктураРеквизитов, МассивСвойств);
	
	Для Каждого ИмяСвойства Из МассивСвойств Цикл
		
		Попытка
			ЗначениеРеквизита = ЗначениеСсылка[ИмяСвойства];
			ЗначениеСвойства = СериализоватьВПростыеТипы(ЗначениеРеквизита, Истина, Истина); // Сначала сериализуем просто как ссылку
			СтруктураРеквизитов.Вставить(ИмяСвойства, ЗначениеСвойства);
			
			// Повторно вызываем для полной сериализации:
			Если  НЕ мТипыПеречислений.СодержитТип(ТипЗнч(ЗначениеРеквизита)) Тогда
				СериализоватьВПростыеТипы(ЗначениеРеквизита, Ложь, Истина);
			КонецЕсли;
		Исключение
		КонецПопытки;
		
	КонецЦикла;
	
КонецФункции

// Выполняет сериализацию табличных частей объекта.
//
// Параметры:
//   ЗначениеСсылка - ЛюбаяСсылка - ссылка на объект, реквизиты которого нужно сериализовать.
//   МетаданныеЗначения - Метаданные - метаданные сериализуемого объекта.
//   СтруктураТабЧастей - Структура - для заполнения сериализованными значениями реквизитов табличных частей.
//
// Возвращаемое значение:
//   Неопределено
//
Функция ВыгрузитьТабличныеЧасти(ЗначениеСсылка, МетаданныеЗначения, СтруктураТабЧастей, ОписаниеСвойствТЧ)
	
	мдТабЧасти = МетаданныеЗначения.ТабличныеЧасти;
	
	Для Каждого ДанныеТЧ Из ОписаниеСвойствТЧ Цикл
		
		ИмяТЧ = ДанныеТЧ.Ключ;
		НаборСвойствТЧ = ДанныеТЧ.Значение;
		
		Попытка
			МетаТЧ = мдТабЧасти[ИмяТЧ];
		Исключение
			Продолжить;
		КонецПопытки;
		
		ДанныеТЧ = ЗначениеСсылка[МетаТЧ.Имя];
		КоличествоСтрок = ДанныеТЧ.Количество();
		Если КоличествоСтрок = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		МассивСтрокТЧ = Новый Массив(КоличествоСтрок);
		Для Каждого СтрокаТЧ Из ДанныеТЧ Цикл
			
			ДанныеСтрокиТЧ = Новый Структура;
			
			Для Каждого СвойствоТЧ Из НаборСвойствТЧ Цикл
				
				ИмяСвойства = СвойствоТЧ.Ключ;
				Попытка
					ЗначениеРеквизита = СтрокаТЧ[ИмяСвойства];
					ЗначениеСвойства = СериализоватьВПростыеТипы(ЗначениеРеквизита, Истина, Истина);
					ДанныеСтрокиТЧ.Вставить(ИмяСвойства, ЗначениеСвойства);
				Исключение
					Продолжить;
				КонецПопытки;
				
				// Повторный вызов для полной сериализации реквизитов ТЧ объекта:
				Если НЕ мТипыПеречислений.СодержитТип(ТипЗнч(ЗначениеРеквизита)) Тогда
					СериализоватьВПростыеТипы(ЗначениеРеквизита, Ложь, Истина);
				КонецЕсли;
			КонецЦикла;
			
			МассивСтрокТЧ.Установить(СтрокаТЧ.НомерСтроки - 1, ДанныеСтрокиТЧ);
			
		КонецЦикла;
		
		СтруктураТабЧастей.Вставить(МетаТЧ.Имя, МассивСтрокТЧ);
		
	КонецЦикла;
	
КонецФункции

Функция ВыгрузитьНаборЗаписей(Источник, КоллекцияТипа, МетаданныеЗначения)	
	
	Данные = Источник.Выгрузить();
	
	ДанныеНабора = Новый Структура("Тип, Отбор, НаборЗаписей");
	ДанныеНабора.Вставить("Тип", КоллекцияТипа + "." + МетаданныеЗначения.Имя);
	ДанныеНабора.Вставить("НаборЗаписей", Данные);
	
	Отбор = Новый Массив;
	Для Каждого ЭлементОтбора Из Источник.Отбор Цикл
		СтруктураОтбора = Новый Структура("Имя, ВидСравнения, Значение");
		СтруктураОтбора.Вставить("Имя",          ЭлементОтбора.Имя);
		СтруктураОтбора.Вставить("ВидСравнения", ЗначениеВСтрокуВнутр(ЭлементОтбора.ВидСравнения));
		СтруктураОтбора.Вставить("Значение",     ЭлементОтбора.Значение);
		СтруктураОтбора.Вставить("Использование",ЭлементОтбора.Использование);
		
		Отбор.Добавить(СтруктураОтбора);
	КонецЦикла;
	ДанныеНабора.Вставить("Отбор", Отбор);
	Возврат ДанныеНабора;
	
КонецФункции

#КонецОбласти

#Область ОбработчикиНеСложныхТипов

Функция обработчик_ЗначениеВСтрокуВнутр(Значение)
	
	Возврат Новый Структура("Тип, Значение", "ЗначениеПлатформыСтрокой", ЗначениеВСтрокуВнутр(Значение));	
	
КонецФункции

Функция обработчик_УникальныйИдентификатор(Значение)
	
	Возврат Новый Структура("Тип, Значение", "{УникальныйИдентификатор}", Строка(Значение));
	
КонецФункции

Функция обработчик_ТаблицаЗначений(Значение)
	
	НовоеЗначение = Новый Массив;
	СтруктураСтроки = ИменаКолонок(Значение);
	Для Каждого Элемент Из Значение Цикл
		СтрокаСтруктурой = Новый Структура(СтруктураСтроки);
		ЗаполнитьЗначенияСвойств(СтрокаСтруктурой, Элемент);
		//todo 
		//Вложенные сложные типы будут обработаны рекурсино или это задача программиста?
		//Строка = ЭлементВПростыеТипы(СтрокаСтруктурой, ТолькоСсылки);
		//Строка.Вставить("Строки", ДанныеВПростыеТипыРекурсивно(Элемент, ТолькоСсылки, СтруктураСтроки));
		НовоеЗначение.Добавить(СтрокаСтруктурой);
	КонецЦикла;
	Возврат НовоеЗначение;	
	
КонецФункции

Функция обработчик_ДеревоЗначений(Значение)
	
	НовоеЗначение = Новый Массив;
	СтруктураСтроки = ИменаКолонок(Значение);
	Для Каждого Элемент Из Значение.Строки Цикл
		СтрокаСтруктурой = Новый Структура(СтруктураСтроки);
		ЗаполнитьЗначенияСвойств(СтрокаСтруктурой, Элемент);
		//todo 
		//Вложенные сложные типы будут обработаны рекурсино или это задача программиста?
		//Строка = ЭлементВПростыеТипы(СтрокаСтруктурой, ТолькоСсылки);
		//Строка.Вставить("Строки", ДанныеВПростыеТипыРекурсивно(Элемент, ТолькоСсылки, СтруктураСтроки));
		НовоеЗначение.Добавить(СтрокаСтруктурой);
	КонецЦикла;
	Возврат НовоеЗначение;
	
КонецФункции

Функция ИменаКолонок(Данные)
	
	СтруктураСтроки = Новый Массив;
	Для Каждого Колонка Из Данные.Колонки Цикл
		СтруктураСтроки.Добавить(Колонка.Имя);
	КонецЦикла;
	Возврат СтрСоединить(СтруктураСтроки, ",");
	
КонецФункции

Функция ОбработчикПроизвольныеДанные(ВходящиеДанные) Экспорт
		
	Если ВходящиеДанные.Свойство("Данные") И ВходящиеДанные.Данные.Свойство("Тип") Тогда
		Если Найти(ВходящиеДанные.Данные.Тип, "Остатки") Тогда
			//ВыполнитьОбработкуОстатки(ВходящиеДанные.Данные)
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

Функция ПустаяСсылка()
	
	Возврат Неопределено;
	
КонецФункции

Функция ЭтоПростойТип(Значение)
	
	Возврат НЕ мПростыеТипыДанных.Получить(ТипЗнч(Значение)) = Неопределено;
	
КонецФункции

// Проверяет участвовал ли переданный элемент справочника в обмене раннее.
// Если нет - регистрирует его для записи в рег. св. "СМП_ВыгруженныеСправочники".
//
// Параметры:
//   ЗначениеСсылка - СправочникСсылка - ссылка на проверяемый элемент справочника.
//
// Возвращаемое значение:
//   Булево - признак того, что объект польностью сериализовывался и отсылался в предыдущих сеансах обмена.
//
Функция ЭтотОбъектУжеОтсылался(ЗначениеСсылка) 
	
	РезультатПроверки = Ложь;
	
	//Если ЗначениеСсылка.Пустая() Тогда
	//	Возврат РезультатПроверки;
	//КонецЕсли;
	
	// 1. Смотрим в локальные стеки:
	РезультатУже = СтекУжеВыгружались.Получить(ЗначениеСсылка);
	РезультатЕще = СтекЕщеНеВыгружались.Получить(ЗначениеСсылка);
	Если РезультатУже <> Неопределено Тогда // Эта ссылка повторяется и была добавлена раннее.
		РезультатПроверки = Истина;
	Иначе
		
		// 2. Проверяем по регистру:
		ПроверкаПоРегистру = РегистрыСведений.СМП_ВыгруженныеСправочники.ПроверитьВыгрузкуЭлементаСправочника(
			ЗначениеСсылка, УчетнаяЗаписьОбмена);
			
		Если ПроверкаПоРегистру = Неопределено Тогда // Объект вв предыдущих сеансах обмена не выгружался
			
			СтекЕщеНеВыгружались.Вставить(ЗначениеСсылка, Новый УникальныйИдентификатор);
			
		Иначе
			
			// Объект выгружался в предыдущих сеансах обмена, но здесь встречается в первый раз.
			// Добавим его в локальный стек для быстрого поиска:
			СтекУжеВыгружались.Вставить(ЗначениеСсылка, Новый УникальныйИдентификатор);
			РезультатПроверки = Истина;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат РезультатПроверки;
	
КонецФункции // ЭтотОбъектУжеОтсылался

// .
//
// Параметры:
//   <Параметр1> - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//   <Параметр2> - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
Процедура ДополнитьСтекСсылокСледующегоУровня(ЗначениеСсылка) 
	
	//слУровень = УровеньВложенности + 1;
	//МассивСсылок = СтекСсылкиКОбработке.Получить(слУровень);
	//Если МассивСсылок = Неопределено Тогда
	//	
	//	МассивСсылок = Новый Массив;
	//	МассивСсылок.Добавить(ЗначениеСсылка);
	//	СтекСсылкиКОбработке.Вставить(слУровень, МассивСсылок);
	//	
	//Иначе
	//	
	//	МассивСсылок.Добавить(ЗначениеСсылка);
	//	//СтекСсылкиКОбработке[слУровень].Добавить(ЗначениеСсылка);
	//КонецЕсли;
	
КонецПроцедуры //ДополнитьСтекСсылокСледующегоУровня(Значение)


// Переписать На использование функции БСП в будущем
Функция ЭтоСсылка(Значение) 
	
	ТипЗначения = ТипЗнч(Значение);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗначения)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(ТипЗначения) 
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипЗначения)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипЗначения) 
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипЗначения)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипЗначения) 
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(ТипЗначения)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(ТипЗначения) 
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(ТипЗначения) Тогда
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции // ЭтоСсылка

#Область ПроцедурыИнициализации

// Выполняет инициализацию контейнера с именами функций для обработки нестандартных типов данных.
//
// Параметры:
//   Нет.
//
Процедура ИнициализироватьОбработчикиТипов()
	
	ОбработчикиТипов = Новый Соответствие;
	ОбработчикиТипов.Вставить(Тип("null"),                    "обработчик_ЗначениеВСтрокуВнутр(Значение)");
	ОбработчикиТипов.Вставить(Тип("ДвоичныеДанные"),          "обработчик_ЗначениеВСтрокуВнутр(Значение)");
	ОбработчикиТипов.Вставить(Тип("ХранилищеЗначения"),       "обработчик_ЗначениеВСтрокуВнутр(Значение)");
	ОбработчикиТипов.Вставить(Тип("ТабличныйДокумент"),       "обработчик_ЗначениеВСтрокуВнутр(Значение)");	
	ОбработчикиТипов.Вставить(Тип("УникальныйИдентификатор"), "обработчик_УникальныйИдентификатор(Значение)");	
	ОбработчикиТипов.Вставить(Тип("ТаблицаЗначений"),         "обработчик_ТаблицаЗначений(Значение)");
	ОбработчикиТипов.Вставить(Тип("ДеревоЗначений"),          "обработчик_ДеревоЗначений(Значение)");
	ОбработчикиТипов.Вставить(Тип("ОписаниеТипов"),           "обработчик_ЗначениеВСтрокуВнутр(Значение)");
	ОбработчикиТипов.Вставить(Тип("Тип"),                     "обработчик_ЗначениеВСтрокуВнутр(Значение)");
	ОбработчикиТипов.Вставить(Тип("ВидДвиженияНакопления"),   "обработчик_ЗначениеВСтрокуВнутр(Значение)");
	ОбработчикиТипов.Вставить(Тип("МоментВремени"),           "обработчик_ЗначениеВСтрокуВнутр(Значение)");
	
	ОбработчикиТипов.Вставить("Ссылка",       "обработчик_Ссылка(Значение)");
	ОбработчикиТипов.Вставить("Перечисление", "обработчик_Перечисление(Значение)");
	
КонецПроцедуры

// Выполняет инициализацию контейнера с наборами имен стандартных реквизитов для объектов ссылочного типа.
//
// Параметры:
//   Нет.
//
Процедура ИнициализироватьСтандартныеРеквизитыОбъектов()
	
	// Владелец, ЭтоГруппа, Родитель, - вычисляются отдельно
	
	мСтандартныеРеквизиты = Новый Соответствие;
	мСтандартныеРеквизиты.Вставить("СправочникСсылка", 
		"Код, Наименование, ПометкаУдаления, Предопределенный, ИмяПредопределенныхДанных");
	
	мСтандартныеРеквизиты.Вставить("ДокументСсылка", 
		"Номер, Дата, Проведен, ПометкаУдаления");
	
	мСтандартныеРеквизиты.Вставить("ПланСчетовСсылка", 
		"Код, Наименование, Порядок, Вид, Забалансовый, ПометкаУдаления, Предопределенный, ИмяПредопределенныхДанных");
	
	мСтандартныеРеквизиты.Вставить("ПланВидовХарактеристикСсылка", 
		"Код, Наименование, ТипЗначения, ПометкаУдаления, Предопределенный, ИмяПредопределенныхДанных");
	
	мСтандартныеРеквизиты.Вставить("ПланВидовРасчетаСсылка", 
		"Код, Наименование, ПометкаУдаления, Предопределенный, ИмяПредопределенныхДанных"); // todo еще периоддействия базовый надо вычислять
	
	мСтандартныеРеквизиты.Вставить("БизнесПроцессСсылка", 
		"Код, Наименование, ПометкаУдаления, Предопределенный, ИмяПредопределенныхДанных"); // to do: дописать ещё реквизиты
	
	// to do: дописать ЗадачаСсылка
	
КонецПроцедуры

// Выполняет инициализацию контейнера с простыми типами данных.
//
// Параметры:
//   Нет.
//
Процедура ИнициализироватьПростыеТипыДанных()
	
	мПростыеТипыДанных = Новый Соответствие;
	мПростыеТипыДанных.Вставить(Тип("Строка"), "");
	мПростыеТипыДанных.Вставить(Тип("Число"), "");
	мПростыеТипыДанных.Вставить(Тип("Булево"), "");
	мПростыеТипыДанных.Вставить(Тип("Дата"), "");
	мПростыеТипыДанных.Вставить(Тип("Неопределено"), "");
	//мПростыеТипыДанных.Вставить(Тип("Null"), "");
	//мПростыеТипыДанных.Вставить(Тип("УникальныйИдентификатор"), "");
	
КонецПроцедуры

// Заполняет описания выгружаемых типов данных.
//
// Параметры:
//   Нет.
//
Процедура ЗаполнитьОписаниеВыгружаемыхТиповДанных() Экспорт 
	
	РезультатЧтения = Неопределено;
	
	ОписаниеJSON = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(УчетнаяЗаписьОбмена, "ОписаниеВыгружаемыхДанных");
	
	Если ПустаяСтрока(ОписаниеJSON) Тогда
		Возврат;
		// to do: добавить вывод предупреждения или ошибки
	КонецЕсли;
	
	мЧтение = Новый ЧтениеJSON;
	мЧтение.УстановитьСтроку(ОписаниеJSON);
	
	Попытка
		РезультатЧтения = ПрочитатьJSON(мЧтение, Истина);
	Исключение
		ВызватьИсключение ОписаниеОшибки();
	КонецПопытки;
	
	мЧтение.Закрыть();
	
	Для Каждого ОписаниеДанных Из РезультатЧтения Цикл
		
		ТипДанных = Тип(ОписаниеДанных.Ключ);
		сОписаниеВыгружаемыхДанных.Вставить(ТипДанных, ОписаниеДанных.Значение);
		
	КонецЦикла;
	
КонецПроцедуры //ИнициализироватьОписаниеВыгружаемыхТиповДанных

#КонецОбласти

#КонецОбласти

#Область РЕФАКТОРИНГ

#Область Десериализация

Функция ЗаполнитьСсылки(ДанныеСтруктурой) Экспорт
	
	ТипДанных = ТипЗнч(ДанныеСтруктурой);
	Если Не ТипДанных = Тип("Структура") Тогда
		ВызватьИсключение СтрШаблон("Ошибка десериализации. Получены данные типа %1, а ожидается ""Структура""", ТипДанных);
	КонецЕсли;
	
	Для Каждого ЭлементДанных Из ДанныеСтруктурой Цикл
		Если ТипЗнч(ЭлементДанных.Значение) = Тип("Структура") Тогда
			
			Если ЭлементДанных.Значение.Свойство("Тип") Тогда
				Тип = ЭлементДанных.Значение.Тип;
				Если Найти(Тип, ".") Тогда
					ИмяТипа = СтрРазделить(ЭлементДанных.Значение.Тип, ".");
					Если ИмяТипа.Количество() > 1 Тогда
						ИмяТипа = ИмяТипа[1];
					Иначе
						Продолжить; // Todo
					КонецЕсли;
				Иначе
					ИмяТипа = Тип;
				КонецЕсли;
				
				Если ИмяТипа = "ЗначениеПлатформыСтрокой" Тогда
					Если ТипЗнч(ЭлементДанных.Значение.Значение) = Тип("Строка") Тогда
						Значение = ЗначениеИзСтрокиВнутр(ЭлементДанных.Значение.Значение);
					Иначе
						Значение = ЭлементДанных.Значение.Значение;
					КонецЕсли;
				ИначеЕсли ИмяТипа = "УникальныйИдентификатор" Тогда
					Значение = Новый УникальныйИдентификатор(ЭлементДанных.Значение.Значение);					
				Иначе					
					Значение = НайтиПоРеквизитамИзСтруктуры(ЭлементДанных.Значение, ИмяТипа);
				КонецЕсли;
				
		        ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ, Значение);
				ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ + "_До", ЭлементДанных.Значение);
			Иначе
				ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ, ЭлементДанных.Значение);
				ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ + "_До", ЭлементДанных.Значение);
			КонецЕсли;
			
		ИначеЕсли СтрДлина(ЭлементДанных.Значение) = 19 и Сред(ЭлементДанных.Значение,11,1) = "T" Тогда
			
			Значение = ДатаИзJSON(ЭлементДанных.Значение);
			ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ, Значение);
			ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ + "_До", ЭлементДанных.Значение);
			
		ИначеЕсли СтрДлина(ЭлементДанных.Значение) = 36 и СтрРазделить(ЭлементДанных.Значение, "-").Количество() = 5 Тогда // уникальный идентификатор?
			
			Попытка
				Значение = Новый УникальныйИдентификатор(ЭлементДанных.Значение);
			Исключение
				Значение = Строка(ЭлементДанных.Значение);
			КонецПопытки;
			ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ, Значение);
			ДанныеСтруктурой.Вставить(ЭлементДанных.Ключ + "_До", ЭлементДанных.Значение);
			
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Функция НайтиПоРеквизитамИзСтруктуры(ДанныеСтруктурой, ИмяТипа) Экспорт
	
	Если ТипЗнч(ДанныеСтруктурой) = Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Значение = Неопределено;
	
	СсылкаНайдена = Ложь;
	Если Найти(ДанныеСтруктурой.Тип, "СправочникСсылка") Тогда
		Значение = Неопределено;
		Если НЕ ВыполнитьАлгоритмПоиска(ИмяТипа, ДанныеСтруктурой, Значение) Тогда
			Если Метаданные.Справочники.Найти(ИмяТипа) = Неопределено Тогда
				Значение = Неопределено;		
			Иначе
				Если ДанныеСтруктурой.Свойство("ИмяПредопределенныхДанных") И ЗначениеЗаполнено(ДанныеСтруктурой.ИмяПредопределенныхДанных) Тогда
					Попытка
						Значение = Справочники[ИмяТипа][ДанныеСтруктурой.ИмяПредопределенныхДанных];
					Исключение
						Значение = Справочники[ИмяТипа].ПолучитьСсылку(Новый УникальныйИдентификатор(ДанныеСтруктурой.Ссылка));	
					КонецПопытки;
				Иначе
					Значение = Справочники[ИмяТипа].ПолучитьСсылку(Новый УникальныйИдентификатор(ДанныеСтруктурой.Ссылка));	
				КонецЕсли;								
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Найти(ДанныеСтруктурой.Тип, "ДокументСсылка") Тогда		
		Если НЕ СсылкаНайдена Тогда
			Если Метаданные.Документы.Найти(ИмяТипа) = Неопределено Тогда
				Значение = Неопределено;
			Иначе
				Значение = Документы[ИмяТипа].ПолучитьСсылку(Новый УникальныйИдентификатор(ДанныеСтруктурой.Ссылка));
			КонецЕсли;
		КонецЕсли;	
	ИначеЕсли Найти(ДанныеСтруктурой.Тип, "ПеречислениеСсылка") Тогда
		ЗначениеПеречисления = ДанныеСтруктурой.Значение;		
		Мета = Метаданные.Перечисления.Найти(ИмяТипа);
		Если Мета = Неопределено Тогда
			Значение = Неопределено;
		Иначе	
			Если ЗначениеПеречисления = "ПустаяСсылка" Тогда
				Значение = Перечисления[ИмяТипа].ПустаяСсылка();
			Иначе
				Если НЕ Метаданные.Перечисления.Найти(ИмяТипа).ЗначенияПеречисления.Найти(ЗначениеПеречисления) = Неопределено Тогда
					Значение = Перечисления[ИмяТипа][ЗначениеПеречисления];
				Иначе
					Значение = Неопределено;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Найти(ДанныеСтруктурой.Тип, "ПланСчетовСсылка") Тогда
		Мета = Метаданные.ПланыСчетов.Найти(ИмяТипа);
		Если Мета = Неопределено Тогда
			Значение = Неопределено;
		Иначе	
			Значение = ПланыСчетов[ИмяТипа].ПолучитьСсылку(Новый УникальныйИдентификатор(ДанныеСтруктурой.Ссылка));
		КонецЕсли;
	ИначеЕсли Найти(ДанныеСтруктурой.Тип, "ПланВидовХарактеристикСсылка") Тогда
		Мета = Метаданные.ПланыВидовХарактеристик.Найти(ИмяТипа);
		Если Мета = Неопределено Тогда
			Значение = Неопределено;
		Иначе
			Значение = ПланыВидовХарактеристик[ИмяТипа].ПолучитьСсылку(Новый УникальныйИдентификатор(ДанныеСтруктурой.Ссылка));
		КонецЕсли;
	ИначеЕсли Найти(ДанныеСтруктурой.Тип, "ПланВидовРасчетаСсылка") Тогда		
		Значение = Неопределено;
		Если НЕ ВыполнитьАлгоритмПоиска(ИмяТипа, ДанныеСтруктурой, Значение) Тогда
			Мета = Метаданные.ПланыВидовРасчета.Найти(ИмяТипа);
			Если Мета = Неопределено Тогда
				Значение = Неопределено;
			Иначе
				Значение = ПланыВидовРасчета[ИмяТипа].ПолучитьСсылку(Новый УникальныйИдентификатор(ДанныеСтруктурой.Ссылка));		
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли Найти(ДанныеСтруктурой.Тип, "БизнесПроцессСсылка") Тогда
		Мета = Метаданные.БизнесПроцессы.Найти(ИмяТипа);
		Если Мета = Неопределено Тогда
			Значение = Неопределено;
		Иначе
			Значение = БизнесПроцессы[ИмяТипа].ПолучитьСсылку(Новый УникальныйИдентификатор(ДанныеСтруктурой.Ссылка));		
		КонецЕсли;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Функция ДатаИзJSON(СтрокаJSON, ФорматДаты = "") Экспорт

	ФорматДаты = ?(ФорматДаты = "",ФорматДатыJSON.ISO,ФорматДаты);
	Дата1С = Неопределено;
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку("{
	|""date"": """+СтрокаJSON+"""
	|}");
	Попытка
		Дата1С = ПрочитатьJSON(ЧтениеJSON, Ложь, "date", ФорматДаты).date;
	Исключение
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	ЧтениеJSON.Закрыть();
	
	Возврат Дата1С;
	
КонецФункции // СтруктураВJSON()

#КонецОбласти

#Область ПрочитатьJSON_Расширенная

Функция ПрочитатьJSON_Расширенная(СтрокаJSON, ИменаПолейСДатами = "date") Экспорт

	СтруктураJSON = Неопределено;
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	Попытка
		СтруктураJSON = ПрочитатьJSON(ЧтениеJSON, Ложь, ИменаПолейСДатами, ФорматДатыJSON.ISO);
	Исключение
		ВызватьИсключение ОписаниеОшибки();
	КонецПопытки;
	ЧтениеJSON.Закрыть();
	
	// todo восстановить даты рекурсивно
	
	Возврат СтруктураJSON;
	
КонецФункции // СтруктураВJSON()

Функция ПрочитатьJSON_Стандартная(СтрокаJSON, ИменаПолейСДатами = "date") Экспорт

	СтруктураJSON = Неопределено;
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	Попытка
		СтруктураJSON = ПрочитатьJSON(ЧтениеJSON, Ложь, ИменаПолейСДатами, ФорматДатыJSON.ISO);
	Исключение
		ВызватьИсключение ОписаниеОшибки();
	КонецПопытки;
	ЧтениеJSON.Закрыть();
	
	Возврат СтруктураJSON;
	
КонецФункции // СтруктураВJSON()

#КонецОбласти

#Область ПарсингВходящихДанных 

Функция ЗаписатьДанные() Экспорт
	
	Если Не ЗначениеЗаполнено(ВходящиеДанные) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Не ТипЗнч(ВходящиеДанные) = Тип("Структура") Тогда
		ВызватьИсключение "Не верный тип входящих данных. Получено: " + ТипЗнч(ВходящиеДанные) + ". Ожидается - структура";		
	КонецЕсли;
	
	Если ВходящиеДанные.Свойство("Тип") Тогда
		Если Найти(ВходящиеДанные.Тип, "СправочникСсылка") Тогда
			ВыполнитьОбработку_Справочник();
		ИначеЕсли Найти(ВходящиеДанные.Тип, "ДокументСсылка") Тогда
			ВыполнитьОбработку_Документ();
		ИначеЕсли Найти(ВходящиеДанные.Тип, "ПланВидовХарактеристикСсылка") Тогда
			ВыполнитьОбработку_ПланВидовХарактеристик();
		ИначеЕсли Найти(ВходящиеДанные.Тип, "ПланВидовРасчета") Тогда
			ВыполнитьОбработку_ПланВидовРасчета();
		ИначеЕсли Найти(ВходящиеДанные.Тип, "РегистрСведений") Тогда
			ВыполнитьОбработку_РегистрСведений();
		ИначеЕсли Найти(ВходящиеДанные.Тип, "РегистрНакопления") Тогда
			ВыполнитьОбработку_РегистрНакопления();
		ИначеЕсли Найти(ВходящиеДанные.Тип, "РегистрРасчета") Тогда
			ВыполнитьОбработку_РегистрРасчета();
		КонецЕсли;
	Иначе
		Если НЕ ПравилаКонвертации = Неопределено Тогда
			ФункцияПравил = Неопределено;
			ПравилаКонвертации.Манифест.Свойство("ОбработчикПроизвольныеДанные", ФункцияПравил);
			Если Не ФункцияПравил = Неопределено Тогда
				ТекстВызоваФункции = СтрШаблон("ПравилаКонвертации.%1(ВходящиеДанные)", ФункцияПравил);
				Выполнить(ТекстВызоваФункции);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ПравилаКонвертацииИсточник

Функция СтруктураДокумента()
	Структура = "Дата, Номер, Ссылка, СуммаВключаетНДС, Контрагент, Склад, ДоговорКонтрагента, ДокументРеализации, ДокументПоступления";
	
	Структура = Новый Структура(Структура);	
	
	Возврат Структура;
КонецФункции

Функция СтруктураСправочника()
	Структура = "Код, Наименование, Ссылка";
	
	Структура = Новый Структура(Структура);	
	
	Возврат Структура;
КонецФункции

Функция СтруктураКонтрагента()
	Структура = СтруктураСправочника();
	
	Возврат Структура;
КонецФункции

Функция СтруктураДоговора()
	Структура = СтруктураСправочника();
	
	Возврат Структура;
КонецФункции

Функция СтруктураНоменклатуры()
	Структура = СтруктураСправочника();
	Структура.Вставить("Артикул");
	
	Возврат Структура;
КонецФункции

Функция ТЧМассивом(ТЧ)
	ТЧМассивом = Новый Массив;
	Для Каждого Строка Из ТЧ Цикл
		НоваяСтрока = СтруктураСтрокаТЧ();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		НоваяСтрока.Номенклатура = СправочникСтруктурой(НоваяСтрока.Номенклатура);
		ТЧМассивом.Добавить(НоваяСтрока);
	КонецЦикла;
	
	Возврат ТЧМассивом;
КонецФункции

Функция СтруктураСтрокаТЧ()
	СтруктураСтрокаТЧ = "Номенклатура, Количество, Цена, Сумма, СуммаНДС, СтавкаНДС";
	СтруктураСтрокаТЧ = Новый Структура(СтруктураСтрокаТЧ );
	
	Возврат СтруктураСтрокаТЧ;
КонецФункции

Функция ДокументСтруктурой(Значение)
	Данные = СтруктураДокумента();
	ЗаполнитьЗначенияСвойств(Данные, Значение);
	Данные.Вставить("Организация", СправочникСтруктурой(Значение.Организация));
	Данные.Вставить("Контрагент", СправочникСтруктурой(Значение.Контрагент));
	Данные.Вставить("ДоговорКонтрагента", СправочникСтруктурой(Значение.ДоговорКонтрагента));
	Данные.Вставить("Товары", ТЧМассивом(Значение.Товары));
	Данные.Вставить("Услуги", ТЧМассивом(Значение.Услуги));
	
	Данные.Вставить("Ссылка", Строка(Значение.УникальныйИдентификатор()));
	Данные.Вставить("Тип", Строка(ТипЗнч(Значение)));
	
	Возврат Данные;
КонецФункции

Функция СправочникСтруктурой(Значение)
	Если ТипЗнч(Значение) = Тип("СправочникСсылка.Номенклатура") Тогда
		Данные = СтруктураНоменклатуры();
	Иначе
		Данные = СтруктураСправочника();
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(Данные, Значение);
	
	Данные.Вставить("Ссылка", Строка(Значение.УникальныйИдентификатор()));	
	Данные.Вставить("Тип", Строка(ТипЗнч(Значение)));
	Возврат Данные;
КонецФункции

#КонецОбласти

#Область ПравилаКонвертацииПриемник

Функция ВыполнитьОбработку_Документ();
	
	ТипОбъекта = СтрРазделить(ВходящиеДанные.Тип, ".")[1];
	
	Ссылка = ПолучитьСсылку_НаДокументПоИдентификатору(ВходящиеДанные);
	Объект1с = Ссылка.ПолучитьОбъект();	
	
	Если Объект1с = Неопределено Тогда		
		Объект1с = Документы[ТипОбъекта].СоздатьДокумент();
		Объект1с.УстановитьСсылкуНового(Ссылка);
	КонецЕсли;	
	
	ЗаполнитьСсылки(ВходящиеДанные);	
	ЗаполнитьЗначенияСвойств(Объект1с, ВходящиеДанные);	

	Если ВходящиеДанные.Свойство("ТЧ") Тогда
		Для Каждого ТЧ Из ВходящиеДанные.ТЧ Цикл
			Попытка
				Объект1с[ТЧ.Ключ].Очистить();
				Для Каждого Строка Из ТЧ.Значение Цикл
					ЗаполнитьСсылки(Строка);	
					НоваяСтрока = Объект1с[ТЧ.Ключ].Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);					
				КонецЦикла;
			Исключение
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
	
	//Если ТипОбъекта = "ПроизводствоБезЗаказа" Тогда
	//	ВыполнитьОбработку_ПроизводствоБезЗаказа(Объект1с);	
	//КонецЕсли;
	
	ВыполнитьАлгоритм("ПередЗаписью", Объект1с, Отказ);
	
	ЗаписатьДокумент(Объект1с);	
	
	ВыполнитьАлгоритм("ПриЗаписи", Объект1с, Отказ);
	
	Возврат Объект1с.Ссылка;
	
КонецФункции

Функция ВыполнитьОбработку_Справочник()
		
	ТипОбъекта = СтрРазделить(ВходящиеДанные.Тип, ".")[1];
	
	ВыполнитьАлгоритм("ПередОбработкой", Неопределено, Отказ);	
	Если Отказ Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// todo Обработчик поиска
	ПолучитьСсылкуНаСправочник();
	
	// todo Обработчик получение объекта
	Если Не СсылкаНаОбъект = Неопределено Тогда
		Попытка
			Объект1с = СсылкаНаОбъект.ПолучитьОбъект();
		Исключение
		КонецПопытки;
	Иначе
		Объект1с = Неопределено;
	КонецЕсли;
	
	Если НЕ Объект1с = Неопределено Тогда
		Возврат СсылкаНаОбъект;
	КонецЕсли;
		
	// todo Обработчик создание объекта
	Если Объект1с = Неопределено Тогда
		Если ВходящиеДанные.Свойство("ЭтоГруппа") И ВходящиеДанные.ЭтоГруппа Тогда
			Объект1с = Справочники[ТипОбъекта].СоздатьГруппу();
		Иначе
			Объект1с = Справочники[ТипОбъекта].СоздатьЭлемент();
		КонецЕсли;
		Если Не СсылкаНаОбъект = Неопределено Тогда
			Объект1с.УстановитьСсылкуНового(СсылкаНаОбъект);
		КонецЕсли;
	КонецЕсли;
	
	// todo Обработчик заполнение реквизитов
	ЗаполнитьСсылки(ВходящиеДанные);	
	ЗаполнитьЗначенияСвойств(Объект1с, ВходящиеДанные, , ИсключаяСвойстваСправочник(ТипОбъекта));
	
	// todo Обработчик заполнение табличных частей
	Если ВходящиеДанные.Свойство("ТЧ") Тогда
		Для Каждого ТЧ Из ВходящиеДанные.ТЧ Цикл
			Попытка
				Объект1с[ТЧ.Ключ].Очистить();
				Для Каждого Строка Из ТЧ.Значение Цикл
					ЗаполнитьСсылки(Строка);	
					НоваяСтрока = Объект1с[ТЧ.Ключ].Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);					
				КонецЦикла;
			Исключение
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
		
	ВыполнитьАлгоритм("ПередЗаписью", Объект1с, Отказ);
		
	Объект1с.ОбменДанными.Загрузка = Истина;
	Объект1с.Записать();
	
	ВыполнитьАлгоритм("ПриЗаписи", Объект1с, Отказ);
	
	Возврат Объект1с.Ссылка;
	
КонецФункции

Функция ВыполнитьОбработку_ПланВидовХарактеристик()
	
	ТипОбъекта = СтрРазделить(ВходящиеДанные.Тип, ".")[1];
	// todo Обработчик перед обработкой
	Если ТипОбъекта = "РесурсныеСпецификации" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// todo Обработчик поиска
	Ссылка = ПолучитьСсылкуНаПланВидовХарактеристик(ВходящиеДанные);
	
	// todo Обработчик получение объекта
	Если Не Ссылка = Неопределено Тогда
		Попытка
			Объект1с = Ссылка.ПолучитьОбъект();
		Исключение
		КонецПопытки;
	Иначе
		Объект1с = Неопределено;
	КонецЕсли;
	
	// todo Обработчик создание объекта
	Если Объект1с = Неопределено Тогда
		Если ВходящиеДанные.Свойство("ЭтоГруппа") И ВходящиеДанные.ЭтоГруппа Тогда
			Объект1с = ПланыВидовХарактеристик[ТипОбъекта].СоздатьГруппу();
		Иначе
			Объект1с = ПланыВидовХарактеристик[ТипОбъекта].СоздатьЭлемент();
		КонецЕсли;
		Если Не Ссылка = Неопределено Тогда
			Объект1с.УстановитьСсылкуНового(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
	// todo Обработчик заполнение реквизитов
	ЗаполнитьСсылки(ВходящиеДанные);	
	ЗаполнитьЗначенияСвойств(Объект1с, ВходящиеДанные, , ИсключаяСвойстваПланВидовХарактеристик(ТипОбъекта));
	
	// todo Обработчик заполнение табличных частей
	Если ВходящиеДанные.Свойство("ТЧ") Тогда
		Для Каждого ТЧ Из ВходящиеДанные.ТЧ Цикл
			Попытка
				Объект1с[ТЧ.Ключ].Очистить();
				Для Каждого Строка Из ТЧ.Значение Цикл
					ЗаполнитьСсылки(Строка);	
					НоваяСтрока = Объект1с[ТЧ.Ключ].Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);					
				КонецЦикла;
			Исключение
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
		
	ФункцияПравил = Неопределено;
	Если НЕ ПравилаКонвертации = Неопределено Тогда
		Обработчики = Неопределено;
		ПравилаКонвертации.Манифест.Свойство(ТипОбъекта, Обработчики);
		Если Не Обработчики = Неопределено Тогда
			Обработчики.Свойство("ПередЗаписью", ФункцияПравил);
		КонецЕсли;
	КонецЕсли;
	
	Если Не ФункцияПравил = Неопределено Тогда
		ТекстВызоваФункции = СтрШаблон("ПравилаКонвертации.%1(Объект1с, ВходящиеДанные)", ФункцияПравил);
		Выполнить(ТекстВызоваФункции);
	КонецЕсли;
		
	Объект1с.ОбменДанными.Загрузка = Истина;
	Объект1с.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);
	Объект1с.Записать();
	
	// todo Обработчик обработчик при записи
	
	Возврат Объект1с.Ссылка;
	
КонецФункции

Функция ВыполнитьОбработку_ПланВидовРасчета()
	
	ТипОбъекта = СтрРазделить(ВходящиеДанные.Тип, ".")[1];
	// todo Обработчик перед обработкой
	Если ТипОбъекта = "РесурсныеСпецификации" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// todo Обработчик поиска
	Ссылка = ПолучитьСсылкуНаПланВидовРасчета(ВходящиеДанные);
	
	// todo Обработчик получение объекта
	Если Не Ссылка = Неопределено Тогда
		Попытка
			Объект1с = Ссылка.ПолучитьОбъект();
		Исключение
		КонецПопытки;
	Иначе
		Объект1с = Неопределено;
	КонецЕсли;
	
	// todo Обработчик создание объекта
	Если Объект1с = Неопределено Тогда
		Объект1с = ПланыВидовРасчета[ТипОбъекта].СоздатьВидРасчета();
		Если Не Ссылка = Неопределено Тогда
			Объект1с.УстановитьСсылкуНового(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
	// todo Обработчик заполнение реквизитов
	ЗаполнитьСсылки(ВходящиеДанные);	
	ЗаполнитьЗначенияСвойств(Объект1с, ВходящиеДанные);//, , ИсключаяСвойстваПланВидовРасчета(ТипОбъекта));
	
	// todo Обработчик заполнение табличных частей
	Если ВходящиеДанные.Свойство("ТЧ") Тогда
		Для Каждого ТЧ Из ВходящиеДанные.ТЧ Цикл
			Попытка
				Объект1с[ТЧ.Ключ].Очистить();
				Для Каждого Строка Из ТЧ.Значение Цикл
					ЗаполнитьСсылки(Строка);	
					НоваяСтрока = Объект1с[ТЧ.Ключ].Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);					
				КонецЦикла;
			Исключение
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
		
	ФункцияПравил = Неопределено;
	Если НЕ ПравилаКонвертации = Неопределено Тогда
		Обработчики = Неопределено;
		ПравилаКонвертации.Манифест.Свойство(ТипОбъекта, Обработчики);
		Если Не Обработчики = Неопределено Тогда
			Обработчики.Свойство("ПередЗаписью", ФункцияПравил);
		КонецЕсли;
	КонецЕсли;
	
	Если Не ФункцияПравил = Неопределено Тогда
		ТекстВызоваФункции = СтрШаблон("ПравилаКонвертации.%1(Объект1с, ВходящиеДанные)", ФункцияПравил);
		Выполнить(ТекстВызоваФункции);
	КонецЕсли;
		
	Объект1с.ОбменДанными.Загрузка = Истина;
	Объект1с.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);
	Объект1с.Записать();
	
	// todo Обработчик обработчик при записи
	
	Возврат Объект1с.Ссылка;
КонецФункции

Функция ВыполнитьОбработку_РегистрСведений()	
	
	// todo очистка набора записей так не сработает
	Если ВходящиеДанные.НаборЗаписей.Количество() = 0 Тогда
		Возврат Неопределено
	КонецЕсли;
	
	ТипОбъекта = СтрРазделить(ВходящиеДанные.Тип, ".")[1];
	
	Мета = Метаданные.РегистрыСведений.Найти(ТипОбъекта);
	Если Мета = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Мета.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда // запись с отборами
		НаборЗаписей = РегистрыСведений[ТипОбъекта].СоздатьНаборЗаписей();
		
		Для Каждого ЭлементОтбора Из ВходящиеДанные.Отбор Цикл
			Если ЭлементОтбора.Использование Тогда
				ЗаполнитьСсылки(ЭлементОтбора);		
				НаборЗаписей.Отбор[ЭлементОтбора.Имя].Установить(ЭлементОтбора.Значение);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Строка Из ВходящиеДанные.НаборЗаписей Цикл
			ЗаполнитьСсылки(Строка);	
			
			НоваяСтрока = НаборЗаписей.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);		
		КонецЦикла;
		
		НаборЗаписей.ОбменДанными.Загрузка = Истина;
		НаборЗаписей.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);	
		
		ВыполнитьАлгоритм("ПередЗаписью", НаборЗаписей, Отказ);	
					
		НаборЗаписей.Записать();
		
		ВыполнитьАлгоритм("ПриЗаписи", НаборЗаписей, Отказ);		
	Иначе // запись через менеджер		
		Для Каждого Строка Из ВходящиеДанные.НаборЗаписей Цикл
			НаборЗаписей = РегистрыСведений[ТипОбъекта].СоздатьНаборЗаписей();
			ЗаполнитьСсылки(Строка);
					
			Для Каждого ЭлементОтбора Из ВходящиеДанные.Отбор Цикл
				НаборЗаписей.Отбор[ЭлементОтбора.Имя].Установить(Строка[ЭлементОтбора.Имя]);				
			КонецЦикла;
			
			НоваяЗапись = НаборЗаписей.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Строка);
			
			НаборЗаписей.ОбменДанными.Загрузка = Истина;
			НаборЗаписей.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);	
			
			ВыполнитьАлгоритм("ПередЗаписью", НаборЗаписей, Отказ);	
						
			НаборЗаписей.Записать();
			
			ВыполнитьАлгоритм("ПриЗаписи", НаборЗаписей, Отказ);		
		КонецЦикла;
	КонецЕсли;	
КонецФункции

Функция ВыполнитьОбработку_РегистрНакопления()	
	
	Если ВходящиеДанные.НаборЗаписей.Количество() = 0 Тогда
		Возврат Неопределено
	КонецЕсли;
	
	ТипОбъекта = СтрРазделить(ВходящиеДанные.Тип, ".")[1];
	
	НаборЗаписей = РегистрыНакопления[ТипОбъекта].СоздатьНаборЗаписей();
	
	Для Каждого ЭлементОтбора Из ВходящиеДанные.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			ЗаполнитьСсылки(ЭлементОтбора);		
			НаборЗаписей.Отбор[ЭлементОтбора.Имя].Установить(ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Строка Из ВходящиеДанные.НаборЗаписей Цикл	
		ЗаполнитьСсылки(Строка);
		Запись = НаборЗаписей.Добавить();
		ЗаполнитьЗначенияСвойств(Запись, Строка);		
	КонецЦикла;
	
	НаборЗаписей.ОбменДанными.Загрузка = Истина;
	НаборЗаписей.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);	
	НаборЗаписей.Записать();
	
	//Если ТипОбъекта = "ШтрихкодыНоменклатуры" Тогда
	//	ВыполнитьОбработку_ШтрихкодыНоменклатуры(НаборЗаписей);	
	//КонецЕсли;	
КонецФункции

Функция ВыполнитьОбработку_РегистрРасчета()	
	
	Если ВходящиеДанные.НаборЗаписей.Количество() = 0 Тогда
		Возврат Неопределено
	КонецЕсли;
	
	ТипОбъекта = СтрРазделить(ВходящиеДанные.Тип, ".")[1];
	
	НаборЗаписей = РегистрыРасчета[ТипОбъекта].СоздатьНаборЗаписей();
	
	Для Каждого ЭлементОтбора Из ВходящиеДанные.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			ЗаполнитьСсылки(ЭлементОтбора);		
			НаборЗаписей.Отбор[ЭлементОтбора.Имя].Установить(ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Строка Из ВходящиеДанные.НаборЗаписей Цикл		
		ЗаполнитьСсылки(Строка);
		Запись = НаборЗаписей.Добавить();
		ЗаполнитьЗначенияСвойств(Запись, Строка);		
	КонецЦикла;
	
	НаборЗаписей.ОбменДанными.Загрузка = Истина;
	НаборЗаписей.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);	
	НаборЗаписей.Записать();
	
	//Если ТипОбъекта = "ШтрихкодыНоменклатуры" Тогда
	//	ВыполнитьОбработку_ШтрихкодыНоменклатуры(НаборЗаписей);	
	//КонецЕсли;	
КонецФункции

Функция ПолучитьСсылкуНаСправочник()		
	
	СсылкаНаОбъект = Неопределено;
	Если НЕ ВыполнитьАлгоритмПоиска(ТипОбъекта, ВходящиеДанные, СсылкаНаОбъект) Тогда
		Если ЗначениеЗаполнено(ВходящиеДанные.ИмяПредопределенныхДанных) Тогда
			Попытка
				СсылкаНаОбъект = Справочники[ТипОбъекта][ВходящиеДанные.ИмяПредопределенныхДанных]
			Исключение
			КонецПопытки;
		Иначе
			ИД = Новый УникальныйИдентификатор(ВходящиеДанные.Ссылка);		
			СсылкаНаОбъект = Справочники[ТипОбъекта].ПолучитьСсылку(ИД);
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
		ОбъектНайден = Истина;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьСсылкуНаПланВидовХарактеристик(Данные)		
	
	Если ЗначениеЗаполнено(Данные.ИмяПредопределенныхДанных) Тогда
		Попытка
			Ссылка = ПланыВидовХарактеристик[ТипОбъекта][Данные.ИмяПредопределенныхДанных]
		Исключение
		КонецПопытки;
	Иначе
		ИД = Новый УникальныйИдентификатор(Данные.Ссылка);	
		Ссылка = ПланыВидовХарактеристик[ТипОбъекта].ПолучитьСсылку(ИД);
	КонецЕсли;	
	
	Возврат Ссылка;
	
КонецФункции

Функция ПолучитьСсылкуНаПланВидовРасчета(Данные)		
	
	Если ЗначениеЗаполнено(Данные.ИмяПредопределенныхДанных) Тогда
		Попытка
			Ссылка = ПланыВидовРасчета[ТипОбъекта][Данные.ИмяПредопределенныхДанных]
		Исключение
		КонецПопытки;
	Иначе
		ИД = Новый УникальныйИдентификатор(Данные.Ссылка);		
		Ссылка = ПланыВидовРасчета[ТипОбъекта].ПолучитьСсылку(ИД);
	КонецЕсли;	
	
	Возврат Ссылка;
	
КонецФункции

Функция ПолучитьСсылку_НаСправочникПоИдентификатору(Данные)
	ИД = Новый УникальныйИдентификатор(Данные.Ссылка);
	
	Возврат Справочники[ТипОбъекта].ПолучитьСсылку(ИД);
КонецФункции

Функция ПолучитьСсылку_НаДокументПоИдентификатору(Данные)
	ИД = Новый УникальныйИдентификатор(Данные.Ссылка);
		
	Ссылка = Документы[ТипОбъекта].ПолучитьСсылку(ИД);
	
	Если НЕ ЗначениеЗаполнено(Ссылка.ВерсияДанных) Тогда // объект точно ранее не записывался
		Возврат Ссылка;
	Иначе
		Возврат Ссылка;// todo или исключение, т.к. ссылка на существующий объект
	КонецЕсли;
КонецФункции

Функция ИсключаяСвойстваСправочник(Тип)
	// todo кеширование типов надо
	Мета = Метаданные.Справочники.Найти(Тип);
	ИсключаяСвойства = Новый Массив;
	
	Если Мета.Владельцы.Количество() = 0 и ВходящиеДанные.Свойство("Владелец") Тогда
		ИсключаяСвойства.Добавить("Владелец");
	КонецЕсли;
	
	Если НЕ Мета.Иерархический и ВходящиеДанные.Свойство("Родитель") Тогда
		ИсключаяСвойства.Добавить("Родитель");
	КонецЕсли;
	
	Возврат СтрСоединить(ИсключаяСвойства, ",");
КонецФункции

Функция ИсключаяСвойстваПланВидовХарактеристик(Тип)
	// todo кеширование типов надо
	Мета = Метаданные.ПланыВидовХарактеристик.Найти(Тип);
	ИсключаяСвойства = Новый Массив;
	
	Если НЕ Мета.Иерархический и ВходящиеДанные.Свойство("Родитель") Тогда
		ИсключаяСвойства.Добавить("Родитель");
	КонецЕсли;
	
	Возврат СтрСоединить(ИсключаяСвойства, ",");
КонецФункции

Функция ИсключаяСвойстваПланВидовРасчета(Тип)
	// todo кеширование типов надо
	Мета = Метаданные.ПланыВидовРасчета.Найти(Тип);
	ИсключаяСвойства = Новый Массив;
	
	Если НЕ Мета.Иерархический и ВходящиеДанные.Свойство("Родитель") Тогда
		ИсключаяСвойства.Добавить("Родитель");
	КонецЕсли;
	
	Возврат СтрСоединить(ИсключаяСвойства, ",");
КонецФункции

Функция ЗаписатьДокумент(обС)
	обС.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);
	
	Попытка
		обС.ОбменДанными.Загрузка = Истина;
		обС.Записать();
	Исключение				
		ВызватьИсключение ОписаниеОшибки();
	КонецПопытки;
			
	//Проводить = ВходящиеДанные.Проведен ИЛИ обС.Проведен;
	//
	//Ошибки = Новый Массив;
	//
	//Если Проводить Тогда
	//	РежимЗаписи = РежимЗаписиДокумента.Проведение;
	//ИначеЕсли Не обС.Ссылка.Пустая() И обС.Ссылка.Проведен Тогда
	//	РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения;
	//Иначе
	//	РежимЗаписи = РежимЗаписиДокумента.Запись;
	//КонецЕсли;	
	//	
	//Попытка
	//	обС.Записать(РежимЗаписи);
	//Исключение
	//	Ошибки.Добавить(ОписаниеОшибки());
	//	Попытка				
	//		обС.ОбменДанными.Загрузка = Истина;
	//		обС.Записать(РежимЗаписиДокумента.Запись);
	//	Исключение				
	//		Ошибки.Добавить(ОписаниеОшибки());
	//	КонецПопытки;			
	//КонецПопытки;

	//Если Ошибки.Количество() Тогда
	//	ВызватьИсключение СтрСоединить(Ошибки, Символы.ПС);
	//КонецЕсли;
КонецФункции

Функция ЗаписатьСправочник(обС)
	обС.ДополнительныеСвойства.Вставить("леОбменДанными", Истина);
	Попытка
		обС.ОбменДанными.Загрузка = Истина;
		обС.Записать();
	Исключение				
		ВызватьИсключение ОписаниеОшибки();
	КонецПопытки;	
КонецФункции

#КонецОбласти

#Область ПравилаКонвертацииСлужебные

Функция ВыполнитьАлгоритм(ГруппаАлгоритмов, Объект1с, Отказ)
	
	ФункцияПравил = Неопределено;
	Если НЕ ПравилаКонвертации = Неопределено Тогда
		Обработчики = Неопределено;
		ПравилаКонвертации.Манифест.Свойство(ТипОбъекта, Обработчики);
		Если Не Обработчики = Неопределено Тогда
			Обработчики.Свойство(ГруппаАлгоритмов, ФункцияПравил);
		КонецЕсли;
	КонецЕсли;
	
	Если Не ФункцияПравил = Неопределено Тогда
		ТекстВызоваФункции = СтрШаблон("ПравилаКонвертации.%1(Объект1с, ВходящиеДанные, Отказ)", ФункцияПравил);
		Выполнить(ТекстВызоваФункции);
	КонецЕсли;
	
КонецФункции

Функция ВыполнитьАлгоритмПоиска(ТипОбъектаПоиска, ДанныеДляПоиска, Значение)
	
	ФункцияПравил = Неопределено;
	Если НЕ ПравилаКонвертации = Неопределено Тогда
		Обработчики = Неопределено;
		ПравилаКонвертации.Манифест.Свойство(ТипОбъектаПоиска, Обработчики);
		Если Не Обработчики = Неопределено Тогда
			Обработчики.Свойство("НайтиСсылку", ФункцияПравил);
			
			Если НЕ ФункцияПравил = Неопределено Тогда
				ТекстВызоваФункции = СтрШаблон("Значение = ПравилаКонвертации.%1(ТипОбъектаПоиска, ДанныеДляПоиска, Отказ)", ФункцияПравил);
				Выполнить(ТекстВызоваФункции);
				Возврат Истина;
			КонецЕсли;			
		КонецЕсли;		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

Функция ЗаписатьJSON_Стандартная(Данные) Экспорт

	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.ПроверятьСтруктуру = Ложь;
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(,Символы.Таб,,ЭкранированиеСимволовJSON.СимволыВнеBMP,Истина,Истина,Истина,Истина,Истина);
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	
	//ЗаполнитьЗначенияСвойств(ЗаписьJSON.Параметры, ПараметрыЗаписиJSON());
	
	НастройкиСериализацииJSON = Новый НастройкиСериализацииJSON;
	НастройкиСериализацииJSON.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.ЛокальнаяДата;
	НастройкиСериализацииJSON.ФорматСериализацииДаты = ФорматДатыJSON.ISO;
	
	ЗаписатьJSON(ЗаписьJSON, Данные, НастройкиСериализацииJSON);
	
	ТекстСообщения = ЗаписьJSON.Закрыть();
	
	Возврат ТекстСообщения;
	
КонецФункции

Функция ПараметрыЗаписиJSON()
	
	ПараметрыЗаписиJSON = Новый Структура;
	
	ПараметрыЗаписиJSON = Новый Структура;
	ПараметрыЗаписиJSON.Вставить("ПереносСтрок", ПереносСтрокJSON.Авто);
	ПараметрыЗаписиJSON.Вставить("СимволыОтступа", " ");
	ПараметрыЗаписиJSON.Вставить("ИспользоватьДвойныеКавычки", Истина);
	ПараметрыЗаписиJSON.Вставить("ЭкранированиеСимволов", ЭкранированиеСимволовJSON.СимволыВнеASCII);
	ПараметрыЗаписиJSON.Вставить("ЭкранироватьУгловыеСкобки", Истина);
	ПараметрыЗаписиJSON.Вставить("ЭкранироватьРазделителиСтрок", Истина);
	ПараметрыЗаписиJSON.Вставить("ЭкранироватьАмперсанд", Истина);
	ПараметрыЗаписиJSON.Вставить("ЭкранироватьОдинарныеКавычки", Истина);
	ПараметрыЗаписиJSON.Вставить("ЭкранироватьСлеш", Истина);
	
	Возврат ПараметрыЗаписиJSON;
	
КонецФункции

#КонецОбласти

#Область Инициализация

ИнициализироватьОбработчикиТипов();
ИнициализироватьСтандартныеРеквизитыОбъектов();
ИнициализироватьПростыеТипыДанных();
Гнпп = 0;
МассивРезультат = Новый Массив;
СтекОбработанныхСсылок = Новый Соответствие;
СтекОбработанныхОбъектов = Новый Соответствие;
СтекУжеВыгружались = Новый Соответствие;
СтекЕщеНеВыгружались = Новый Соответствие;

мТипыДокументов = Документы.ТипВсеСсылки();
мТипыСправочников = Справочники.ТипВсеСсылки();
мТипыПеречислений = Перечисления.ТипВсеСсылки();

сОписаниеВыгружаемыхДанных = Новый Соответствие;

ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(,Символы.Таб,,ЭкранированиеСимволовJSON.СимволыВнеBMP,Истина,Истина,Истина,Истина,Истина);

НастройкиСериализацииJSON = Новый НастройкиСериализацииJSON;
НастройкиСериализацииJSON.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.ЛокальнаяДата;
НастройкиСериализацииJSON.ФорматСериализацииДаты = ФорматДатыJSON.ISO;

ОбъектНайден       = Ложь;
ПерезаписатьОбъект = Истина;
Отказ              = Ложь;

#КонецОбласти
