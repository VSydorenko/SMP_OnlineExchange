
#Область ОписаниеПеременных

// Переменные перенесены из модуля обработки "УниверсальныйОбменДаннымиXML".
// По мере реализации механизма лишние будут удаляться..

////////////////////////////////////////////////////////////////////////////////
// ИСПОЛЬЗУЕМЫЕ СОКРАЩЕНИЯ ИМЕН ПЕРЕМЕННЫХ (АБРЕВИАТУРЫ)

//  ПКО  - правило конвертации объектов.
//  ПКС  - правило конвертации свойств объектов.
//  ПКГС - правило конвертации группы свойств объектов.
//  ПКЗ  - правило конвертации значений объектов.
//  ПВД  - правило выгрузки данных.
//  ПОД  - правило очистки данных.

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПЕРЕМЕННЫЕ МОДУЛЯ ДЛЯ НАПИСАНИЯ АЛГОРИТМОВ (ОБЩИЕ ДЛЯ ВЫГРУЗКИ И ЗАГРУЗКИ)

Перем Конвертация  Экспорт;  // Структура свойств конвертации (Имя, Ид, обработчики событий обмена).

Перем Алгоритмы    Экспорт;  // Структура, содержащая используемые алгоритмы.
Перем Запросы      Экспорт;  // Структура, содержащая используемые запросы.
Перем ДопОбработки Экспорт;  // Структура, содержащая используемые внешние обработки. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)

Перем Правила      Экспорт;  // Структура, содержащая ссылки на ПКО.

Перем Менеджеры    Экспорт;  // Соответствие, содержащее поля Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД, ПКО.
Перем МенеджерыДляПлановОбмена Экспорт;
Перем ФайлОбмена Экспорт;            // Последовательно записываемый/читаемый файл обмена. (Здесь будет файл json прочитанный в соответствие)

Перем ПараметрыДопОбработок Экспорт;  // Структура, содержащая параметры, используемых внешних обработок. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)

Перем ПараметрыИнициализированы Экспорт;  // Если Истина, то необходимые параметры конвертации проинициализированы.

Перем мФайлПротоколаДанных Экспорт; // Файл для ведения протокола обмена данными. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)
Перем ФлагКомментироватьОбработкуОбъектов Экспорт; // (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)

Перем ВнешняяОбработкаОбработчиковСобытий Экспорт; // Объект "ВнешниеОбработкиМенеджер" для вызова экспортных процедур 
                                                   // обработчиков при отладке загрузки/выгрузки. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)

Перем ОбщиеПроцедурыФункции;  // Переменная хранит ссылку на данный экземпляр обработки - ЭтотОбъект.
                              // Необходима для вызова экспортных процедур из обработчиков событий.

Перем мМакетПараметровОбработчиков; // Табличный документ с параметрами обработчиков. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)
Перем мМакетОбщиеПроцедурыФункции;  // Текстовый документ с комментариями, глобальными переменными и обертками общих
                                    // процедур и функций. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)

Перем мРежимыОбработкиДанных; // Структура, содержащая режимы использования этой обработки.
Перем РежимОбработкиДанных;   // Содержит текущее значение режима обработки данных.

Перем мРежимыОтладкиАлгоритмов; // Структура, содержащая режимы отладки алгоритмов. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)
Перем АлгоритмыИнтегрированные; // Структура, содержащая алгоритмы с интегрированным кодом вложенных алгоритмов. (ПОКА ЧТО НЕ ИСПОЛЬЗУЕТСЯ)

Перем ИменаОбработчиков; // Структура, содержащая имена всех обработчиков правил обмена.

Перем РазделителиКонфигурации; // Массив: содержащий разделители конфигурации.

////////////////////////////////////////////////////////////////////////////////
// ФЛАГИ НАЛИЧИЯ ГЛОБАЛЬНЫХ ОБРАБОТЧИКОВ СОБЫТИЙ

Перем ЕстьГлобальныйОбработчикПередВыгрузкойОбъекта;
Перем ЕстьГлобальныйОбработчикПослеВыгрузкиОбъекта;

Перем ЕстьГлобальныйОбработчикПередКонвертациейОбъекта;

Перем ЕстьГлобальныйОбработчикПередЗагрузкойОбъекта;
Перем ЕстьГлобальныйОбработчикПослеЗагрузкиОбъекта;

Перем ВерсияПлатформыПриемника;
Перем ПлатформаПриемника;

////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ ОБРАБОТОК ОБМЕНА (ОБЩИЕ ДЛЯ ВЫГРУЗКИ И ЗАГРУЗКИ)

Перем одТипСтрока;                  // Тип("Строка")
Перем одТипБулево;                  // Тип("Булево")
Перем одТипЧисло;                   // Тип("Число")
Перем одТипДата;                    // Тип("Дата")
Перем одТипХранилищеЗначения;       // Тип("ХранилищеЗначения")
Перем одТипУникальныйИдентификатор; // Тип("УникальныйИдентификатор")
Перем одТипДвоичныеДанные;          // Тип("ДвоичныеДанные")
Перем одТипВидДвиженияНакопления;   // Тип("ВидДвиженияНакопления")
Перем одТипУдалениеОбъекта;         // Тип("УдалениеОбъекта")
Перем одТипВидСчета;			    // Тип("ВидСчета")
Перем одТипТип;			  		    // Тип("Тип")
Перем одТипСоответствие;		    // Тип("Соответствие").

//Перем одТипУзлаXML_КонецЭлемента  Экспорт; (НЕ ИСПОЛЬЗУЕТСЯ, УДАЛИТЬ)
//Перем одТипУзлаXML_НачалоЭлемента Экспорт; (НЕ ИСПОЛЬЗУЕТСЯ, УДАЛИТЬ)
//Перем одТипУзлаXML_Текст          Экспорт; (НЕ ИСПОЛЬЗУЕТСЯ, УДАЛИТЬ)

Перем ЗначениеПустаяДата Экспорт;

Перем одСообщения;             // Соответствие. Ключ - код ошибки,  Значение - описание ошибки.

//Перем мСписокМакетовПравилОбмена Экспорт; (НЕ ИСПОЛЬЗУЕТСЯ, УДАЛИТЬ)


////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ ОБРАБОТКИ ВЫГРУЗКИ
 
Перем мСчетчикВыгруженныхОбъектов Экспорт;   // Число - счетчик выгруженных объектов.
Перем мСчетчикНПП Экспорт;   // Число - счетчик НПП
Перем мТаблицаПравилКонвертацииСвойств;      // ТаблицаЗначений - шаблон для воссоздания структуры таблицы путем
                                             //                   копирования.
Перем мXMLПравила;                           // Xml-Строка, содержащая описание правил обмена.
Перем мСтрокаТиповДляПриемника;

////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ ОБРАБОТКИ ЗАГРУЗКИ
 
Перем мСчетчикЗагруженныхОбъектов Экспорт;// Число - счетчик загруженных объектов.

Перем мАтрибутыФайлаОбмена Экспорт;       // Структура. После открытия файла 
                                          // содержит атрибуты файла обмена 
                                          // согласно формату.

Перем ЗагруженныеОбъекты Экспорт;         // Соответствие. Ключ - НПП объекта в файле,
                                          // Значение - ссылка на загруженный объект.
Перем ЗагруженныеГлобальныеОбъекты Экспорт;
Перем ЧислоХранимыхЗагруженныхОбъектов Экспорт;  // Число хранимых загруженных объектов, 
                                          // после которого Соответствие ЗагруженныеОбъекты 
                                          // очищается.
Перем ЗапоминатьЗагруженныеОбъекты Экспорт;

Перем мСоответствиеДопПараметровПоиска;
Перем мСоответствиеПравилКонвертации; // Соответствие для определения правила конвертации объекта по типу этого объекта.

Перем мОбработкаДляЗагрузкиДанных Экспорт;

Перем мСоответствиеПустыхЗначенийТипов;
Перем мСоответствиеОписаниеТипов;

//Перем мБылиПрочитаныПравилаОбменаПриЗагрузке Экспорт; (НЕ ИСПОЛЬЗУЕТСЯ, УДАЛИТЬ)

Перем мСтекВызововВыгрузкиДанных;

Перем мСоответствиеТиповДанныхДляЗагрузки;

Перем мГлобальныйСтекНеЗаписанныхОбъектов;

Перем СобытияПослеЗагрузкиПараметров Экспорт;

Перем ТекущийУровеньВложенностиВыгрузитьПоПравилу;

// СМП
Перем мУчетнаяЗаписьОбмена Экспорт; // СправочникСсылка.СМП_УчетныеЗаписиОбменов - учетная запись обмена для которой выполняется конвертация.
Перем мСтрокаJSON Экспорт; // Строка - Строка в формате JSON для конвертации
Перем мТекущийобъектДляЧтения; // Соответствие - здесь запоминаем объект перед чтением из массива объектов.
Перем ОбрезатьСтрокиСправа; // Булево - был реквизитом обработки
Перем мОшибки Экспорт; // Массив для накопления текстов ошибок работы конвертации.
////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ ДЛЯ ХРАНЕНИЯ МОДУЛЕЙ СТАНДАРТНЫХ ПОДСИСТЕМ

Перем МодульДатыЗапретаИзменения;

#КонецОбласти

#Область ПрограммныйИнтерфейс

#Область ЭкпортируемыеПроцедурыИФункции

// Выполняет загрузку данных в соответствии с установленными режимами (правилами обмена).
//
// Параметры:
//  Нет.
//
Процедура ВыполнитьЗагрузку() Экспорт
	
	РаботаВозможна = ВыполнитьДействияПередЧтениемДанных(мСтрокаJSON);
	
	Если Не РаботаВозможна Тогда
		Возврат;
	КонецЕсли;
	
	// Возможно в будущем понадобится:
	//Если ИспользоватьТранзакции Тогда
	//	НачатьТранзакцию();
	//КонецЕсли;
	
	Попытка
		ПроизвестиЧтениеДанных();
		// Отложенная запись того, что не записали с самого начала.
		ПровестиЗаписьНеЗаписанныхОбъектов();
		//Если ИспользоватьТранзакции Тогда
		//	ЗафиксироватьТранзакцию();
		//КонецЕсли;
	Исключение
		//Если ИспользоватьТранзакции Тогда
		//	ОтменитьТранзакцию();
		//КонецЕсли;
	КонецПопытки;
	
	ВыполнитьДействияПослеЗавершенияЧтенияДанных();
	
КонецПроцедуры

// Перед началом чтения данных из файла выполняем инициализацию переменных,
// загрузку правил обмена,
// открываем транзакцию на запись данных в ИБ (в Будущем) ,
// выполняем необходимые обработчики событий.
//
// Параметры:
//  СтрокаДанных - Строка - строка в формате JSON, содержащая данные для загрузки.
//
//  Возвращаемое значение:
//     Булево - Истина - загрузка данных из файла возможна; Ложь - нет.
//
Функция ВыполнитьДействияПередЧтениемДанных(СтрокаДанных = "") Экспорт
	
	РежимОбработкиДанных = мРежимыОбработкиДанных.Загрузка;

	мСоответствиеДопПараметровПоиска       = Новый Соответствие;
	мСоответствиеПравилКонвертации         = Новый Соответствие;
	
	Правила.Очистить();
	
	ИнициализироватьКомментарииПриВыгрузкеИЗагрузкеДанных();
	
	ИнициализироватьВедениеПротоколаОбмена(); // Подключить в будущем
	
	ЗагрузкаВозможна = Истина;
	
	Если ПустаяСтрока(СтрокаДанных) Тогда
		
		ЗагрузкаВозможна = Ложь;
		
		//Если ПустаяСтрока(ИмяФайлаОбмена) Тогда
		//	ЗаписатьВПротоколВыполнения(15);
		//	ЗагрузкаВозможна = Ложь;
		//КонецЕсли;
	
	КонецЕсли;
	
	// Инициализируем внешнюю обработку с экспортными обработчиками.
	//ИнициализацияВнешнейОбработкиОбработчиковСобытий(ЗагрузкаВозможна, ЭтотОбъект); // Подключить в будущем
	
	Если Не ЗагрузкаВозможна Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтрокаСообщения = СтрШаблон(Нстр("ru = 'Начало загрузки: %1'"), ТекущаяДатаСеанса());
	Сообщить(СтрокаСообщения);
	ЗаписатьВПротоколВыполнения(СтрокаСообщения, , Ложь, , , Истина);
	
	//Если ФлагРежимОтладки Тогда // Подумать - возможно будем грузить каждый реквизит документа отдельно в  транзакции.
	//	ИспользоватьТранзакции = Ложь;
	//КонецЕсли;
	
	//Если КоличествоОбработанныхОбъектовДляОбновленияСтатуса = 0 Тогда
	//	
	//	КоличествоОбработанныхОбъектовДляОбновленияСтатуса = 100;
	//	
	//КонецЕсли;
	
	мСоответствиеТиповДанныхДляЗагрузки = Новый Соответствие;
	мГлобальныйСтекНеЗаписанныхОбъектов = Новый Соответствие;
	
	мСчетчикЗагруженныхОбъектов = 0;
	ФлагОшибки                  = Ложь;
	ЗагруженныеОбъекты          = Новый Соответствие; // экспортная переменная
	ЗагруженныеГлобальныеОбъекты = Новый Соответствие; // экспортная переменная

	ИнициализироватьМенеджерыИСообщения();
	
	Преобразовать_JSON_В_Соответствие(); // Читаем строку JSON в соответствие
	ЗагрузитьПравилаОбмена(); // Загрузка ПКО согласно учетной записи обмена данными
	
	//ОткрытьФайлЗагрузки(,СтрокаДанных); // В будущем убрать
	
	Если ФлагОшибки Тогда 
		ЗавершитьВедениеПротоколаОбмена();
		Возврат Ложь; 
	КонецЕсли;

	//// Определяем интерфейсы обработчиков.
	//Если ФлагРежимОтладкиОбработчиков Тогда
	//	
	//	ДополнитьПравилаИнтерфейсамиОбработчиков(Конвертация, ТаблицаПравилКонвертации, ТаблицаПравилВыгрузки, ТаблицаПравилОчистки);
	//	
	//КонецЕсли;
	
	// Обработчик ПередЗагрузкойДанных
	Отказ = Ложь;
	
	// Узнать, для чего это!:
	//Если БезопасныйРежим Тогда
	//	УстановитьБезопасныйРежим(Истина);
	//	Для Каждого ИмяРазделителя Из РазделителиКонфигурации Цикл
	//		УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
	//	КонецЦикла;
	//КонецЕсли;
	
	Если Не ПустаяСтрока(Конвертация.ПередЗагрузкойДанных) Тогда
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Конвертация, "ПередЗагрузкойДанных"));
			//	
			//Иначе
				
				Выполнить(Конвертация.ПередЗагрузкойДанных);
				
			//КонецЕсли;
			
		Исключение
			
			//ОписаниеОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			СтрокаСообщенияОбОшибке = ЗаписатьИнформациюОбОшибкеОбработчикиКонвертации(22, ОписаниеОшибки(), Нстр("ru = 'ПередЗагрузкойДанных (конвертация)'"));
			мОшибки.Добавить(СтрокаСообщенияОбОшибке);
			
			Отказ = Истина;
			
		КонецПопытки;
		
		Если Отказ Тогда // Отказ от загрузки данных
			ЗавершитьВедениеПротоколаОбмена();
			//ФайлОбмена.Закрыть();
			//ДеструкторВнешнейОбработкиОбработчиковСобытий();
			Возврат Ложь;
		КонецЕсли;
		
	КонецЕсли;

	//// Очистка информационной базы по правилам.
	//ОбработатьПравилаОчистки(ТаблицаПравилОчистки.Строки);
	
	Возврат Истина;
	
КонецФункции

// Выполняет последовательное чтение файла сообщения обмена и записывает данные в информационную базу.
//
// Параметры:
//  РезультирующаяСтрокаСИнформациейОбОшибке - Строка - результирующая строка с информацией об ошибке.
// 
Процедура ПроизвестиЧтениеДанных(РезультирующаяСтрокаСИнформациейОбОшибке = "") Экспорт
	
	Если БезопасныйРежим Тогда
		УстановитьБезопасныйРежим(Истина);
		Для Каждого ИмяРазделителя Из РазделителиКонфигурации Цикл
			УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		КонецЦикла;
	КонецЕсли;
	
	Попытка
		
		// SimplyUNF ++
		
		//ЗагрузитьЗначенияПараметровОбменаДанными(); // На будущее
		Отказ = Ложь;
		ПричинаОтказа = "";
		
		ТекстАлгоритма = "";
		Конвертация.Свойство("ПослеЗагрузкиПараметров", ТекстАлгоритма);
		
		Если Не ПустаяСтрока(ТекстАлгоритма) Тогда
			
			Попытка
				
				//Если ФлагРежимОтладкиОбработчиков Тогда
				//	
				//	ВызватьИсключение НСтр("ru = 'Отладка обработчика ""После загрузки параметров"" не поддерживается.'");
				//	
				//Иначе
					
					Выполнить(ТекстАлгоритма);
					
				//КонецЕсли;
				
				Если Отказ = Истина Тогда
					
					Если Не ПустаяСтрока(ПричинаОтказа) Тогда
						СтрокаИсключения = СтрШаблон(НСтр("ru = 'Загрузка данных отменена по причине: %1'"), ПричинаОтказа);
						ВызватьИсключение СтрокаИсключения;
					Иначе
						ВызватьИсключение НСтр("ru = 'Загрузка данных отменена'");
					КонецЕсли;
				КонецЕсли;
			Исключение
				
				//ОписаниеОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ЗП = ПолучитьСтруктуруЗаписиПротокола(75, ОписаниеОшибки());
				ЗП.Обработчик = "ПослеЗагрузкиПараметров";
				СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(75, ЗП, Истина);
				мОшибки.Добавить(СтрокаСообщенияОбОшибке);
				
				Если Не ФлагРежимОтладки Тогда
					ВызватьИсключение СтрокаСообщенияОбОшибке;
				КонецЕсли;
			КонецПопытки;
		КонецЕсли;
		
		ЗагрузитьИнформациюОТипахДанных(); // Заполнить по данным из таблицы ПКО и ПКС
		
		МассивОбъектов = ФайлОбмена.Получить("Объекты");
		
		Для Каждого ДанныеОбъекта Из МассивОбъектов Цикл
			
			мТекущийобъектДляЧтения = ДанныеОбъекта;
			ПоследнийОбъектЗагрузки = ПрочитатьОбъект(ДанныеОбъекта);
			ОбработатьОкончаниеЧтенияНовогоЭлемента(ПоследнийОбъектЗагрузки);
			
		КонецЦикла;
		
		// SimplyUNF --
		
	Исключение
		
		//ОписаниеОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
		СтрокаОшибки = СтрШаблон("Ошибка при загрузке данных: %1", ОписаниеОшибки());
		РезультирующаяСтрокаСИнформациейОбОшибке = ЗаписатьВПротоколВыполнения(СтрокаОшибки, Неопределено, Истина, , , Истина);
		мОшибки.Добавить(РезультирующаяСтрокаСИнформациейОбОшибке);
		ЗавершитьВедениеПротоколаОбмена();
		
		Возврат;
		
	КонецПопытки;
	
КонецПроцедуры

// Выполняет конвертацию строки в формате JSON в соответствие.
//
// Параметры:
//  Нет.
//
Процедура Преобразовать_JSON_В_Соответствие() Экспорт
	
	Чтение = Новый ЧтениеJSON;
	Чтение.УстановитьСтроку(мСтрокаJSON);
	
	Попытка
		ФайлОбмена = ПрочитатьJSON(Чтение, Истина);
		Чтение.Закрыть();
	Исключение
		
		ФайлОбмена = Неопределено;
		ФлагОшибки = Истина;
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры //Преобразовать_JSON_В_Соответствие

// Осуществляет загрузку правил обмена в соответствии с форматом.
//
// Параметры:
//  Нет.
// 
Процедура ЗагрузитьПравилаОбмена() Экспорт 
	
	ИнициализироватьМенеджерыИСообщения();
	
	//ЕстьГлобальныйОбработчикПередВыгрузкойОбъекта    = Ложь;
	//ЕстьГлобальныйОбработчикПослеВыгрузкиОбъекта     = Ложь;
	
	ЕстьГлобальныйОбработчикПередКонвертациейОбъекта = Ложь;

	ЕстьГлобальныйОбработчикПередЗагрузкойОбъекта    = Ложь;
	ЕстьГлобальныйОбработчикПослеЗагрузкиОбъекта     = Ложь;
	
	СоздатьСтруктуруКонвертации();
	
	мТаблицаПравилКонвертацииСвойств = Новый ТаблицаЗначений;
	ИнициализацияТаблицыПравилКонвертацииСвойств(мТаблицаПравилКонвертацииСвойств);
	ДополнитьСлужебныеТаблицыКолонками();
	
	// СМП ++
	// Дозаполнение конвертации:
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	СМП_УчетныеЗаписиОбменов.Код КАК Код,
	|	СМП_УчетныеЗаписиОбменов.Наименование КАК Наименование,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПередЗагрузкойДанных КАК АлгоритмПередЗагрузкойДанных,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПередЗагрузкойОбъекта КАК АлгоритмПередЗагрузкойОбъекта,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПередКонвертациейОбъекта КАК АлгоритмПередКонвертациейОбъекта,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПередПолучениемИзмененныхОбъектов КАК АлгоритмПередПолучениемИзмененныхОбъектов,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПослеЗагрузкиДанных КАК АлгоритмПослеЗагрузкиДанных,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПослеЗагрузкиОбъекта КАК АлгоритмПослеЗагрузкиОбъекта,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПослеЗагрузкиПараметров КАК АлгоритмПослеЗагрузкиПараметров,
	|	СМП_УчетныеЗаписиОбменов.АлгоритмПриПолученииИнформацииОбУдалении КАК АлгоритмПриПолученииИнформацииОбУдалении,
	|	СМП_УчетныеЗаписиОбменов.ДатаНачалаВыгрузкиДокументов КАК ДатаНачалаВыгрузкиДокументов,
	|	СМП_УчетныеЗаписиОбменов.ИмяПользователя КАК ИмяПользователя,
	|	СМП_УчетныеЗаписиОбменов.Источник КАК Источник,
	|	СМП_УчетныеЗаписиОбменов.КомИмяИнформационнойБазыНаСервере1СПредприятия КАК КомИмяИнформационнойБазыНаСервере1СПредприятия,
	|	СМП_УчетныеЗаписиОбменов.КомИмяСервера1СПредприятия КАК КомИмяСервера1СПредприятия,
	|	СМП_УчетныеЗаписиОбменов.Комментарий КАК Комментарий,
	|	СМП_УчетныеЗаписиОбменов.НастройкаОбмена КАК НастройкаОбмена,
	|	СМП_УчетныеЗаписиОбменов.Описание КАК Описание,
	|	СМП_УчетныеЗаписиОбменов.ПарольПользователя КАК ПарольПользователя,
	|	СМП_УчетныеЗаписиОбменов.РежимОтладки КАК РежимОтладки,
	|	СМП_УчетныеЗаписиОбменов.СпособПодключения КАК СпособПодключения,
	|	СМП_УчетныеЗаписиОбменов.УдалятьСопоставленныеОбъектыВПриемникеПриИхУдаленииВИсточнике КАК УдалятьСопоставленныеОбъектыВПриемникеПриИхУдаленииВИсточнике,
	|	СМП_УчетныеЗаписиОбменов.ФайлКаталогОбмена КАК ФайлКаталогОбмена,
	|	СМП_УчетныеЗаписиОбменов.ХттпСервисАдресПодключения КАК ХттпСервисАдресПодключения,
	|	СМП_УчетныеЗаписиОбменов.ИдентификаторОбмена КАК ИдентификаторОбмена
	|ИЗ
	|	Справочник.СМП_УчетныеЗаписиОбменов КАК СМП_УчетныеЗаписиОбменов
	|ГДЕ
	|	СМП_УчетныеЗаписиОбменов.Ссылка = &УчетнаяЗаписьОбмена";
	Запрос.УстановитьПараметр("УчетнаяЗаписьОбмена", мУчетнаяЗаписьОбмена);
	ЗапросВыборка = Запрос.Выполнить().Выбрать();
	ЗапросВыборка.Следующий();
	
	Конвертация.Вставить("ВерсияФормата", "");
	Конвертация.Вставить("Ид", ЗапросВыборка.Код);
	Конвертация.Вставить("Наименование", ЗапросВыборка.Наименование);
	Конвертация.Вставить("ДатаВремяСоздания", Дата("00010101"));
	Конвертация.Вставить("Источник", ЗапросВыборка.Источник); // СправочникСсылка.Конфигурации - ссылка на конфигурацию-источник
	Конвертация.Вставить("Приемник", Метаданные.Имя);
	Конвертация.Вставить("УдалятьСопоставленныеОбъектыВПриемникеПриИхУдаленииВИсточнике", ЗапросВыборка.УдалятьСопоставленныеОбъектыВПриемникеПриИхУдаленииВИсточнике);
	
	// События конвертации
	Конвертация.Вставить("ПередВыгрузкойДанных", "");
	Конвертация.Вставить("ПослеВыгрузкиДанных", "");
	Конвертация.Вставить("ПередВыгрузкойОбъекта", "");
	Конвертация.Вставить("ПослеВыгрузкиОбъекта", "");
	
	Конвертация.Вставить("ПередЗагрузкойОбъекта", ЗапросВыборка.АлгоритмПередЗагрузкойОбъекта);
	ЕстьГлобальныйОбработчикПередЗагрузкойОбъекта = Не ПустаяСтрока(Конвертация.ПередЗагрузкойОбъекта);
	
	Конвертация.Вставить("ПослеЗагрузкиОбъекта", ЗапросВыборка.АлгоритмПослеЗагрузкиОбъекта);
	ЕстьГлобальныйОбработчикПослеЗагрузкиОбъекта = Не ПустаяСтрока(Конвертация.ПослеЗагрузкиОбъекта);
	
	Конвертация.Вставить("ПередКонвертациейОбъекта", ЗапросВыборка.АлгоритмПередКонвертациейОбъекта);
	ЕстьГлобальныйОбработчикПередКонвертациейОбъекта = Не ПустаяСтрока(Конвертация.ПередКонвертациейОбъекта);
	
	Конвертация.Вставить("ПередЗагрузкойДанных", ЗапросВыборка.АлгоритмПередЗагрузкойДанных);
	Конвертация.Вставить("ПослеЗагрузкиДанных", ЗапросВыборка.АлгоритмПослеЗагрузкиДанных);
	Конвертация.Вставить("ПослеЗагрузкиПараметров", ЗапросВыборка.АлгоритмПослеЗагрузкиПараметров);
	Конвертация.Вставить("ПередОтправкойИнформацииОбУдалении", "");
	Конвертация.Вставить("ПередПолучениемИзмененныхОбъектов", ЗапросВыборка.АлгоритмПередПолучениемИзмененныхОбъектов);
	Конвертация.Вставить("ПриПолученииИнформацииОбУдалении", ЗапросВыборка.АлгоритмПриПолученииИнформацииОбУдалении);
	Конвертация.Вставить("ПослеПолученияИнформацииОбУзлахОбмена", "");
	
	//ЗагрузитьПараметры() // Здесь будут загружаться дополнительные параметры из файла обмена, дописать
	ЗагрузитьПравилаКонвертации();
	//ЗагрузитьПравилаОчистки(ПравилаОбмена, ЗаписьXML) // Дописать в будущем, если это нужно
	ЗагрузитьАлгоритмы();
	//ЗагрузитьЗапросы(); // Дописать в будущем
	//ЗагрузитьОбработки(); // Дописать в будущем
	// СМП --
	
	// Дополнительно нужна информация по типам данных приемника для быстрой загрузки данных.
	//СтруктураДанных = Новый Соответствие();
	//ЗаполнитьИнформациюПоТипамДанныхПриемника(СтруктураДанных, ТаблицаПравилКонвертации);
	
	//мСтрокаТиповДляПриемника = СоздатьСтрокуСТипамиДляПриемника(СтруктураДанных); // А нужно ли...
	мСтрокаТиповДляПриемника = "";
	
КонецПроцедуры

Процедура ЗаполнитьИнформациюПоТипамДанныхПриемника(СтруктураДанных, Правила)
	
	Для Каждого Строка Из Правила Цикл
		
		Если ПустаяСтрока(Строка.Приемник) Тогда
			Продолжить;
		КонецЕсли;
		
		сДанныеМенеджера = Менеджеры.Получить(Тип(Строка.Приемник));
		обМетаданныеПриемник = сДанныеМенеджера.ОбъектМД;
		
		ДанныеСтруктуры = СтруктураДанных[Строка.Приемник];
		Если ДанныеСтруктуры = Неопределено Тогда
			
			ДанныеСтруктуры = Новый Соответствие();
			СтруктураДанных[Строка.Приемник] = ДанныеСтруктуры;
			
		КонецЕсли;
		
		// Обходим поля поиска и ПКС и запоминаем типы данных.
		ЗаполнитьСвойстваДляПоиска(ДанныеСтруктуры, Строка.СвойстваПоиска, обМетаданныеПриемник);
				
		// Свойства
		ЗаполнитьСвойстваДляПоиска(ДанныеСтруктуры, Строка.Свойства, обМетаданныеПриемник);
		
	КонецЦикла;
	
	УдалитьЛишниеЭлементыИзСоответствия(СтруктураДанных);	
	
КонецПроцедуры

Процедура ЗаполнитьСвойстваДляПоиска(СтруктураДанных, ПКС, обМетаданныеПриемник)
	
	Для Каждого СтрокаПолей Из ПКС Цикл
		
		Если СтрокаПолей.ЭтоГруппа Тогда
						
			Если СтрокаПолей.ВидПриемника = "ТабличнаяЧасть" 
				ИЛИ СтрНайти(СтрокаПолей.ВидПриемника, "НаборДвижений") > 0 Тогда
				
				мдТабличныеЧасти = обМетаданныеПриемник.ТабличныеЧасти;
				мдТЧ = мдТабличныеЧасти[СтрокаПолей.Приемник];
				
				ИмяСтруктурыПриемника = СтрокаПолей.Приемник + ?(СтрокаПолей.ВидПриемника = "ТабличнаяЧасть", "ТабличнаяЧасть", "НаборЗаписей");
				
				ВнутренняяСтруктура = СтруктураДанных[ИмяСтруктурыПриемника];
				
				Если ВнутренняяСтруктура = Неопределено Тогда
					ВнутренняяСтруктура = Новый Соответствие();
				КонецЕсли;
				
				СтруктураДанных[ИмяСтруктурыПриемника] = ВнутренняяСтруктура;
				
			Иначе
				
				ВнутренняяСтруктура = СтруктураДанных;	
				
			КонецЕсли;
			
			ЗаполнитьСвойстваДляПоиска(ВнутренняяСтруктура, СтрокаПолей.ПравилаГруппы, мдТЧ);
									
		Иначе
			
			ИмяРеквизита = СтрокаПолей.Приемник;
			
			Если ИмяРеквизита = "{УникальныйИдентификатор}" Тогда
				Продолжить;
			КонецЕсли;
			
			мдСтандартные = обМетаданныеПриемник.СтандартныеРеквизиты;
			мдРеквизиты = обМетаданныеПриемник.Реквизиты;
			мдРеквизит = Неопределено;
			отРеквизит = Неопределено;
			
			Попытка
				
				мдРеквизит = мдСтандартные[ИмяРеквизита];
				отРеквизит = мдРеквизит.Тип;
				СтруктураДанных[СтрокаПолей.Приемник] = отРеквизит;
				Продолжить;
				
			Исключение
			    //ОписаниеОшибки()
			КонецПопытки;
			
			Попытка
				
				мдРеквизит = мдРеквизиты[ИмяРеквизита];
				отРеквизит = мдРеквизит.Тип;
				СтруктураДанных[СтрокаПолей.Приемник] = отРеквизит;
				Продолжить;
				
			Исключение
			    //ОписаниеОшибки()
			КонецПопытки;
			
			//Если ПустаяСтрока(СтрокаПолей.ТипПриемника)	Тогда
			//	
			//	Продолжить;
			//	
			//КонецЕсли;
			//
			//СтруктураДанных[СтрокаПолей.Приемник] = СтрокаПолей.ТипПриемника;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьЛишниеЭлементыИзСоответствия(СтруктураДанных)
	
	Для Каждого Элемент Из СтруктураДанных Цикл
		
		Если ТипЗнч(Элемент.Значение) = одТипСоответствие Тогда
			
			УдалитьЛишниеЭлементыИзСоответствия(Элемент.Значение);
			
			Если Элемент.Значение.Количество() = 0 Тогда
				СтруктураДанных.Удалить(Элемент.Ключ);
			КонецЕсли;
			
		КонецЕсли;		
		
	КонецЦикла;		
	
КонецПроцедуры

Функция СоздатьСтрокуСТипамиДляПриемника(СтруктураДанных) // Возможно убрать в будущем
	
	//ЗаписьXML = Новый ЗаписьXML;
	//ЗаписьXML.УстановитьСтроку();
	//ЗаписьXML.ЗаписатьНачалоЭлемента("ИнформацияОТипахДанных");	
	//
	//Для Каждого Строка Из СтруктураДанных Цикл
	//	
	//	ЗаписьXML.ЗаписатьНачалоЭлемента("ТипДанных");
	//	УстановитьАтрибут(ЗаписьXML, "Имя", Строка.Ключ);
	//	
	//	Для Каждого СтрокаПодчинения Из Строка.Значение Цикл
	//		
	//		СоздатьСтрокуСТипамиСвойств(ЗаписьXML, СтрокаПодчинения);	
	//		
	//	КонецЦикла;
	//	
	//	ЗаписьXML.ЗаписатьКонецЭлемента();
	//	
	//КонецЦикла;	
	//
	//ЗаписьXML.ЗаписатьКонецЭлемента();
	//
	//СтрокаРезультата = ЗаписьXML.Закрыть();
	//Возврат СтрокаРезультата;
	
КонецФункции

// Разобраться - возможно и не нужна. Или переписать.
Процедура ЗагрузитьИнформациюОТипахДанных()
	
	Для Каждого СтрПКО Из ТаблицаПравилКонвертации Цикл
		
		Если СтрНачинаетсяС(СтрПКО.Приемник, "ПеречислениеСсылка") Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТипа = СтрПКО.Приемник;
		ТипПриемника = Тип(ИмяТипа);
		
		сДанныеМенеджера = Менеджеры.Получить(ТипПриемника);
		обМетаданныеПриемник = сДанныеМенеджера.объектМД;
		МассивКоллекцийМД = Новый Массив;
		МассивКоллекцийМД.Добавить("СтандартныеРеквизиты");
		МассивКоллекцийМД.Добавить("Реквизиты");
		Если СтрНачинаетсяС(ИмяТипа, "Регистр") Тогда
			МассивКоллекцийМД.Добавить("Измерения");
			МассивКоллекцийМД.Добавить("Ресурсы");
		КонецЕсли;
		
		СоответствиеТипа = Новый Соответствие;
		ЗагрузитьСоответствиеТиповДляОдногоТипа(СтрПКО.Свойства, СоответствиеТипа, обМетаданныеПриемник, МассивКоллекцийМД);
		ЗагрузитьСоответствиеТиповДляОдногоТипа(СтрПКО.СвойстваПоиска, СоответствиеТипа, обМетаданныеПриемник, МассивКоллекцийМД);
		мСоответствиеТиповДанныхДляЗагрузки.Вставить(ТипПриемника, СоответствиеТипа);
		
	КонецЦикла;
	
	//Пока ФайлОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ФайлОбмена.ЛокальноеИмя;
	//	
	//	Если ИмяУзла = "ТипДанных" Тогда
	//		
	//		ИмяТипа = одАтрибут(ФайлОбмена, одТипСтрока, "Имя");
	//		
	//		СоответствиеТипа = Новый Соответствие;
	//		мСоответствиеТиповДанныхДляЗагрузки.Вставить(Тип(ИмяТипа), СоответствиеТипа);

	//		ЗагрузитьСоответствиеТиповДляОдногоТипа(ФайлОбмена, СоответствиеТипа);	
	//		
	//	ИначеЕсли (ИмяУзла = "ИнформацияОТипахДанных") И (ФайлОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//		Прервать;
	//		
	//	КонецЕсли;
	//	
	//КонецЦикла;	
	
КонецПроцедуры

// Разобраться - возможно и не нужна. Или переписать.
Процедура ЗагрузитьСоответствиеТиповДляОдногоТипа(ТаблицаПКС, СоответствиеТипа, обМетаданныеПриемник, МассивКоллекцийМД)
	
	Для Каждого СтрокаПКС Из ТаблицаПКС Цикл
		
		Если СтрокаПКС.Имя = "{УникальныйИдентификатор}" Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаПКС.ЭтоГруппа Тогда 
			
			мдТабличнаяЧасть = обМетаданныеПриемник.ТабличныеЧасти[СтрокаПКС.Приемник];
			
			ПравилаТЧ = СтрокаПКС.ПравилаГруппы;
			СоответствиеТиповТЧ = Новый Соответствие;
			Для Каждого стрПравилоТЧ Из ПравилаТЧ Цикл
				
				//Если НЕ ПустаяСтрока(стрПравилоТЧ.ТипПриемника) Тогда
				//	ТипСтрокой = Тип(стрПравилоТЧ.ТипПриемника);
				//ИначеЕсли ЗначениеЗаполнено(стрПравилоТЧ.ПравилоКонвертации) Тогда
				//	ТипСтрокой = Тип(стрПравилоТЧ.ПравилоКонвертации.ТипПриемника);
				//Иначе
				//	ТипСтрокой = Тип("Строка");
				//КонецЕсли;
				
				//СоответствиеТиповТЧ.Вставить(стрПравилоТЧ.Приемник, ТипСтрокой);
				
				ИмяРеквизитаТЧ = стрПравилоТЧ.Приемник;
				ОписаниеТиповРеквизита = ОписаниеТиповРеквизитаПриемника(мдТабличнаяЧасть, МассивКоллекцийМД, ИмяРеквизитаТЧ);
				СоответствиеТиповТЧ.Вставить(стрПравилоТЧ.Приемник, ОписаниеТиповРеквизита);
				
			КонецЦикла;
			
			СоответствиеТипа.Вставить(СтрокаПКС.Приемник + СтрокаПКС.ВидПриемника, СоответствиеТиповТЧ);
			
		Иначе
			
			ИмяРеквизита = СтрокаПКС.Приемник;
			ОписаниеТиповРеквизита = ОписаниеТиповРеквизитаПриемника(обМетаданныеПриемник, МассивКоллекцийМД, ИмяРеквизита);
			
			Если ОписаниеТиповРеквизита = Неопределено Тогда
				Продолжить;
			Иначе
				
				СоответствиеТипа.Вставить(ИмяРеквизита, ОписаниеТиповРеквизита);
				
			КонецЕсли;
			
			//Если НЕ ПустаяСтрока(СтрокаПКС.ТипПриемника) Тогда
			//	ТипСтрокой = СтрокаПКС.ТипПриемника;
			//	СоответствиеТипа.Вставить(ИмяРеквизита, Тип(ТипСтрокой));
			//ИначеЕсли ЗначениеЗаполнено(СтрокаПКС.ПравилоКонвертации) Тогда
			//	ТипСтрокой = СтрокаПКС.ПравилоКонвертации.ТипПриемника;
			//	СоответствиеТипа.Вставить(ИмяРеквизита, Тип(ТипСтрокой));
			//КонецЕсли;
			
			//СоответствиеТипа.Вставить(ИмяРеквизита, Тип(ТипСтрокой));
			
		КонецЕсли;
	КонецЦикла;
	
	//Пока ПравилаОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ПравилаОбмена.ЛокальноеИмя;
	//	
	//	Если (ПравилаОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//	    Прервать;
	//		
	//	КонецЕсли;
	//	
	//	// прочитали начало элемента
	//	ПравилаОбмена.Прочитать();
	//	
	//	Если ПравилаОбмена.ТипУзла = одТипУзлаXML_НачалоЭлемента Тогда
	//		
	//		// это новый элемент
	//		НовоеСоответствие = Новый Соответствие;
	//		СоответствиеТипа.Вставить(ИмяУзла, НовоеСоответствие);
	//		
	//		ЗагрузитьОдинТипДанных(ПравилаОбмена, НовоеСоответствие, ПравилаОбмена.ЛокальноеИмя);			
	//		
	//	Иначе
	//		СоответствиеТипа.Вставить(ИмяУзла, Тип(ПравилаОбмена.Значение));
	//		ПравилаОбмена.Прочитать();
	//	КонецЕсли;	
	//	
	//КонецЦикла;	
	
КонецПроцедуры

// .
//
// Параметры:
//   <Параметр1> - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//   <Параметр2> - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид> - <описание возвращаемого значения>
//
Функция ОписаниеТиповРеквизитаПриемника(обМетаданныеПриемник, МассивКоллекцийМД, ИмяРеквизита) 
	
	мдРеквизит = Неопределено;
	отРеквизит = Неопределено;
	
	Для Каждого ИмяКоллекции Из МассивКоллекцийМД Цикл
		
		мдКоллекция = обМетаданныеПриемник[ИмяКоллекции];
		
		Попытка
			
			мдРеквизит = мдКоллекция[ИмяРеквизита];
			отРеквизит = мдРеквизит.Тип;
			Прервать;
			
		Исключение
			Продолжить;
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат отРеквизит;
	
КонецФункции // ОписаниеТиповРеквизитаПриемника


// Разобраться - возможно и не нужна. Или переписать.
Процедура ЗагрузитьОдинТипДанных(ПравилаОбмена, СоответствиеТипа, ИмяЛокальногоЭлемента)
	
	//ИмяУзла = ИмяЛокальногоЭлемента;
	//
	//ПравилаОбмена.Прочитать();
	//
	//Если (ПравилаОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//	
	//	ПравилаОбмена.Прочитать();
	//	Возврат;
	//	
	//ИначеЕсли ПравилаОбмена.ТипУзла = одТипУзлаXML_НачалоЭлемента Тогда
	//		
	//	// это новый элемент
	//	НовоеСоответствие = Новый Соответствие;
	//	СоответствиеТипа.Вставить(ИмяУзла, НовоеСоответствие);
	//	
	//	ЗагрузитьОдинТипДанных(ПравилаОбмена, НовоеСоответствие, ПравилаОбмена.ЛокальноеИмя);			
	//	ПравилаОбмена.Прочитать();
	//	
	//Иначе
	//	СоответствиеТипа.Вставить(ИмяУзла, Тип(ПравилаОбмена.Значение));
	//	ПравилаОбмена.Прочитать();
	//КонецЕсли;	
	//
	//ЗагрузитьСоответствиеТиповДляОдногоТипа(ПравилаОбмена, СоответствиеТипа);
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСДанными

// Возвращает объект ОписаниеТипов, содержащий указанный тип.
//
// Параметры:
//  ЗначениеТипа - Строка
//               - Тип - содержит имя типа или значение типа Тип.
//  
// Возвращаемое значение:
//  ОписаниеТипов - объект Описание типов.
//
Функция одОписаниеТипа(ЗначениеТипа) Экспорт
	
	ОписаниеТипов = мСоответствиеОписаниеТипов[ЗначениеТипа];
	
	Если ОписаниеТипов = Неопределено Тогда
		
		МассивТипов = Новый Массив;
		Если ТипЗнч(ЗначениеТипа) = одТипСтрока Тогда
			МассивТипов.Добавить(Тип(ЗначениеТипа));
		Иначе
			МассивТипов.Добавить(ЗначениеТипа);
		КонецЕсли; 
		ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
		
		мСоответствиеОписаниеТипов.Вставить(ЗначениеТипа, ОписаниеТипов);
		
	КонецЕсли;
	
	Возврат ОписаниеТипов;
	
КонецФункции

// Осуществляет простой поиск объекта информационной базы по указанному свойству.
//
// Параметры:
//  Стр            - Строка - значение свойства, по которому осуществляется 
//                   поиск объект;
//  Тип            - Тип - тип искомого объекта;
//  Свойство       - Строка - имя свойства, по-которому ищем объект.
//
// Возвращаемое значение:
//  Произвольный - найденный объект информационной базы.
//
Функция одПолучитьЗначениеПоСтроке(Стр, Тип, Свойство = "") Экспорт

	Если ПустаяСтрока(Стр) Тогда
		Возврат Новый(Тип);
	КонецЕсли; 

	Свойства = Менеджеры[Тип];

	Если Свойства = Неопределено Тогда
		
		ОписаниеТипов = одОписаниеТипа(Тип);
		Возврат ОписаниеТипов.ПривестиЗначение(Стр);
		
	КонецЕсли;

	Если ПустаяСтрока(Свойство) Тогда
		
		Если Свойства.ИмяТипа = "Перечисление" Тогда
			Свойство = "Имя";
		Иначе
			Свойство = "{ИмяПредопределенногоЭлемента}";
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат НайтиОбъектПоСвойству(Свойства.Менеджер, Свойство, Стр, Неопределено);
	
КонецФункции

// Осуществляет простой поиск объекта информационной базы по указанному свойству.
//
// Параметры:
//  Менеджер       - СправочникМенеджер
//                 - ДокументМенеджер - менеджер искомого объекта;
//  Свойство       - Строка - свойство, по которому осуществляем поиск: Имя, Код, 
//                   Наименование или Имя индексируемого реквизита.
//  Значение       - Строка
//                 - Число
//                 - Дата - значение свойства, по которому ищем объект.
//  НайденныйОбъектПоУникальномуИдентификатору - СправочникОбъект
//                                             - ДокументОбъект - объект информационной базы, 
//                   который был найден по уникальному идентификатору в ходе выполнения функции.
//  ОбщаяСтруктураСвойств - Структура - свойства искомого объекта.
//  ОбщиеСвойстваПоиска - Структура
//  СтрокаЗапросаПоискаПоУникальномуИдентификатору - Строка - текст запроса для поиска по уникальному идентификатору.
//
// Возвращаемое значение:
//  Произвольный - найденный объект информационной базы.
//
Функция НайтиОбъектПоСвойству(Менеджер, 
							  Свойство, 
							  Значение, 
							  НайденныйОбъектПоУникальномуИдентификатору, 
							  ОбщаяСтруктураСвойств = Неопределено, 
							  ОбщиеСвойстваПоиска = Неопределено,
							  СтрокаЗапросаПоискаПоУникальномуИдентификатору = "") Экспорт
	
	Если ОбщаяСтруктураСвойств = Неопределено Тогда
		Попытка
			ТекСтруктураСвойств = Менеджеры[ТипЗнч(Менеджер.ПустаяСсылка())];
			ИмяТипа = ТекСтруктураСвойств.ИмяТипа;
		Исключение
			ИмяТипа = "";
		КонецПопытки;
	Иначе
		ИмяТипа = ОбщаяСтруктураСвойств.ИмяТипа;
	КонецЕсли;
	
	Если Свойство = "Имя" Тогда
		
		Возврат Менеджер[Значение];
		
	ИначеЕсли Свойство = "Код"
		И (ИмяТипа = "Справочник"
		ИЛИ ИмяТипа = "ПланВидовХарактеристик"
		ИЛИ ИмяТипа = "ПланСчетов"
		ИЛИ ИмяТипа = "ПланОбмена"
		ИЛИ ИмяТипа = "ПланВидовРасчета") Тогда
		
		Возврат Менеджер.НайтиПоКоду(Значение);
		
	ИначеЕсли Свойство = "Наименование"
		И (ИмяТипа = "Справочник"
		ИЛИ ИмяТипа = "ПланВидовХарактеристик"
		ИЛИ ИмяТипа = "ПланСчетов"
		ИЛИ ИмяТипа = "ПланОбмена"
		ИЛИ ИмяТипа = "ПланВидовРасчета"
		ИЛИ ИмяТипа = "Задача") Тогда
		
		Возврат Менеджер.НайтиПоНаименованию(Значение, ИСТИНА);
		
	ИначеЕсли Свойство = "Номер"
		И (ИмяТипа = "Документ"
		ИЛИ ИмяТипа = "БизнесПроцесс"
		ИЛИ ИмяТипа = "Задача") Тогда
		
		Возврат Менеджер.НайтиПоНомеру(Значение);
		
	ИначеЕсли Свойство = "{УникальныйИдентификатор}" Тогда
		
		СсылкаПоИдентификатору = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(Значение));
		
		Ссылка = ПроверитьСуществованиеСсылки(СсылкаПоИдентификатору, Менеджер, НайденныйОбъектПоУникальномуИдентификатору,
			СтрокаЗапросаПоискаПоУникальномуИдентификатору);
			
		Возврат Ссылка;
		
	ИначеЕсли Свойство = "{ИмяПредопределенногоЭлемента}" Тогда
		
		Попытка
			
			Ссылка = Менеджер[Значение];
			
		Исключение
			
			Ссылка = Менеджер.НайтиПоКоду(Значение);
			
		КонецПопытки;
		
		Возврат Ссылка;
		
	Иначе
		
		// Можно найти только по реквизиту, кроме строк произвольной длины и хранилища значений.
		Если НЕ (Свойство = "Дата"
			ИЛИ Свойство = "Проведен"
			ИЛИ Свойство = "ПометкаУдаления"
			ИЛИ Свойство = "Владелец"
			ИЛИ Свойство = "Родитель"
			ИЛИ Свойство = "ЭтоГруппа") Тогда
			
			Попытка
				
				СтрокаНеограниченнойДлины = ОпределитьЭтотПараметрНеограниченнойДлинны(ОбщаяСтруктураСвойств, Значение, Свойство);
				
			Исключение
				
				СтрокаНеограниченнойДлины = Ложь;
				
			КонецПопытки;
			
			Если НЕ СтрокаНеограниченнойДлины Тогда
				
				Возврат Менеджер.НайтиПоРеквизиту(Свойство, Значение);
				
			КонецЕсли;
			
		КонецЕсли;
		
		СсылкаНаОбъект = НайтиЭлементЗапросом(ОбщаяСтруктураСвойств, ОбщиеСвойстваПоиска, , Менеджер);
		Возврат СсылкаНаОбъект;
		
	КонецЕсли;
	
КонецФункции

Функция ОпределитьУПоляНеограниченнаяДлина(МенеджерТипа, ИмяПараметра)
	
	ДлинныеСтроки = Неопределено;
	Если НЕ МенеджерТипа.Свойство("ДлинныеСтроки", ДлинныеСтроки) Тогда
		
		ДлинныеСтроки = Новый Соответствие;
		Для Каждого Реквизит Из МенеджерТипа.ОбъектМД.Реквизиты Цикл
			
			Если Реквизит.Тип.СодержитТип(одТипСтрока) 
				И (Реквизит.Тип.КвалификаторыСтроки.Длина = 0) Тогда
				
				ДлинныеСтроки.Вставить(Реквизит.Имя, Реквизит.Имя);	
				
			КонецЕсли;
			
		КонецЦикла;
		
		МенеджерТипа.Вставить("ДлинныеСтроки", ДлинныеСтроки);
		
	КонецЕсли;
	
	Возврат (ДлинныеСтроки[ИмяПараметра] <> Неопределено);
		
КонецФункции

Функция ОпределитьЭтотПараметрНеограниченнойДлинны(МенеджерТипа, ЗначениеПараметра, ИмяПараметра)
	
	Попытка
			
		Если ТипЗнч(ЗначениеПараметра) = одТипСтрока Тогда
			СтрокаНеограниченнойДлины = ОпределитьУПоляНеограниченнаяДлина(МенеджерТипа, ИмяПараметра);
		Иначе
			СтрокаНеограниченнойДлины = Ложь;
		КонецЕсли;		
												
	Исключение
				
		СтрокаНеограниченнойДлины = Ложь;
				
	КонецПопытки;
	
	Возврат СтрокаНеограниченнойДлины;	
	
КонецФункции

Функция НайтиЭлементЗапросом(СтруктураСвойств, 
							 СвойстваПоиска, 
							 ТипОбъекта = Неопределено, 
							 МенеджерТипа = Неопределено, 
							 КоличествоРеальныхСвойствДляПоиска = Неопределено)
	
	КоличествоСвойствДляПоиска = 
		?(КоличествоРеальныхСвойствДляПоиска = Неопределено, СвойстваПоиска.Количество(), КоличествоРеальныхСвойствДляПоиска);
	
	Если КоличествоСвойствДляПоиска = 0
		И СтруктураСвойств.ИмяТипа = "Перечисление" Тогда
		
		Возврат СтруктураСвойств.ПустаяСсылка;
		
	КонецЕсли;	
	
	ТекстЗапроса       = СтруктураСвойств.СтрокаПоиска;
	
	Если ПустаяСтрока(ТекстЗапроса) Тогда
		Возврат СтруктураСвойств.ПустаяСсылка;
	КонецЕсли;
	
	ЗапросПоиска       = Новый Запрос();
	КоличествоСвойствПоКоторымУстановленПоиск = 0;
			
	Для каждого Свойство Из СвойстваПоиска Цикл
				
		ИмяПараметра      = Свойство.Ключ;
		
		// Не по всем параметрам можно искать.
		Если ИмяПараметра = "{УникальныйИдентификатор}"
			ИЛИ ИмяПараметра = "{ИмяПредопределенногоЭлемента}" Тогда
						
			Продолжить;
						
		КонецЕсли;
		
		ЗначениеПараметра = Свойство.Значение;
		ЗапросПоиска.УстановитьПараметр(ИмяПараметра, ЗначениеПараметра);
				
		Попытка
			
			СтрокаНеограниченнойДлины = ОпределитьЭтотПараметрНеограниченнойДлинны(СтруктураСвойств, ЗначениеПараметра, ИмяПараметра);		
													
		Исключение
					
			СтрокаНеограниченнойДлины = Ложь;
					
		КонецПопытки;
		
		КоличествоСвойствПоКоторымУстановленПоиск = КоличествоСвойствПоКоторымУстановленПоиск + 1;
				
		Если СтрокаНеограниченнойДлины Тогда
					
			ТекстЗапроса = ТекстЗапроса + ?(КоличествоСвойствПоКоторымУстановленПоиск > 1, " И ", "") + ИмяПараметра + " ПОДОБНО &" + ИмяПараметра;
					
		Иначе
					
			ТекстЗапроса = ТекстЗапроса + ?(КоличествоСвойствПоКоторымУстановленПоиск > 1, " И ", "") + ИмяПараметра + " = &" + ИмяПараметра;
					
		КонецЕсли;
								
	КонецЦикла;
	
	Если КоличествоСвойствПоКоторымУстановленПоиск = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗапросПоиска.Текст = ТекстЗапроса;
	Результат = ЗапросПоиска.Выполнить();
			
	Если Результат.Пустой() Тогда
		
		Возврат Неопределено;
								
	Иначе
		
		// Возвращаем первый найденный объект.
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		СсылкаНаОбъект = Выборка.Ссылка;
				
	КонецЕсли;
	
	Возврат СсылкаНаОбъект;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Проверяет тип данных:
//
// Параметры:
//   Тип - Тип - Проверяемый тип значения.
//
// Возвращаемое значение:
//   Булево - результат проверки
//
Функция ЭтоПростойТипДанных(Тип) 
	
	Результат = Истина;
	
	Если Тип = одТипБулево
		ИЛИ Тип = одТипДата
		ИЛИ Тип = одТипСтрока 
		ИЛИ Тип = одТипЧисло Тогда
		Результат = Истина;
	Иначе
		Результат = Ложь;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ЭтоПростойТипДанных


#Область ИнициализацияРеквизитовИМодульныхПеременных

Процедура ИнициализироватьКомментарииПриВыгрузкеИЗагрузкеДанных()
	
	//КомментарийПриВыгрузкеДанных = "";
	КомментарийПриЗагрузкеДанных = "";
	
КонецПроцедуры

// Инициализирует реквизиты обработки и модульные переменные.
//
// Параметры:
//  Нет.
// 
Процедура ИнициализацияРеквизитовИМодульныхПеременных()
	
	БезопасныйРежим = Истина; // Для совместимости. Возможно убрать в будущем.
	
	//КоличествоОбработанныхОбъектовДляОбновленияСтатуса = 100; // реквизит обработки
	
	ЗапоминатьЗагруженныеОбъекты     = Истина; // экспортная переменная
	ЧислоХранимыхЗагруженныхОбъектов = 5000; // экспортная переменная
	
	ПараметрыИнициализированы        = Ложь; // экспортная переменная
	
	//ВестиДополнительныйКонтрольЗаписиВXML = Ложь; // реквизит обработки
	//НепосредственноеЧтениеВИБПриемнике = Ложь; // реквизит обработки
	НеВыводитьНикакихИнформационныхСообщенийПользователю = Ложь; // реквизит обработки
	
	Менеджеры    = Неопределено; // экспортная переменная
	одСообщения  = Неопределено; // переменнна
	
	ФлагОшибки   = Ложь; // реквизит обработки
	
	СоздатьСтруктуруКонвертации();
	
	Правила      = Новый Структура; // экспортная переменная
	Алгоритмы    = Новый Структура; // экспортная переменная
	//ДопОбработки = Новый Структура; // экспортная переменная
	Запросы      = Новый Структура; // экспортная переменная

	Параметры    = Новый Структура; // реквизит обработки
	СобытияПослеЗагрузкиПараметров = Новый Структура; // экспортная переменная
	
	ПараметрыДопОбработок = Новый Структура; // экспортная переменная
	
	// Типы
	одТипСтрока                  = Тип("Строка");
	одТипБулево                  = Тип("Булево");
	одТипЧисло                   = Тип("Число");
	одТипДата                    = Тип("Дата");
	одТипХранилищеЗначения       = Тип("ХранилищеЗначения");
	одТипУникальныйИдентификатор = Тип("УникальныйИдентификатор");
	одТипДвоичныеДанные          = Тип("ДвоичныеДанные");
	одТипВидДвиженияНакопления   = Тип("ВидДвиженияНакопления");
	одТипУдалениеОбъекта         = Тип("УдалениеОбъекта");
	одТипВидСчета			     = Тип("ВидСчета");
	одТипТип                     = Тип("Тип");
	одТипСоответствие            = Тип("Соответствие");

	ЗначениеПустаяДата		   = Дата('00010101');
	
	//мXMLПравила  = Неопределено; // экспортная переменная
	
	//// Типы узлов xml
	//одТипУзлаXML_КонецЭлемента  = ТипУзлаXML.КонецЭлемента;
	//одТипУзлаXML_НачалоЭлемента = ТипУзлаXML.НачалоЭлемента;
	//одТипУзлаXML_Текст          = ТипУзлаXML.Текст;

	// мСписокМакетовПравилОбмена  = Новый СписокЗначений; // экспортная переменная
	//Для каждого Макет Из Метаданные().Макеты Цикл
	//	мСписокМакетовПравилОбмена.Добавить(Макет.Синоним);
	//КонецЦикла; 
	
	//мФайлПротоколаДанных = Неопределено; // экспортная переменная
	
	//ТипИнформационнойБазыДляПодключения = Истина; // реквизит обработки
	//АутентификацияWindowsИнформационнойБазыДляПодключения = Ложь; // реквизит обработки
	//ВерсияПлатформыИнформационнойБазыДляПодключения = "V8"; // реквизит обработки
	//ОткрыватьПротоколыОбменаПослеВыполненияОпераций = Ложь; // реквизит обработки
	ЗагружатьДанныеВРежимеОбмена = Истина; // реквизит обработки
	ЗаписыватьВИнформационнуюБазуТолькоИзмененныеОбъекты = Ложь; // реквизит обработки, всегда всё записсываем
	ЗаписыватьРегистрыНаборамиЗаписей = Истина; // реквизит обработки
	ОптимизированнаяЗаписьОбъектов = Истина; // реквизит обработки
	//ВыгружатьТолькоРазрешенные = Истина; // реквизит обработки
	ОбъектыПоСсылкеЗагружатьБезПометкиУдаления = Истина;	 // реквизит обработки
	//ИспользоватьОтборПоДатеДляВсехОбъектов = Истина; // реквизит обработки
	
	мСоответствиеПустыхЗначенийТипов = Новый Соответствие; // переменная
	мСоответствиеОписаниеТипов = Новый Соответствие; // переменная
	
	//мБылиПрочитаныПравилаОбменаПриЗагрузке = Ложь; // экспортная переменная

	//ОбработчикиСобытийЧитаемИзФайлаПравилОбмена = Истина; // Реквизит Объекта
	
	мРежимыОбработкиДанных = Новый Структура;
	мРежимыОбработкиДанных.Вставить("Загрузка",                   0);
	//мРежимыОбработкиДанных.Вставить("Выгрузка",                   0);
	//мРежимыОбработкиДанных.Вставить("Загрузка",                   1);
	//мРежимыОбработкиДанных.Вставить("ЗагрузкаПравилОбмена",       2);
	//мРежимыОбработкиДанных.Вставить("ЭкспортОбработчиковСобытий", 3);
	
	РежимОбработкиДанных = мРежимыОбработкиДанных.Загрузка;
	
	мРежимыОтладкиАлгоритмов = Новый Структура;
	мРежимыОтладкиАлгоритмов.Вставить("НеИспользовать",   0);
	мРежимыОтладкиАлгоритмов.Вставить("ПроцедурныйВызов", 1);
	мРежимыОтладкиАлгоритмов.Вставить("ИнтеграцияКода",   2);
	
	РежимОтладкиАлгоритмов = мРежимыОтладкиАлгоритмов.НеИспользовать;
	
	// Модули стандартных подсистем.
	Попытка
		// Вызов ВычислитьВБезопасномРежиме не требуется, т.к. для вычисления передается строковый литерал.
		МодульДатыЗапретаИзменения = Вычислить("ДатыЗапретаИзменения");
	Исключение
		МодульДатыЗапретаИзменения = Неопределено;
	КонецПопытки;
	
	// Пока оставим, уточнить надобность:
	РазделителиКонфигурации = Новый Массив;
	Для Каждого ОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
		Если ОбщийРеквизит.РазделениеДанных = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять Тогда
			РазделителиКонфигурации.Добавить(ОбщийРеквизит.Имя);
		КонецЕсли;
	КонецЦикла;
	РазделителиКонфигурации = Новый ФиксированныйМассив(РазделителиКонфигурации);
	
	//ВременныйКаталогРаботыСФайлами = ПолучитьИмяВременногоФайла();
	//УдалитьФайлы(ВременныйКаталогРаботыСФайлами);
	
	ОбрезатьСтрокиСправа = Истина;
	
	мОшибки = Новый Массив;
	
КонецПроцедуры

// Инициализирует структуру для хранения глобальных обработчиков элемента спр. "СМП_УчетныеЗаписиОбменовДанными".
//
Процедура СоздатьСтруктуруКонвертации()
	
	Конвертация  = Новый Структура(
	"ПередВыгрузкойДанных, 
	|ПослеВыгрузкиДанных, 
	|ПередВыгрузкойОбъекта, 
	|ПослеВыгрузкиОбъекта, 
	|ПередКонвертациейОбъекта, 
	|ПередЗагрузкойОбъекта, 
	|ПослеЗагрузкиОбъекта, 
	|ПередЗагрузкойДанных, 
	|ПослеЗагрузкиДанных");
	
КонецПроцедуры

// Инициализация служебных таблиц.
//
Процедура ДополнитьСлужебныеТаблицыКолонками()
	
	ИнициализацияТаблицыПравилКонвертации();
	//ИнициализацияТаблицыПравилВыгрузки();
	//ИнициализацияТаблицыПравилОчистки();
	ИнициализацияТаблицыНастройкиПараметров();
	
КонецПроцедуры

Процедура ИнициализацияСтруктурыИменОбработчиков()
	
	// Обработчики Конвертации.
	ИменаОбработчиковКонвертации = Новый Структура;
	ИменаОбработчиковКонвертации.Вставить("ПередВыгрузкойДанных"); // Отсутствует
	ИменаОбработчиковКонвертации.Вставить("ПослеВыгрузкиДанных"); // Отсутствует
	ИменаОбработчиковКонвертации.Вставить("ПередВыгрузкойОбъекта"); // Отсутствует
	ИменаОбработчиковКонвертации.Вставить("ПослеВыгрузкиОбъекта"); // Отсутствует
	ИменаОбработчиковКонвертации.Вставить("ПередКонвертациейОбъекта");
	ИменаОбработчиковКонвертации.Вставить("ПередОтправкойИнформацииОбУдалении"); // Отсутствует
	ИменаОбработчиковКонвертации.Вставить("ПередПолучениемИзмененныхОбъектов");
	
	ИменаОбработчиковКонвертации.Вставить("ПередЗагрузкойОбъекта");
	ИменаОбработчиковКонвертации.Вставить("ПослеЗагрузкиОбъекта");
	ИменаОбработчиковКонвертации.Вставить("ПередЗагрузкойДанных");
	ИменаОбработчиковКонвертации.Вставить("ПослеЗагрузкиДанных");
	ИменаОбработчиковКонвертации.Вставить("ПриПолученииИнформацииОбУдалении");
	ИменаОбработчиковКонвертации.Вставить("ПослеПолученияИнформацииОбУзлахОбмена"); // Отсутствует
	
	ИменаОбработчиковКонвертации.Вставить("ПослеЗагрузкиПравилОбмена");
	ИменаОбработчиковКонвертации.Вставить("ПослеЗагрузкиПараметров");
	
	// Обработчики ПКО.
	ИменаОбработчиковПКО = Новый Структура;
	ИменаОбработчиковПКО.Вставить("ПередВыгрузкой"); // Отсутствует
	ИменаОбработчиковПКО.Вставить("ПриВыгрузке"); // Отсутствует
	ИменаОбработчиковПКО.Вставить("ПослеВыгрузки"); // Отсутствует
	ИменаОбработчиковПКО.Вставить("ПослеВыгрузкиВФайл"); // Отсутствует
	
	ИменаОбработчиковПКО.Вставить("ПередЗагрузкой");
	ИменаОбработчиковПКО.Вставить("ПриЗагрузке");
	ИменаОбработчиковПКО.Вставить("ПослеЗагрузки");
	
	ИменаОбработчиковПКО.Вставить("ПоследовательностьПолейПоиска");
	
	// Обработчики ПКС.
	ИменаОбработчиковПКС = Новый Структура;
	ИменаОбработчиковПКС.Вставить("ПередВыгрузкой");
	ИменаОбработчиковПКС.Вставить("ПриВыгрузке");
	ИменаОбработчиковПКС.Вставить("ПослеВыгрузки");

	// Обработчики ПКГС.
	ИменаОбработчиковПКГС = Новый Структура;
	ИменаОбработчиковПКГС.Вставить("ПередВыгрузкой");
	ИменаОбработчиковПКГС.Вставить("ПриВыгрузке");
	ИменаОбработчиковПКГС.Вставить("ПослеВыгрузки");
	
	ИменаОбработчиковПКГС.Вставить("ПередОбработкойВыгрузки");
	ИменаОбработчиковПКГС.Вставить("ПослеОбработкиВыгрузки");
	
	// Обработчики ПВД.
	ИменаОбработчиковПВД = Новый Структура;
	ИменаОбработчиковПВД.Вставить("ПередОбработкой");
	ИменаОбработчиковПВД.Вставить("ПослеОбработки");
	ИменаОбработчиковПВД.Вставить("ПередВыгрузкой");
	ИменаОбработчиковПВД.Вставить("ПослеВыгрузки");
	
	// Обработчики ПОД.
	ИменаОбработчиковПОД = Новый Структура;
	ИменаОбработчиковПОД.Вставить("ПередОбработкой");
	ИменаОбработчиковПОД.Вставить("ПослеОбработки");
	ИменаОбработчиковПОД.Вставить("ПередУдалением");
	
	// Глобальная структура с именами обработчиков.
	ИменаОбработчиков = Новый Структура;
	ИменаОбработчиков.Вставить("Конвертация", ИменаОбработчиковКонвертации); 
	ИменаОбработчиков.Вставить("ПКО",         ИменаОбработчиковПКО); 
	ИменаОбработчиков.Вставить("ПКС",         ИменаОбработчиковПКС); 
	ИменаОбработчиков.Вставить("ПКГС",        ИменаОбработчиковПКГС); 
	ИменаОбработчиков.Вставить("ПВД",         ИменаОбработчиковПВД); 
	ИменаОбработчиков.Вставить("ПОД",         ИменаОбработчиковПОД); 
	
КонецПроцедуры

// Выполняет инициализация менеджеров объектов и всех сообщений протокола обмена данными.
//
// Параметры:
//  Нет.
// 
Процедура ИнициализироватьМенеджерыИСообщения() Экспорт
	
	Если Менеджеры = Неопределено Тогда
		ИнициализацияМенеджеров();
	КонецЕсли; 

	Если одСообщения = Неопределено Тогда
		ИнициализацияСообщений();
	КонецЕсли;
	
КонецПроцедуры

// Инициализирует переменную Менеджеры, содержащую соответствия типов объектов их свойствам.
//
// Параметры:
//  Нет.
// 
Процедура ИнициализацияМенеджеров()

	Менеджеры = Новый Соответствие;
	
	МенеджерыДляПлановОбмена = Новый Соответствие;
    	
	// ССЫЛКИ
	
	Для каждого ОбъектМД Из Метаданные.Справочники Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "Справочник", Справочники[ОбъектМД.Имя], "СправочникСсылка", Истина);
					
	КонецЦикла;

	Для каждого ОбъектМД Из Метаданные.Документы Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "Документ", Документы[ОбъектМД.Имя], "ДокументСсылка");
				
	КонецЦикла;

	Для каждого ОбъектМД Из Метаданные.ПланыВидовХарактеристик Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "ПланВидовХарактеристик", ПланыВидовХарактеристик[ОбъектМД.Имя], "ПланВидовХарактеристикСсылка", Истина);
				
	КонецЦикла;
	
	Для каждого ОбъектМД Из Метаданные.ПланыСчетов Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "ПланСчетов", ПланыСчетов[ОбъектМД.Имя], "ПланСчетовСсылка", Истина);
						
	КонецЦикла;
	
	Для каждого ОбъектМД Из Метаданные.ПланыВидовРасчета Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "ПланВидовРасчета", ПланыВидовРасчета[ОбъектМД.Имя], "ПланВидовРасчетаСсылка", Истина);
				
	КонецЦикла;
	
	Для каждого ОбъектМД Из Метаданные.ПланыОбмена Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "ПланОбмена", ПланыОбмена[ОбъектМД.Имя], "ПланОбменаСсылка");
				
	КонецЦикла;
	
	Для каждого ОбъектМД Из Метаданные.Задачи Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "Задача", Задачи[ОбъектМД.Имя], "ЗадачаСсылка");
				
	КонецЦикла;
	
	Для каждого ОбъектМД Из Метаданные.БизнесПроцессы Цикл
		
		ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, "БизнесПроцесс", БизнесПроцессы[ОбъектМД.Имя], "БизнесПроцессСсылка");
		
		ИмяТипа = "ТочкаМаршрутаБизнесПроцесса";
		// ссылка на точки маршрута
		Имя              = ОбъектМД.Имя;
		Менеджер         = БизнесПроцессы[Имя].ТочкиМаршрута;
		СтрокаПоиска     = "";
		ТипСсылкиСтрокой = "ТочкаМаршрутаБизнесПроцессаСсылка." + Имя;
		ТипСсылки        = Тип(ТипСсылкиСтрокой);
		Структура = СтруктураПараметровМенеджера(Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД);
		Структура.Вставить("ПустаяСсылка", Неопределено);
		Структура.Вставить("СтрокаПоиска", СтрокаПоиска);
		Менеджеры.Вставить(ТипСсылки, Структура);
				
	КонецЦикла;
	
	// РЕГИСТРЫ

	Для каждого ОбъектМД Из Метаданные.РегистрыСведений Цикл
		
		ДополнитьМассивМенеджеровТипомРегистра(Менеджеры, ОбъектМД, "РегистрСведений", РегистрыСведений[ОбъектМД.Имя], "РегистрСведенийЗапись", "РегистрСведенийВыборка");
						
	КонецЦикла;

	Для каждого ОбъектМД Из Метаданные.РегистрыБухгалтерии Цикл
		
		ДополнитьМассивМенеджеровТипомРегистра(Менеджеры, ОбъектМД, "РегистрБухгалтерии", РегистрыБухгалтерии[ОбъектМД.Имя], "РегистрБухгалтерииЗапись", "РегистрБухгалтерииВыборка");
				
	КонецЦикла;
	
	Для каждого ОбъектМД Из Метаданные.РегистрыНакопления Цикл
		
		ДополнитьМассивМенеджеровТипомРегистра(Менеджеры, ОбъектМД, "РегистрНакопления", РегистрыНакопления[ОбъектМД.Имя], "РегистрНакопленияЗапись", "РегистрНакопленияВыборка");
						
	КонецЦикла;
	
	Для каждого ОбъектМД Из Метаданные.РегистрыРасчета Цикл
		
		ДополнитьМассивМенеджеровТипомРегистра(Менеджеры, ОбъектМД, "РегистрРасчета", РегистрыРасчета[ОбъектМД.Имя], "РегистрРасчетаЗапись", "РегистрРасчетаВыборка");
						
	КонецЦикла;
	
	ИмяТипа = "Перечисление";
	
	Для каждого ОбъектМД Из Метаданные.Перечисления Цикл
		
		Имя              = ОбъектМД.Имя;
		Менеджер         = Перечисления[Имя];
		ТипСсылкиСтрокой = "ПеречислениеСсылка." + Имя;
		ТипСсылки        = Тип(ТипСсылкиСтрокой);
		Структура = СтруктураПараметровМенеджера(Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД);
		Структура.Вставить("ПустаяСсылка", Перечисления[Имя].ПустаяСсылка());

		Менеджеры.Вставить(ТипСсылки, Структура);
		
	КонецЦикла;	
	
	// Константы
	ИмяТипа             = "Константы";
	ОбъектМД            = Метаданные.Константы;
	Имя					= "Константы";
	Менеджер			= Константы;
	ТипСсылкиСтрокой	= "КонстантыНабор";
	ТипСсылки			= Тип(ТипСсылкиСтрокой);
	Структура = СтруктураПараметровМенеджера(Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД);
	Менеджеры.Вставить(ТипСсылки, Структура);
	
КонецПроцедуры

Процедура ДополнитьМассивМенеджеровСсылочнымТипом(Менеджеры, МенеджерыДляПлановОбмена, ОбъектМД, ИмяТипа, Менеджер, ПрефиксИмениТипа, ВозможенПоискПоПредопределенным = Ложь)
	
	Имя              = ОбъектМД.Имя;
	ТипСсылкиСтрокой = ПрефиксИмениТипа + "." + Имя;
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	ПсевдонимТаблицыМетаданных.Ссылка
	|ИЗ
	|	&ИмяТаблицыМетаданных КАК ПсевдонимТаблицыМетаданных
	|ГДЕ
	|	&ПараметрАвтозаменыДляОбнуленияСекцииУсловий";
	
	СтрокаЗамены = "";
	СтрокаЗамены = СтрШаблон("%1.%2", ИмяТипа, Имя);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицыМетаданных", СтрокаЗамены);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПараметрАвтозаменыДляОбнуленияСекцииУсловий", "");
	
	СтрокаПоиска     = ТекстЗапроса;
	ТипСсылки        = Тип(ТипСсылкиСтрокой);
	Структура = СтруктураПараметровМенеджера(Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД);
	Структура.Вставить("ВозможенПоискПоПредопределенным", ВозможенПоискПоПредопределенным);
	Структура.Вставить("СтрокаПоиска", СтрокаПоиска);
	Менеджеры.Вставить(ТипСсылки, Структура);
	
	СтруктураДляПланаОбмена = СтруктураПараметровПланаОбмена(Имя, ТипСсылки, Истина, Ложь);
	МенеджерыДляПлановОбмена.Вставить(ОбъектМД, СтруктураДляПланаОбмена);
	
КонецПроцедуры

Процедура ДополнитьМассивМенеджеровТипомРегистра(Менеджеры, ОбъектМД, ИмяТипа, Менеджер, ПрефиксИмениТипаЗапись, ПрефиксИмениТипаВыборка)
	
	Периодический = Неопределено;
	
	Имя					= ОбъектМД.Имя;
	ТипСсылкиСтрокой	= ПрефиксИмениТипаЗапись + "." + Имя;
	ТипСсылки			= Тип(ТипСсылкиСтрокой);
	Структура = СтруктураПараметровМенеджера(Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД);
	
	Если ИмяТипа = "РегистрСведений" Тогда
		
		Периодический = (ОбъектМД.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический);
		ПодчиненныйРегистратору = (ОбъектМД.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору);
		
		Структура.Вставить("Периодический", Периодический);
		Структура.Вставить("ПодчиненныйРегистратору", ПодчиненныйРегистратору);
		
	КонецЕсли;	
	
	Менеджеры.Вставить(ТипСсылки, Структура);
		

	СтруктураДляПланаОбмена = СтруктураПараметровПланаОбмена(Имя, ТипСсылки, Ложь, Истина);

	МенеджерыДляПлановОбмена.Вставить(ОбъектМД, СтруктураДляПланаОбмена);
	
	
	ТипСсылкиСтрокой	= ПрефиксИмениТипаВыборка + "." + Имя;
	ТипСсылки			= Тип(ТипСсылкиСтрокой);
	Структура = СтруктураПараметровМенеджера(Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД);

	Если Периодический <> Неопределено Тогда
		
		Структура.Вставить("Периодический", Периодический);
		Структура.Вставить("ПодчиненныйРегистратору", ПодчиненныйРегистратору);	
		
	КонецЕсли;
	
	Менеджеры.Вставить(ТипСсылки, Структура);	
		
КонецПроцедуры

// Возвращаемое значение:
//   Структура - описание менеджера типа значения:
//     * Имя - Строка
//     * ИмяТипа - Строка
//     * ТипСсылкиСтрокой - Строка
//     * Менеджер - Произвольный
//     * ОбъектМД - ОбъектМетаданных
//     * ВозможенПоискПоПредопределенным - Булево
//     * ПКО - Произвольный
//
Функция СтруктураПараметровМенеджера(Имя, ИмяТипа, ТипСсылкиСтрокой, Менеджер, ОбъектМД)
	Структура = Новый Структура();
	Структура.Вставить("Имя", Имя);
	Структура.Вставить("ИмяТипа", ИмяТипа);
	Структура.Вставить("ТипСсылкиСтрокой", ТипСсылкиСтрокой);
	Структура.Вставить("Менеджер", Менеджер);
	Структура.Вставить("ОбъектМД", ОбъектМД);
	Структура.Вставить("ВозможенПоискПоПредопределенным", Ложь);
	Структура.Вставить("ПКО");
	Возврат Структура;
КонецФункции

Функция СтруктураПараметровПланаОбмена(Имя, ТипСсылки, ЭтоСсылочныйТип, ЭтоРегистр)
	Структура = Новый Структура();
	Структура.Вставить("Имя",Имя);
	Структура.Вставить("ТипСсылки",ТипСсылки);
	Структура.Вставить("ЭтоСсылочныйТип",ЭтоСсылочныйТип);
	Структура.Вставить("ЭтоРегистр",ЭтоРегистр);
	Возврат Структура;
КонецФункции

// Инициализирует переменную одСообщения, содержащую соответствия кодов сообщений их описаниям.
//
// Параметры:
//  Нет.
// 
Процедура ИнициализацияСообщений()

	одСообщения = Новый Соответствие;
	
	одСообщения.Вставить(2,  НСтр("ru = 'Ошибка распаковки файла обмена. Файл заблокирован'"));
	одСообщения.Вставить(3,  НСтр("ru = 'Указанный файл правил обмена не существует'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка при создании COM-объекта %1'");
	одСообщения.Вставить(4,  СтрШаблон(ТекстОшибки,"Msxml2.DOMDocument"));
	
	одСообщения.Вставить(5,  НСтр("ru = 'Ошибка открытия файла обмена'"));
	одСообщения.Вставить(6,  НСтр("ru = 'Ошибка при загрузке правил обмена'"));
	одСообщения.Вставить(7,  НСтр("ru = 'Ошибка формата правил обмена'"));
	одСообщения.Вставить(8,  НСтр("ru = 'Некорректно указано имя файла для выгрузки данных'"));
	одСообщения.Вставить(9,  НСтр("ru = 'Ошибка формата файла обмена'"));
	одСообщения.Вставить(10, НСтр("ru = 'Не указано имя файла для выгрузки данных (Имя файла данных)'"));
	одСообщения.Вставить(11, НСтр("ru = 'Ссылка на несуществующий объект метаданных в правилах обмена'"));
	одСообщения.Вставить(12, НСтр("ru = 'Не указано имя файла с правилами обмена (Имя файла правил)'"));
	
	одСообщения.Вставить(13, НСтр("ru = 'Ошибка получения значения свойства объекта (по имени свойства источника)'"));
	одСообщения.Вставить(14, НСтр("ru = 'Ошибка получения значения свойства объекта (по имени свойства приемника)'"));
	
	одСообщения.Вставить(15, НСтр("ru = 'Не указано имя файла для загрузки данных (Имя файла для загрузки)'"));
	
	одСообщения.Вставить(16, НСтр("ru = 'Ошибка получения значения свойства подчиненного объекта (по имени свойства источника)'"));
	одСообщения.Вставить(17, НСтр("ru = 'Ошибка получения значения свойства подчиненного объекта (по имени свойства приемника)'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1'");
	одСообщения.Вставить(19, СтрШаблон(ТекстОшибки, "ПередЗагрузкойОбъекта"));
	одСообщения.Вставить(20, СтрШаблон(ТекстОшибки, "ПриЗагрузкеОбъекта"));
	одСообщения.Вставить(21, СтрШаблон(ТекстОшибки, "ПослеЗагрузкиОбъекта"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1 (конвертация)'");
	одСообщения.Вставить(22, СтрШаблон(ТекстОшибки, "ПередЗагрузкойДанных"));
	одСообщения.Вставить(23, СтрШаблон(ТекстОшибки, "ПослеЗагрузкиДанных"));
	
	одСообщения.Вставить(24, НСтр("ru = 'Ошибка при удалении объекта'"));
	одСообщения.Вставить(25, НСтр("ru = 'Ошибка при записи документа'"));
	одСообщения.Вставить(26, НСтр("ru = 'Ошибка записи объекта'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1'");
	одСообщения.Вставить(27, СтрШаблон(ТекстОшибки, "ПередОбработкойПравилаВыгрузки"));
	одСообщения.Вставить(28, СтрШаблон(ТекстОшибки, "ПослеОбработкиПравилаОчистки"));
	одСообщения.Вставить(29, СтрШаблон(ТекстОшибки, "ПередУдалениемОбъекта"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1'");
	одСообщения.Вставить(31, СтрШаблон(ТекстОшибки, "ПередОбработкойПравилаВыгрузки"));
	одСообщения.Вставить(32, СтрШаблон(ТекстОшибки, "ПослеОбработкиПравилаВыгрузки"));
	одСообщения.Вставить(33, СтрШаблон(ТекстОшибки, "ПередВыгрузкойОбъекта"));
	одСообщения.Вставить(34, СтрШаблон(ТекстОшибки, "ПослеВыгрузкиОбъекта"));
	
	одСообщения.Вставить(39, НСтр("ru = 'Ошибка при выполнении алгоритма, содержащегося в файле обмена'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1'");
	одСообщения.Вставить(41, СтрШаблон(ТекстОшибки, "ПередВыгрузкойОбъекта"));
	одСообщения.Вставить(42, СтрШаблон(ТекстОшибки, "ПриВыгрузкеОбъекта"));
	одСообщения.Вставить(43, СтрШаблон(ТекстОшибки, "ПослеВыгрузкиОбъекта"));
	
	одСообщения.Вставить(45, НСтр("ru = 'Не найдено правило конвертации объектов'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1 группы свойств'");
	одСообщения.Вставить(48, СтрШаблон(ТекстОшибки, "ПередОбработкойВыгрузки"));
	одСообщения.Вставить(49, СтрШаблон(ТекстОшибки, "ПослеОбработкиВыгрузки"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1 (объекта коллекции)'");
	одСообщения.Вставить(50, СтрШаблон(ТекстОшибки, "ПередВыгрузкой"));
	одСообщения.Вставить(51, СтрШаблон(ТекстОшибки, "ПриВыгрузке"));
	одСообщения.Вставить(52, СтрШаблон(ТекстОшибки, "ПослеВыгрузки"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в глобальном обработчике события %1 (конвертация)'"); 
	одСообщения.Вставить(53, СтрШаблон(ТекстОшибки, "ПередЗагрузкойОбъекта"));
	одСообщения.Вставить(54, СтрШаблон(ТекстОшибки, "ПослеЗагрузкиОбъекта"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1 (свойства)'");
	одСообщения.Вставить(55, СтрШаблон(ТекстОшибки, "ПередВыгрузкой"));
	одСообщения.Вставить(56, СтрШаблон(ТекстОшибки, "ПриВыгрузке"));
	одСообщения.Вставить(57, СтрШаблон(ТекстОшибки, "ПослеВыгрузки"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1 (конвертация)'");
	одСообщения.Вставить(62, СтрШаблон(ТекстОшибки, "ПередВыгрузкойДанных"));
	одСообщения.Вставить(63, СтрШаблон(ТекстОшибки, "ПослеВыгрузкиДанных"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в глобальном обработчике события %1 (конвертация)'");
	одСообщения.Вставить(64,  СтрШаблон(ТекстОшибки, "ПередКонвертациейОбъекта"));
	одСообщения.Вставить(65, СтрШаблон(ТекстОшибки, "ПередВыгрузкойОбъекта"));
	
	одСообщения.Вставить(66, НСтр("ru = 'Ошибка получения коллекции подчиненных объектов из входящих данных'"));
	одСообщения.Вставить(67, НСтр("ru = 'Ошибка получения свойства подчиненного объекта из входящих данных'"));
	одСообщения.Вставить(68, НСтр("ru = 'Ошибка получения свойства объекта из входящих данных'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в глобальном обработчике события %1 (конвертация)'");
	одСообщения.Вставить(69, СтрШаблон(ТекстОшибки, "ПослеВыгрузкиОбъекта"));
	
	одСообщения.Вставить(71, НСтр("ru = 'Не найдено соответствие для значения Источника'"));
	
	одСообщения.Вставить(72, НСтр("ru = 'Ошибка при выгрузке данных для узла плана обмена'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1'");
	одСообщения.Вставить(73, СтрШаблон(ТекстОшибки, "ПоследовательностьПолейПоиска"));
	
	одСообщения.Вставить(74, НСтр("ru = 'Необходимо перезагрузить правила обмена для выгрузки данных'"));
	
	одСообщения.Вставить(75, НСтр("ru = 'Ошибка при выполнении алгоритма после загрузки значений параметров'"));
	
	ТекстОшибки = НСтр("ru = 'Ошибка в обработчике события %1'");
	одСообщения.Вставить(76, СтрШаблон(ТекстОшибки, "ПослеВыгрузкиОбъектаВФайл"));
	
	одСообщения.Вставить(77, НСтр("ru = 'Не указан файл внешней обработки с подключаемыми процедурами обработчиков событий'"));
	
	одСообщения.Вставить(78, НСтр("ru = 'Ошибка создания внешней обработки из файла с процедурами обработчиков событий'"));
	
	одСообщения.Вставить(79, НСтр("ru = 'Код алгоритмов не может быть интегрирован в обработчик из-за обнаруженного рекурсивного вызова алгоритмов. 
	                         |Если в процессе отладки нет необходимости отлаживать код алгоритмов, то укажите режим ""не отлаживать алгоритмы""
	                         |Если необходимо выполнять отладку алгоритмов с рекурсивным вызовом, то укажите режим  ""алгоритмы отлаживать как процедуры"" 
	                         |и повторите выгрузку.'"));
	
	одСообщения.Вставить(80, НСтр("ru = 'Обмен данными можно проводить только под полными правами'"));
	
	одСообщения.Вставить(1000, НСтр("ru = 'Ошибка при создании временного файла выгрузки данных'"));

КонецПроцедуры

// Сохраняет в протокол выполнения (или выводит на экран) сообщения указанной структуры
//
// Параметры:
//  Код               - Число. Код сообщения
//  СтруктураЗаписи   - Структура. Структура записи протокола
//  ВзвестиФлагОшибок - Если истина, то - это сообщение об ошибке. Взводится ФлагОшибки
// 
Функция ЗаписатьВПротоколВыполнения(Код= "", 
									СтруктураЗаписи = Неопределено, 
									ВзвестиФлагОшибок = Истина, 
									Уровень = 0, 
									Выравнивание = 22, 
									БезусловнаяЗаписьВПротоколОбмена = Ложь) Экспорт

	Отступ = "";
    Для Сч = 0 По Уровень-1 Цикл
		Отступ = Отступ + Символы.Таб;
	КонецЦикла; 
	
	Если ТипЗнч(Код) = одТипЧисло Тогда
		
		Если одСообщения = Неопределено Тогда
			ИнициализацияСообщений();
		КонецЕсли;
		
		Стр = одСообщения[Код];
		
	Иначе
		
		Стр = Строка(Код);
		
	КонецЕсли;

	Стр = Отступ + Стр;
	
	Если СтруктураЗаписи <> Неопределено Тогда
		
		Для каждого Поле Из СтруктураЗаписи Цикл
			
			Значение = Поле.Значение;
			Если Значение = Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			Ключ = Поле.Ключ;
			Стр  = Стр + Символы.ПС + Отступ + Символы.Таб + одДополнитьСтроку(Поле.Ключ, Выравнивание) + " =  " + Строка(Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	ИтоговаяСтрокаДляЗаписи = Символы.ПС + Стр;

	
	Если ВзвестиФлагОшибок Тогда
		
		УстановитьФлагОшибки(Истина);
		СообщитьПользователю(ИтоговаяСтрокаДляЗаписи);
		
	Иначе
		
		Если НеВыводитьНикакихИнформационныхСообщенийПользователю = Ложь
			И (БезусловнаяЗаписьВПротоколОбмена ИЛИ ВыводВОкноСообщенийИнформационныхСообщений) Тогда
			
			СообщитьПользователю(ИтоговаяСтрокаДляЗаписи);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если мФайлПротоколаДанных <> Неопределено Тогда
		
		Если ВзвестиФлагОшибок Тогда
			
			мФайлПротоколаДанных.ЗаписатьСтроку(Символы.ПС + "Ошибка.");
			
		КонецЕсли;
		
		Если ВзвестиФлагОшибок ИЛИ БезусловнаяЗаписьВПротоколОбмена ИЛИ ВыводВПротоколИнформационныхСообщений Тогда
			
			мФайлПротоколаДанных.ЗаписатьСтроку(ИтоговаяСтрокаДляЗаписи);
		
		КонецЕсли;		
		
	КонецЕсли;
	
	Возврат Стр;
		
КонецФункции

// Процедура установки значения глобальной переменной "ФлагОшибки"
//
// Параметры:
//  Значение - Булево, новое значение переменной "ФлагОшибки"
//  
Процедура УстановитьФлагОшибки(Значение)
	
	ФлагОшибки = Значение;
	
	//Если ФлагОшибки Тогда
	//	
	//	ДеструкторВнешнейОбработкиОбработчиковСобытий(ФлагРежимОтладки);
	//	
	//КонецЕсли;
	
КонецПроцедуры

// Выводит сообщение пользователю
//
// Параметры:
//	ТекстСообщенияПользователю - Строка - Текст выводимого сообщения
//
Процедура СообщитьПользователю(ТекстСообщенияПользователю) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Сообщить();
	
КонецПроцедуры

// Выполняет инициализацию файла для записи событий загрузки/выгрузки данных
//
// Параметры:
//  Нет.
// 
Процедура ИнициализироватьВедениеПротоколаОбмена() Экспорт
	
	Если ПустаяСтрока(ИмяФайлаПротоколаОбмена) Тогда
		
		мФайлПротоколаДанных = Неопределено;
		ФлагКомментироватьОбработкуОбъектов = ВыводВОкноСообщенийИнформационныхСообщений;		
		Возврат;
		
	Иначе	
		
		ФлагКомментироватьОбработкуОбъектов = ВыводВПротоколИнформационныхСообщений ИЛИ ВыводВОкноСообщенийИнформационныхСообщений;		
		
	КонецЕсли;
	
	мФайлПротоколаДанных = Новый ЗаписьТекста(ИмяФайлаПротоколаОбмена, КодировкаТекста.ANSI, , ДописыватьДанныеВПротоколОбмена) ;
	
КонецПроцедуры

// Дополняет строку указанным символом до указанной длины.
//
// Параметры: 
//  Стр          - дополняемая строка;
//  Длина        - требуемая длина результирующей строки;
//  Чем          - символ, которым дополняется строка.
//
// Возвращаемое значение:
//  Строка, дополненная указанным символом до указанной длины.
//
Функция одДополнитьСтроку(Стр, Длина, Чем = " ") Экспорт

	Результат = СокрЛП(Стр);
	Пока Длина - СтрДлина(Результат) > 0 Цикл
		Результат = Результат + Чем;
	КонецЦикла;

	Возврат(Результат);

КонецФункции // одДополнитьСтроку()

// Закрывает файл протокола обмена данными. Файл сохраняется на диск
//
Процедура ЗавершитьВедениеПротоколаОбмена() Экспорт 
	
	Если мФайлПротоколаДанных <> Неопределено Тогда
		
		мФайлПротоколаДанных.Закрыть();
				
	КонецЕсли;	
	
	мФайлПротоколаДанных = Неопределено;
	
КонецПроцедуры

Функция ЗаписатьИнформациюОбОшибкеОбработчикиКонвертации(КодСообщения, СтрокаОшибки, ИмяОбработчика)
	
	ЗП                        = ПолучитьСтруктуруЗаписиПротокола(КодСообщения, СтрокаОшибки);
	ЗП.Обработчик             = ИмяОбработчика;
	СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(КодСообщения, ЗП);
	Возврат СтрокаСообщенияОбОшибке;
	
КонецФункции

// Возвращает объект типа структура, содержащий все возможные поля
// записи протокола выполнения (сообщения об ошибках и т.п.)
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Объект типа структура
// 
Функция ПолучитьСтруктуруЗаписиПротокола(КодСообщения = "", СтрокаОшибки = "") Экспорт

	СтруктураОшибки = Новый Структура("ИмяПКО,ИмяПОД,Нпп,Гнпп,Источник,ТипОбъекта,Свойство,Значение,ТипЗначения,ПКО,ПКС,ПКГС,ПВД,ПОД,Объект,СвойствоПриемника,КонвертируемоеЗначение,Обработчик,ОписаниеОшибки,ПозицияМодуля,Текст,КодСообщения,УзелПланаОбмена");
	
	СтрокаМодуля              = ОтделитьРазделителем(СтрокаОшибки, "{");
	ОписаниеОшибки            = ОтделитьРазделителем(СтрокаМодуля, "}: ");
	
	Если ОписаниеОшибки <> "" Тогда
		
		СтруктураОшибки.ОписаниеОшибки         = ОписаниеОшибки;
		СтруктураОшибки.ПозицияМодуля          = СтрокаМодуля;
				
	КонецЕсли;
	
	Если СтруктураОшибки.КодСообщения <> "" Тогда
		
		СтруктураОшибки.КодСообщения           = КодСообщения;
		
	КонецЕсли;
	
	Возврат СтруктураОшибки;
	
КонецФункции

// Разбирает строку на две части: до подстроки разделителя и после.
//
// Параметры:
//  Стр          - разбираемая строка;
//  Разделитель  - подстрока-разделитель:
//  Режим        - 0 - разделитель в возвращаемые подстроки не включается;
//                 1 - разделитель включается в левую подстроку;
//                 2 - разделитель включается в правую подстроку.
//
// Возвращаемое значение:
//  Правая часть строки - до символа-разделителя.
// 
Функция ОтделитьРазделителем(Стр, Знач Разделитель, Режим=0) Экспорт

	ПраваяЧасть         = "";
	ПозРазделителя      = Найти(Стр, Разделитель);
	ДлинаРазделителя    = СтрДлина(Разделитель);
	Если ПозРазделителя > 0 Тогда
		ПраваяЧасть	 = Сред(Стр, ПозРазделителя + ?(Режим=2, 0, ДлинаРазделителя));
		Стр          = СокрЛП(Лев(Стр, ПозРазделителя - ?(Режим=1, -ДлинаРазделителя + 1, 1)));
	КонецЕсли;

	Возврат(ПраваяЧасть);

КонецФункции // ОтделитьРазделителем()

Процедура КомментарииКЗагрузкеОбъекта(Нпп, ИмяПравила, Источник, ТипОбъекта, ГНпп = 0)
	
	Если ФлагКомментироватьОбработкуОбъектов Тогда
		
		Если Нпп <> 0 Тогда
			СтрокаСообщения = СтрШаблон(НСтр("ru = 'Загрузка объекта № %1'"), Нпп);
		Иначе
			СтрокаСообщения = СтрШаблон(НСтр("ru = 'Загрузка объекта № %1'"), ГНпп);
		КонецЕсли;
		
		ЗП = ПолучитьСтруктуруЗаписиПротокола();
		
		Если Не ПустаяСтрока(ИмяПравила) Тогда
			
			ЗП.ИмяПКО = ИмяПравила;
			
		КонецЕсли;
		
		Если Не ПустаяСтрока(Источник) Тогда
			
			ЗП.Источник = Источник;
			
		КонецЕсли;
		
		ЗП.ТипОбъекта = ТипОбъекта;
		ЗаписатьВПротоколВыполнения(СтрокаСообщения, ЗП, Ложь);
		
	КонецЕсли;	
	
КонецПроцедуры

// Регистрирует в протоколе выполнения ошибку обработчика ПКО (загрузка)
//
Функция ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(КодСообщения, СтрокаОшибки, ИмяПравила, Источник = "", 
	ТипОбъекта, Объект = Неопределено, ИмяОбработчика) Экспорт
	
	ЗП                        = ПолучитьСтруктуруЗаписиПротокола(КодСообщения, СтрокаОшибки);
	ЗП.ИмяПКО                 = ИмяПравила;
	ЗП.ТипОбъекта             = ТипОбъекта;
	ЗП.Обработчик             = ИмяОбработчика;
						
	Если Не ПустаяСтрока(Источник) Тогда
							
		ЗП.Источник           = Источник;
							
	КонецЕсли;
						
	Если Объект <> Неопределено Тогда
	
		ЗП.Объект                 = Строка(Объект);
		
	КонецЕсли;
	
	СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(КодСообщения, ЗП);
	
	Если Не ФлагРежимОтладки Тогда
		ВызватьИсключение СтрокаСообщенияОбОшибке;
	КонецЕсли;
		
КонецФункции

// Регистрирует в протоколе выполнения ошибку обработчика ПКС
//
Функция ЗаписатьИнформациюОбОшибкеОбработчикиПКС(КодСообщения, СтрокаОшибки, ПКО, ПКС, Источник = "", 
	ИмяОбработчика = "", Значение = Неопределено, ЭтоПКС = Истина) Экспорт
	
	ЗП                        = ПолучитьСтруктуруЗаписиПротокола(КодСообщения, СтрокаОшибки);
	ЗП.ПКО                    = ПКО.Имя + "  (" + ПКО.Наименование + ")";
	
	ИмяПравила = ПКС.Имя + "  (" + ПКС.Наименование + ")";
	Если ЭтоПКС Тогда
		ЗП.ПКС                = ИмяПравила;
	Иначе
		ЗП.ПКГС               = ИмяПравила;
	КонецЕсли;
	
	Попытка
		ЗП.Объект                 = Строка(Источник) + "  (" + ТипЗнч(Источник) + ")";
	Исключение
		ЗП.Объект                 = "(" + ТипЗнч(Источник) + ")";
	КонецПопытки;
	
	Если ЭтоПКС Тогда
		ЗП.СвойствоПриемника      = ПКС.Приемник + "  (" + ПКС.ТипПриемника + ")";
	КонецЕсли;
	
	Если ИмяОбработчика <> "" Тогда
		ЗП.Обработчик         = ИмяОбработчика;
	КонецЕсли;
	
	Если Значение <> Неопределено Тогда
		ЗП.КонвертируемоеЗначение = Строка(Значение) + "  (" + ТипЗнч(Значение) + ")";
	КонецЕсли;
	
	СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(КодСообщения, ЗП);
	
	Если Не ФлагРежимОтладки Тогда
		ВызватьИсключение СтрокаСообщенияОбОшибке;
	КонецЕсли;
		
КонецФункции	

// Записывает информацию об ошибке в протокол выполнения обмена.
//
Функция ЗаписатьИнформациюОбОшибкеВПротокол(КодСообщения, СтрокаОшибки, Объект, ТипОбъекта = Неопределено) Экспорт
	
	ЗП         = ПолучитьСтруктуруЗаписиПротокола(КодСообщения, СтрокаОшибки);
	ЗП.Объект  = Объект;
	
	Если ТипОбъекта <> Неопределено Тогда
		ЗП.ТипОбъекта     = ТипОбъекта;
	КонецЕсли;	
		
	СтрокаОшибки = ЗаписатьВПротоколВыполнения(КодСообщения, ЗП);	
	
	Возврат СтрокаОшибки;	
	
КонецФункции

#КонецОбласти

#Область ИнициализацияТаблицПравилОбмена

// Инициализирует колонки таблицы правил конвертации объектов.
//
// Параметры:
//  Нет.
// 
Процедура ИнициализацияТаблицыПравилКонвертации()

	Колонки = ТаблицаПравилКонвертации.Колонки;
	
	ДобавитьНедостающиеКолонки(Колонки, "Имя");
	ДобавитьНедостающиеКолонки(Колонки, "Наименование");
	ДобавитьНедостающиеКолонки(Колонки, "Порядок");

	ДобавитьНедостающиеКолонки(Колонки, "СинхронизироватьПоИдентификатору");
	ДобавитьНедостающиеКолонки(Колонки, "НеСоздаватьЕслиНеНайден", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "НеВыгружатьОбъектыСвойствПоСсылкам", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ПродолжитьПоискПоПолямПоискаЕслиПоИдентификаторуНеНашли", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ИспользоватьБыстрыйПоискПриЗагрузке", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ГенерироватьНовыйНомерИлиКодЕслиНеУказан", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "МаленькоеКоличествоОбъектов", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "КоличествоОбращенийДляВыгрузкиСсылки", одОписаниеТипа("Число"));
	ДобавитьНедостающиеКолонки(Колонки, "КоличествоЭлементовВИБ", одОписаниеТипа("Число"));
	
	ДобавитьНедостающиеКолонки(Колонки, "СпособВыгрузки");

	ДобавитьНедостающиеКолонки(Колонки, "Источник");
	ДобавитьНедостающиеКолонки(Колонки, "Приемник");
	
	ДобавитьНедостающиеКолонки(Колонки, "ТипИсточника",  одОписаниеТипа("Строка"));

	ДобавитьНедостающиеКолонки(Колонки, "ПередВыгрузкой");
	ДобавитьНедостающиеКолонки(Колонки, "ПриВыгрузке");
	ДобавитьНедостающиеКолонки(Колонки, "ПослеВыгрузки");
	ДобавитьНедостающиеКолонки(Колонки, "ПослеВыгрузкиВФайл");
	
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПередВыгрузкой",	    одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПриВыгрузке",		одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПослеВыгрузки",		одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПослеВыгрузкиВФайл",	одОписаниеТипа("Булево"));

	ДобавитьНедостающиеКолонки(Колонки, "ПередЗагрузкой");
	ДобавитьНедостающиеКолонки(Колонки, "ПриЗагрузке");
	ДобавитьНедостающиеКолонки(Колонки, "ПослеЗагрузки");
	
	ДобавитьНедостающиеКолонки(Колонки, "ПоследовательностьПолейПоиска");
	ДобавитьНедостающиеКолонки(Колонки, "ПоискПоТабличнымЧастям");
	
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПередЗагрузкой", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПриЗагрузке",    одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПослеЗагрузки",  одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПоследовательностьПолейПоиска",  одОписаниеТипа("Булево"));

	ДобавитьНедостающиеКолонки(Колонки, "СвойстваПоиска",	одОписаниеТипа("ТаблицаЗначений"));
	ДобавитьНедостающиеКолонки(Колонки, "Свойства",		одОписаниеТипа("ТаблицаЗначений"));
	
	ДобавитьНедостающиеКолонки(Колонки, "Значения",		одОписаниеТипа("Соответствие"));

	ДобавитьНедостающиеКолонки(Колонки, "Выгруженные",							одОписаниеТипа("Соответствие"));
	ДобавитьНедостающиеКолонки(Колонки, "ВыгруженныеТолькоСсылки",				одОписаниеТипа("Соответствие"));
	ДобавитьНедостающиеКолонки(Колонки, "ВыгружатьПредставлениеИсточника",		одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "НеЗамещать",					одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "ЗапоминатьВыгруженные",       одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ВсеОбъектыВыгружены",         одОписаниеТипа("Булево"));
	
КонецПроцедуры

// Инициализирует колонки таблицы правил конвертации свойств объектов.
//
// Параметры:
//  Таб            - ТаблицаЗначений - инициализируемая таблица правил конвертации свойств.
// 
Процедура ИнициализацияТаблицыПравилКонвертацииСвойств(Таб) Экспорт // Убрать лишние колонки

	Колонки = Таб.Колонки;
	
	ДобавитьНедостающиеКолонки(Колонки, "Имя");
	ДобавитьНедостающиеКолонки(Колонки, "Наименование");
	ДобавитьНедостающиеКолонки(Колонки, "Порядок");
	
	ДобавитьНедостающиеКолонки(Колонки, "ЭтоГруппа", 			одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ПравилаГруппы");
	
	ДобавитьНедостающиеКолонки(Колонки, "ВидИсточника");
	ДобавитьНедостающиеКолонки(Колонки, "ВидПриемника");
	
	ДобавитьНедостающиеКолонки(Колонки, "УпрощеннаяВыгрузкаСвойства", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "УпрощеннаяЗагрузкаСвойства", одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "НуженУзелXMLПриВыгрузке", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "НуженУзелXMLПриВыгрузкеГруппы", одОписаниеТипа("Булево"));

	ДобавитьНедостающиеКолонки(Колонки, "ТипИсточника", одОписаниеТипа("Строка"));
	ДобавитьНедостающиеКолонки(Колонки, "ТипПриемника", одОписаниеТипа("Строка"));
	
	ДобавитьНедостающиеКолонки(Колонки, "Источник");
	ДобавитьНедостающиеКолонки(Колонки, "Приемник");

	ДобавитьНедостающиеКолонки(Колонки, "ПравилоКонвертации");

	ДобавитьНедостающиеКолонки(Колонки, "ПолучитьИзВходящихДанных", одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "НеЗамещать", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "Отключить", одОписаниеТипа("Булево"));	
	
	ДобавитьНедостающиеКолонки(Колонки, "ПередВыгрузкой");
	ДобавитьНедостающиеКолонки(Колонки, "ПриВыгрузке");
	ДобавитьНедостающиеКолонки(Колонки, "ПослеВыгрузки");
	
	ДобавитьНедостающиеКолонки(Колонки, "ПередЗагрузкой");
	ДобавитьНедостающиеКолонки(Колонки, "ПриЗагрузке");
	ДобавитьНедостающиеКолонки(Колонки, "ПослеЗагрузки");

	ДобавитьНедостающиеКолонки(Колонки, "ПередОбработкойВыгрузки");
	ДобавитьНедостающиеКолонки(Колонки, "ПослеОбработкиВыгрузки");

	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПередВыгрузкой",			одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПриВыгрузке",				одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПослеВыгрузки",				одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПередЗагрузкой", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПриЗагрузке", одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПослеЗагрузки", одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПередОбработкойВыгрузки",	одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ЕстьОбработчикПослеОбработкиВыгрузки",	одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "ПриводитьКДлине",	одОписаниеТипа("Число"));
	ДобавитьНедостающиеКолонки(Колонки, "ИмяПараметраДляПередачи");
	ДобавитьНедостающиеКолонки(Колонки, "ПоискПоДатеНаРавенство",					одОписаниеТипа("Булево"));
	ДобавитьНедостающиеКолонки(Колонки, "ВыгружатьГруппуЧерезФайл",					одОписаниеТипа("Булево"));
	
	ДобавитьНедостающиеКолонки(Колонки, "СтрокаПолейПоиска");
	
КонецПроцедуры

// Инициализирует колонки таблицы настройки параметров.
//
// Параметры:
//  Нет.
// 
Процедура ИнициализацияТаблицыНастройкиПараметров()

	Колонки = ТаблицаНастройкиПараметров.Колонки;

	ДобавитьНедостающиеКолонки(Колонки, "Имя");
	ДобавитьНедостающиеКолонки(Колонки, "Наименование");
	ДобавитьНедостающиеКолонки(Колонки, "Значение");
	ДобавитьНедостающиеКолонки(Колонки, "ПередаватьПараметрПриВыгрузке");
	ДобавитьНедостающиеКолонки(Колонки, "ПравилоКонвертации");

КонецПроцедуры

// Добавляет колонки в таблицы ПКО, параметров и т.д.
//
// Параметры:
//  Нет.
//
Процедура ДобавитьНедостающиеКолонки(Колонки, Имя, Типы = Неопределено)
	
	Если Колонки.Найти(Имя) <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Колонки.Добавить(Имя, Типы);
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыЗагрузкиПравилОбмена

// Осуществляет загрузку правил конвертации объектов.
//
// Параметры:
//  Нет.
//
Процедура ЗагрузитьПравилаКонвертации()

	ТаблицаПравилКонвертации.Очистить();
	ОчиститьПКОМенеджеров();
	
	ВыборкаПКО = ПолучитьВыборкуПравилКонвертации();
	Если ВыборкаПКО = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Пока ВыборкаПКО.Следующий() Цикл
		ЗагрузитьПравилоКонвертации(ВыборкаПКО);
	КонецЦикла;
	
	ТаблицаПравилКонвертации.Индексы.Добавить("Приемник");
	
КонецПроцедуры

// Возвращает выборку правил конвертации объектов по учетной записи обмена данными.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   ВыборкаИзРезультатаЗапроса, Неопределено - выборка ПКО
//
Функция ПолучитьВыборкуПравилКонвертации() Экспорт
	
	ВыборкаПКО = Неопределено;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПравилаКонвертацииОбъектов.Ссылка КАК Ссылка,
	|	ПравилаКонвертацииОбъектов.Родитель КАК Родитель,
	|	ПравилаКонвертацииОбъектов.ЭтоГруппа КАК ЭтоГруппа,
	|	ПравилаКонвертацииОбъектов.Код КАК Код,
	|	ПравилаКонвертацииОбъектов.Наименование КАК Наименование,
	|	ПравилаКонвертацииОбъектов.АлгоритмПередВыгрузкойОбъекта КАК АлгоритмПередВыгрузкойОбъекта,
	|	ПравилаКонвертацииОбъектов.АлгоритмПередЗагрузкойОбъекта КАК АлгоритмПередЗагрузкойОбъекта,
	|	ПравилаКонвертацииОбъектов.АлгоритмПослеВыгрузкиОбъекта КАК АлгоритмПослеВыгрузкиОбъекта,
	|	ПравилаКонвертацииОбъектов.АлгоритмПослеВыгрузкиОбъектаВФайлОбмена КАК АлгоритмПослеВыгрузкиОбъектаВФайлОбмена,
	|	ПравилаКонвертацииОбъектов.АлгоритмПоследовательностьПолейПоиска КАК АлгоритмПоследовательностьПолейПоиска,
	|	ПравилаКонвертацииОбъектов.АлгоритмПослеЗагрузкиОбъекта КАК АлгоритмПослеЗагрузкиОбъекта,
	|	ПравилаКонвертацииОбъектов.АлгоритмПриВыгрузкеОбъекта КАК АлгоритмПриВыгрузкеОбъекта,
	|	ПравилаКонвертацииОбъектов.АлгоритмПриЗагрузкеОбъекта КАК АлгоритмПриЗагрузкеОбъекта,
	|	ПравилаКонвертацииОбъектов.ВыгружатьОбъектТолькоПриНаличииНаНегоСсылки КАК ВыгружатьОбъектТолькоПриНаличииНаНегоСсылки,
	|	ПравилаКонвертацииОбъектов.ГенерироватьНовыйНомерИлиКодЕслиНеУказан КАК ГенерироватьНовыйНомерИлиКодЕслиНеУказан,
	|	ПравилаКонвертацииОбъектов.ИспользоватьБыстрыйПоискПриЗагрузке КАК ИспользоватьБыстрыйПоискПриЗагрузке,
	|	ПравилаКонвертацииОбъектов.Источник КАК Источник,
	|	ПравилаКонвертацииОбъектов.НеВыгружатьОбъектыСвойствПоСсылкам КАК НеВыгружатьОбъектыСвойствПоСсылкам,
	|	ПравилаКонвертацииОбъектов.НеЗамещать КАК НеЗамещать,
	|	ПравилаКонвертацииОбъектов.НеЗамещатьОбъектСозданныйВИнформационнойБазеПриемнике КАК НеЗамещатьОбъектСозданныйВИнформационнойБазеПриемнике,
	|	ПравилаКонвертацииОбъектов.НеЗапоминатьВыгруженные КАК НеЗапоминатьВыгруженные,
	|	ПравилаКонвертацииОбъектов.НеСоздаватьОбъектВПриемникеЕслиНеНайденПоПолямПоиска КАК НеСоздаватьОбъектВПриемникеЕслиНеНайденПоПолямПоиска,
	|	ПравилаКонвертацииОбъектов.Описание КАК Описание,
	|	ПравилаКонвертацииОбъектов.Порядок КАК Порядок,
	|	ПравилаКонвертацииОбъектов.Приемник КАК Приемник,
	|	ПравилаКонвертацииОбъектов.ПриоритетОбъектовОбмена КАК ПриоритетОбъектовОбмена,
	|	ПравилаКонвертацииОбъектов.ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD КАК ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD,
	|	ПравилаКонвертацииОбъектов.ПродолжитьПоискПоПолямПоискаЕслиПоИдентификаторуНеНашли КАК ПродолжитьПоискПоПолямПоискаЕслиПоИдентификаторуНеНашли,
	|	ПравилаКонвертацииОбъектов.СинхронизироватьПоИдентификатору КАК СинхронизироватьПоИдентификатору,
	|	ПравилаКонвертацииОбъектов.ТипИсточника КАК ТипИсточника,
	|	ПравилаКонвертацииОбъектов.ТипПриемника КАК ТипПриемника,
	|	ПравилаКонвертацииОбъектов.НастройкаВариантовПоискаОбъектов.(
	|		Ссылка КАК Ссылка,
	|		НомерСтроки КАК НомерСтроки,
	|		ИмяНастройкиДляАлгоритма КАК ИмяНастройкиДляАлгоритма,
	|		ИмяНастройкиДляПользователя КАК ИмяНастройкиДляПользователя,
	|		ОписаниеНастройкиДляПользователя КАК ОписаниеНастройкиДляПользователя
	|	) КАК НастройкаВариантовПоискаОбъектов,
	|	ПравилаКонвертацииОбъектов.Предопределенный КАК Предопределенный,
	|	ПравилаКонвертацииОбъектов.ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных
	|ИЗ
	|	Справочник.ПравилаКонвертацииОбъектов КАК ПравилаКонвертацииОбъектов
	|ГДЕ
	|	ПравилаКонвертацииОбъектов.ПометкаУдаления = ЛОЖЬ
	|	И ПравилаКонвертацииОбъектов.Владелец = &УчетнаяЗаписьОбмена
	|	И ПравилаКонвертацииОбъектов.ЭтоГруппа = ЛОЖЬ";
	
	Запрос.УстановитьПараметр("УчетнаяЗаписьОбмена", мУчетнаяЗаписьОбмена);
	РезультатЗапроса = Запрос.Выполнить();
	Если Не РезультатЗапроса.Пустой() Тогда
		ВыборкаПКО = РезультатЗапроса.Выбрать();
	КонецЕсли;
	
	Возврат ВыборкаПКО;
	
КонецФункции // ПолучитьВыборкуПравилКонвертации

// Процедура очистки ПКо у менеджеров для правил обмена.
Процедура ОчиститьПКОМенеджеров() // Возможно вообще не нужно... Оставлено для совместимости пока что...
	
	Если Менеджеры = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого МенеджерПравила Из Менеджеры Цикл
		МенеджерПравила.Значение.ПКО = Неопределено;
	КонецЦикла;
	
КонецПроцедуры

// Осуществляет загрузку правила конвертации объектов.
//
// Параметры:
//  ВыборкаПКО - ВыборкаИзРезультатаЗапроса - элемент выборки результата запроса, содержит свойства конктретного ПКО
//
Процедура ЗагрузитьПравилоКонвертации(ВыборкаПКО)

	НоваяСтрока = КоллекцияПравилаКонвертации().Добавить();
	
	// Значения по умолчанию
	НоваяСтрока.ЗапоминатьВыгруженные = Истина;
	НоваяСтрока.НеЗамещать            = Ложь;
	//НоваяСтрока.ПриоритетОбъектовОбмена = Перечисления.ПриоритетыОбъектовОбмена.ПриоритетОбъектаОбменаВыше; // Проанализировать нужно ли вообще
	
	ТаблицаПоискПоТЧ = КоллекцияПоискПоТабличнымЧастям();
	НоваяСтрока.ПоискПоТабличнымЧастям = ТаблицаПоискПоТЧ;
	
	НоваяСтрока.Имя = СокрЛП(ВыборкаПКО.Код);
	НоваяСтрока.Наименование = СокрЛП(ВыборкаПКО.Наименование);
	НоваяСтрока.СинхронизироватьПоИдентификатору = ВыборкаПКО.СинхронизироватьПоИдентификатору;
	НоваяСтрока.НеСоздаватьЕслиНеНайден = ВыборкаПКО.НеСоздаватьОбъектВПриемникеЕслиНеНайденПоПолямПоиска;
	НоваяСтрока.НеВыгружатьОбъектыСвойствПоСсылкам = ВыборкаПКО.НеВыгружатьОбъектыСвойствПоСсылкам;
	НоваяСтрока.ПродолжитьПоискПоПолямПоискаЕслиПоИдентификаторуНеНашли = ВыборкаПКО.ПродолжитьПоискПоПолямПоискаЕслиПоИдентификаторуНеНашли;
	НоваяСтрока.ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD = ВыборкаПКО.ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD;
	//НоваяСтрока.НеЗамещатьОбъектСозданныйВИнформационнойБазеПриемнике = ВыборкаПКО.НеЗамещатьОбъектСозданныйВИнформационнойБазеПриемнике; // Подумать - нужно ли
	НоваяСтрока.ИспользоватьБыстрыйПоискПриЗагрузке = ВыборкаПКО.ИспользоватьБыстрыйПоискПриЗагрузке;
	НоваяСтрока.ГенерироватьНовыйНомерИлиКодЕслиНеУказан = ВыборкаПКО.ГенерироватьНовыйНомерИлиКодЕслиНеУказан;
	НоваяСтрока.ЗапоминатьВыгруженные = НЕ ВыборкаПКО.НеЗапоминатьВыгруженные;
	НоваяСтрока.НеЗамещать = ВыборкаПКО.НеЗамещать;
	НоваяСтрока.Приемник = ВыборкаПКО.Приемник;
	НоваяСтрока.Источник = СокрЛП(ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ВыборкаПКО.Источник, "Наименование"));
	
	// Свойства
	НоваяСтрока.СвойстваПоиска = мТаблицаПравилКонвертацииСвойств.Скопировать();
	НоваяСтрока.Свойства = мТаблицаПравилКонвертацииСвойств.Скопировать();
	Если НоваяСтрока.СинхронизироватьПоИдентификатору <> Неопределено И НоваяСтрока.СинхронизироватьПоИдентификатору Тогда
		
		СвойствоПоискаУИ = НоваяСтрока.СвойстваПоиска.Добавить();
		СвойствоПоискаУИ.Имя = "{УникальныйИдентификатор}";
		СвойствоПоискаУИ.Источник = "{УникальныйИдентификатор}";
		СвойствоПоискаУИ.Приемник = "{УникальныйИдентификатор}";
		
	КонецЕсли;
	
	// ПКС
	ЗагрузитьСвойства(ВыборкаПКО.Ссылка, НоваяСтрока.Свойства, НоваяСтрока.СвойстваПоиска);
	
	// ПКЗ
	ЗагрузитьЗначения(ВыборкаПКО.Ссылка, НоваяСтрока.Значения, Тип(НоваяСтрока.Приемник));
	
	// Обработчики событий выгрузки
	НоваяСтрока.ПередВыгрузкой = ВыборкаПКО.АлгоритмПередВыгрузкойОбъекта;
	НоваяСтрока.ЕстьОбработчикПередВыгрузкой = Не ПустаяСтрока(НоваяСтрока.ПередВыгрузкой);
	
	НоваяСтрока.ПриВыгрузке = ВыборкаПКО.АлгоритмПриВыгрузкеОбъекта;
	НоваяСтрока.ЕстьОбработчикПриВыгрузке = Не ПустаяСтрока(НоваяСтрока.ПриВыгрузке);
	
	НоваяСтрока.ПослеВыгрузки = ВыборкаПКО.АлгоритмПослеВыгрузкиОбъекта;
	НоваяСтрока.ЕстьОбработчикПослеВыгрузки = Не ПустаяСтрока(НоваяСтрока.ПослеВыгрузки);
	
	НоваяСтрока.ПослеВыгрузкиВФайл = ВыборкаПКО.АлгоритмПослеВыгрузкиОбъектаВФайлОбмена;
	НоваяСтрока.ЕстьОбработчикПослеВыгрузкиВФайл  = Не ПустаяСтрока(НоваяСтрока.ПослеВыгрузкиВФайл);
	
	// Обработчики событий загрузки
	НоваяСтрока.ПередЗагрузкой = ВыборкаПКО.АлгоритмПередЗагрузкойОбъекта;
	НоваяСтрока.ЕстьОбработчикПередЗагрузкой = Не ПустаяСтрока(НоваяСтрока.ПередЗагрузкой);
	
	НоваяСтрока.ПриЗагрузке = ВыборкаПКО.АлгоритмПриЗагрузкеОбъекта;
	НоваяСтрока.ЕстьОбработчикПриЗагрузке = Не ПустаяСтрока(НоваяСтрока.ПриЗагрузке);
	
	НоваяСтрока.ПослеЗагрузки = ВыборкаПКО.АлгоритмПослеЗагрузкиОбъекта;
	НоваяСтрока.ЕстьОбработчикПослеЗагрузки = Не ПустаяСтрока(НоваяСтрока.ПослеЗагрузки);
	
	НоваяСтрока.ПоследовательностьПолейПоиска = ВыборкаПКО.АлгоритмПоследовательностьПолейПоиска;
	НоваяСтрока.ЕстьОбработчикПоследовательностьПолейПоиска = Не ПустаяСтрока(НоваяСтрока.ПоследовательностьПолейПоиска);
	
	// Проверить используется ли...
	//ИначеЕсли ИмяУзла = "ПоискПоТабличнымЧастям" Тогда
	//		
	//		Значение = одЗначениеЭлемента(ПравилаОбмена, одТипСтрока);
	//		
	//		Для Номер = 1 По СтрЧислоСтрок(Значение) Цикл
	//			
	//			ТекущаяСтрока = СтрПолучитьСтроку(Значение, Номер);
	//			
	//			СтрокаПоиска = ОтделитьРазделителем(ТекущаяСтрока, ":");
	//			
	//			СтрокаТаблицы = ТаблицаПоискПоТЧ.Добавить();
	//			СтрокаТаблицы.ИмяЭлемента = ТекущаяСтрока;
	//			
	//			СтрокаТаблицы.ПоляПоискаТЧ = РазложитьСтрокуВМассивПодстрок(СтрокаПоиска);
	//			
	//		КонецЦикла;
	
	ИтоговаяСтрокаПоискаПоТЧ = "";
	
	// В приемник нужно передать информацию о полях поиска для табличных частей.
	Для Каждого СтрокаСвойств Из НоваяСтрока.Свойства Цикл
		
		Если Не СтрокаСвойств.ЭтоГруппа
			ИЛИ ПустаяСтрока(СтрокаСвойств.ВидИсточника)
			ИЛИ ПустаяСтрока(СтрокаСвойств.Приемник) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		Если ПустаяСтрока(СтрокаСвойств.СтрокаПолейПоиска) Тогда
			Продолжить;
		КонецЕсли;
		
		ИтоговаяСтрокаПоискаПоТЧ = ИтоговаяСтрокаПоискаПоТЧ + Символы.ПС + СтрокаСвойств.ВидИсточника + "." + СтрокаСвойств.Приемник + ":" + СтрокаСвойств.СтрокаПолейПоиска;
		
	КонецЦикла;
	
	ИтоговаяСтрокаПоискаПоТЧ = СокрЛП(ИтоговаяСтрокаПоискаПоТЧ);
	
	// Быстрый доступ к ПКО по имени.
	Правила.Вставить(НоваяСтрока.Имя, НоваяСтрока);
	
КонецПроцедуры

// Осуществляет загрузку правил конвертации свойств.
//
// Параметры:
//  пкоСсылка  - СправочникСсылка.ПравилаКонвертацииОбъектов - ссылка на ПКО для получения ПКС, ПКГС.
//  ТаблицаСвойств - ТаблицаЗначений - таблица значений, содержащая ПКС.
//  ТаблицаПоиска  - ТаблицаЗначений - таблица значений, содержащая ПКС (синхронизирующих).
//
Процедура ЗагрузитьСвойства(пкоСсылка, ТаблицаСвойств, ТаблицаПоиска)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПравилаКонвертацииСвойств.Ссылка КАК Ссылка,
	|	ПравилаКонвертацииСвойств.ВерсияДанных КАК ВерсияДанных,
	|	ПравилаКонвертацииСвойств.ПометкаУдаления КАК ПометкаУдаления,
	|	ПравилаКонвертацииСвойств.Владелец КАК Владелец,
	|	ПравилаКонвертацииСвойств.Родитель КАК Родитель,
	|	ПравилаКонвертацииСвойств.ЭтоГруппа КАК ЭтоГруппа,
	|	ПравилаКонвертацииСвойств.Код КАК Код,
	|	ПравилаКонвертацииСвойств.Наименование КАК Наименование,
	|	ПравилаКонвертацииСвойств.АвтоматическиПриводитьЗначениеКДлинеПриемника КАК АвтоматическиПриводитьЗначениеКДлинеПриемника,
	|	ПравилаКонвертацииСвойств.АлгоритмПередВыгрузкойСвойства КАК АлгоритмПередВыгрузкойСвойства,
	|	ПравилаКонвертацииСвойств.АлгоритмПередОбработкойВыгрузки КАК АлгоритмПередОбработкойВыгрузки,
	|	ПравилаКонвертацииСвойств.АлгоритмПослеВыгрузкиСвойства КАК АлгоритмПослеВыгрузкиСвойства,
	|	ПравилаКонвертацииСвойств.АлгоритмПослеОбработкиВыгрузки КАК АлгоритмПослеОбработкиВыгрузки,
	|	ПравилаКонвертацииСвойств.АлгоритмПриВыгрузкеСвойства КАК АлгоритмПриВыгрузкеСвойства,
	|	ПравилаКонвертацииСвойств.ВидИсточника КАК ВидИсточника,
	|	ПравилаКонвертацииСвойств.ВидПриемника КАК ВидПриемника,
	|	ПравилаКонвертацииСвойств.ВыгружатьГруппуЧерезФайл КАК ВыгружатьГруппуЧерезФайл,
	|	ПравилаКонвертацииСвойств.ИмяИсточника КАК ИмяИсточника,
	|	ПравилаКонвертацииСвойств.ИмяПараметраДляПередачи КАК ИмяПараметраДляПередачи,
	|	ПравилаКонвертацииСвойств.ИмяПравилаКонвертации КАК ИмяПравилаКонвертации,
	|	ПравилаКонвертацииСвойств.ИмяПриемника КАК ИмяПриемника,
	|	ПравилаКонвертацииСвойств.Источник КАК Источник,
	|	ПравилаКонвертацииСвойств.Комментарий КАК Комментарий,
	|	ПравилаКонвертацииСвойств.НеЗамещать КАК НеЗамещать,
	|	ПравилаКонвертацииСвойств.Описание КАК Описание,
	|	ПравилаКонвертацииСвойств.Отключить КАК Отключить,
	|	ПравилаКонвертацииСвойств.Поиск КАК Поиск,
	|	ПравилаКонвертацииСвойств.ПоискПоДатеНаРавенство КАК ПоискПоДатеНаРавенство,
	|	ПравилаКонвертацииСвойств.ПолучитьИзВходящихДанных КАК ПолучитьИзВходящихДанных,
	|	ПравилаКонвертацииСвойств.Порядок КАК Порядок,
	|	ПравилаКонвертацииСвойств.ПравилоКонвертации КАК ПравилоКонвертации,
	|	ПравилаКонвертацииСвойств.Приемник КАК Приемник,
	|	ПравилаКонвертацииСвойств.ТипИсточника КАК ТипИсточника,
	|	ПравилаКонвертацииСвойств.ТипПриемника КАК ТипПриемника,
	|	ПравилаКонвертацииСвойств.Предопределенный КАК Предопределенный,
	|	ПравилаКонвертацииСвойств.ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных,
	|	ПравилаКонвертацииСвойств.Представление КАК Представление,
	|	ПравилаКонвертацииСвойств.АлгоритмПередЗагрузкойСвойства КАК АлгоритмПередЗагрузкойСвойства,
	|	ПравилаКонвертацииСвойств.АлгоритмПриЗагрузкеСвойства КАК АлгоритмПриЗагрузкеСвойства,
	|	ПравилаКонвертацииСвойств.АлгоритмПослеЗагрузкиСвойства КАК АлгоритмПослеЗагрузкиСвойства
	|ИЗ
	|	Справочник.ПравилаКонвертацииСвойств КАК ПравилаКонвертацииСвойств
	|ГДЕ
	|	ПравилаКонвертацииСвойств.ПометкаУдаления = ЛОЖЬ
	|	И ПравилаКонвертацииСвойств.Владелец = &Владелец
	|
	|УПОРЯДОЧИТЬ ПО
	|	Ссылка ИЕРАРХИЯ";
	
	Запрос.УстановитьПараметр("Владелец", пкоСсылка);
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	ВыборкаОбщая = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	
	Пока ВыборкаОбщая.Следующий() Цикл
		
		Если ВыборкаОбщая.ЭтоГруппа И НЕ ВыборкаОбщая.Отключить Тогда // Если отключено ПКГС, внутренние ПКС не грузим
			
			СтрокаПКГС = ЗагрузитьПКГС(ВыборкаОбщая, ТаблицаСвойств);
			
			ВыборкаСвойстваТЧ = ВыборкаОбщая.Выбрать(ОбходРезультатаЗапроса.Прямой);
			
			Пока ВыборкаСвойстваТЧ.Следующий() Цикл
				
				ЗагрузитьПКС(ВыборкаСвойстваТЧ, СтрокаПКГС.ПравилаГруппы);
				
			КонецЦикла;
			
		Иначе
			
			ЗагрузитьПКС(ВыборкаОбщая, ТаблицаСвойств, ТаблицаПоиска);
			
		КонецЕсли;
		
	КонецЦикла;

	ТаблицаСвойств.Сортировать("Порядок");
	ТаблицаПоиска.Сортировать("Порядок");
	
КонецПроцедуры

// Осуществляет загрузку правила конвертации свойств.
//
// Параметры:
//  ВыборкаПКС  - ВыборкаИзРезультатаЗапроса - содержит данные конкретного ПКС.
//  ТаблицаСвойств - см. КоллекцияПравилаКонвертацииСвойств
//  ТаблицаПоиска - см. КоллекцияПравилаКонвертацииСвойств
//
Процедура ЗагрузитьПКС(ВыборкаПКС, ТаблицаСвойств, ТаблицаПоиска = Неопределено, СтрокаПолейПоиска = "")

	//Если ВыборкаПКС.Отключить Тогда
	//	Возврат;
	//КонецЕсли;
	
	ЭтоПолеПоиска = ВыборкаПКС.Поиск;
	
	Если ЭтоПолеПоиска И ТаблицаПоиска <> Неопределено Тогда
		НоваяСтрока = ТаблицаПоиска.Добавить();
	Иначе
		НоваяСтрока = ТаблицаСвойств.Добавить();
	КонецЕсли;
	
	// Значения по умолчанию
	НоваяСтрока.НеЗамещать               = Ложь;
	НоваяСтрока.ПолучитьИзВходящихДанных = Ложь;
	
	НоваяСтрока.Источник = ВыборкаПКС.ИмяИсточника;
	НоваяСтрока.ВидИсточника = ВыборкаПКС.ВидИсточника;
	НоваяСтрока.ТипИсточника = ВыборкаПКС.ТипИсточника;
	
	НоваяСтрока.Приемник = ВыборкаПКС.ИмяПриемника;
	НоваяСтрока.ВидПриемника = ВыборкаПКС.ВидПриемника;
	НоваяСтрока.ТипПриемника = ВыборкаПКС.ТипПриемника;
	
	Если ЭтоПолеПоиска Тогда
		ДобавитьПолеКСтрокеПоиска(СтрокаПолейПоиска, НоваяСтрока.Приемник);
	КонецЕсли;
	
	НоваяСтрока.Имя = ВыборкаПКС.Код;
	НоваяСтрока.Наименование = ВыборкаПКС.Наименование;
	НоваяСтрока.Порядок = ВыборкаПКС.Порядок;
	НоваяСтрока.НеЗамещать = ВыборкаПКС.НеЗамещать;
	НоваяСтрока.Отключить = ВыборкаПКС.Отключить;
	НоваяСтрока.ПравилоКонвертации = ВыборкаПКС.ПравилоКонвертации;
	НоваяСтрока.ПолучитьИзВходящихДанных = ВыборкаПКС.ПолучитьИзВходящихДанных;
	НоваяСтрока.ПриводитьКДлине = ВыборкаПКС.АвтоматическиПриводитьЗначениеКДлинеПриемника;
	НоваяСтрока.ИмяПараметраДляПередачи = ВыборкаПКС.ИмяПараметраДляПередачи;
	НоваяСтрока.ПоискПоДатеНаРавенство = ВыборкаПКС.ПоискПоДатеНаРавенство;
	
	// Обработчики
	НоваяСтрока.ПередВыгрузкой = ВыборкаПКС.АлгоритмПередВыгрузкойСвойства;
	НоваяСтрока.ЕстьОбработчикПередВыгрузкой = Не ПустаяСтрока(НоваяСтрока.ПередВыгрузкой);
	
	НоваяСтрока.ПриВыгрузке = ВыборкаПКС.АлгоритмПриВыгрузкеСвойства;
	НоваяСтрока.ЕстьОбработчикПриВыгрузке = Не ПустаяСтрока(НоваяСтрока.ПриВыгрузке);
	
	НоваяСтрока.ПослеВыгрузки = ВыборкаПКС.АлгоритмПослеВыгрузкиСвойства;
	НоваяСтрока.ЕстьОбработчикПослеВыгрузки = Не ПустаяСтрока(НоваяСтрока.ПослеВыгрузки);
	
	НоваяСтрока.ПередЗагрузкой = ВыборкаПКС.АлгоритмПередЗагрузкойСвойства;
	НоваяСтрока.ЕстьОбработчикПередЗагрузкой = НЕ ПустаяСтрока(НоваяСтрока.ПередЗагрузкой);
	
	НоваяСтрока.ПриЗагрузке = ВыборкаПКС.АлгоритмПриЗагрузкеСвойства;
	НоваяСтрока.ЕстьОбработчикПриЗагрузке = НЕ ПустаяСтрока(НоваяСтрока.ПриЗагрузке);
	
	НоваяСтрока.ПослеЗагрузки = ВыборкаПКС.АлгоритмПослеЗагрузкиСвойства;
	НоваяСтрока.ЕстьОбработчикПослеЗагрузки = НЕ ПустаяСтрока(НоваяСтрока.ПослеЗагрузки);
	
	//НоваяСтрока.УпрощеннаяВыгрузкаСвойства = НЕ НоваяСтрока.ПолучитьИзВходящихДанных
	//	И НЕ НоваяСтрока.ЕстьОбработчикПередВыгрузкой
	//	И НЕ НоваяСтрока.ЕстьОбработчикПриВыгрузке
	//	И НЕ НоваяСтрока.ЕстьОбработчикПослеВыгрузки
	//	И ПустаяСтрока(НоваяСтрока.ПравилоКонвертации)
	//	И НоваяСтрока.ТипИсточника = НоваяСтрока.ТипПриемника
	//	И (НоваяСтрока.ТипИсточника = "Строка" 
	//		ИЛИ НоваяСтрока.ТипИсточника = "Число" 
	//		ИЛИ НоваяСтрока.ТипИсточника = "Булево" 
	//		ИЛИ НоваяСтрока.ТипИсточника = "Дата");
			
	НоваяСтрока.УпрощеннаяЗагрузкаСвойства = НЕ НоваяСтрока.ПолучитьИзВходящихДанных 
		И НЕ НоваяСтрока.ЕстьОбработчикПередЗагрузкой 
		И НЕ НоваяСтрока.ЕстьОбработчикПриЗагрузке 
		И НЕ НоваяСтрока.ЕстьОбработчикПослеЗагрузки
		И ПустаяСтрока(НоваяСтрока.ПравилоКонвертации) 
		И НоваяСтрока.ТипИсточника = НоваяСтрока.ТипПриемника 
		И (НоваяСтрока.ТипИсточника = "Строка" 
			ИЛИ НоваяСтрока.ТипИсточника = "Число" 
			ИЛИ НоваяСтрока.ТипИсточника = "Булево" 
			ИЛИ НоваяСтрока.ТипИсточника = "Дата");
		
	//НоваяСтрока.НуженУзелXMLПриВыгрузке = НоваяСтрока.ЕстьОбработчикПриВыгрузке ИЛИ НоваяСтрока.ЕстьОбработчикПослеВыгрузки;
	НоваяСтрока.НуженУзелXMLПриВыгрузке = Ложь;
	
КонецПроцедуры

// Осуществляет загрузку правила конвертации группы свойств.
//
// Параметры:
//   ВыборкаПКГС  - ВыборкаИзРезультатаЗапроса - содержит данные конкретного ПКГС.
//   ТаблицаСвойств - см. КоллекцияПравилаКонвертацииСвойств
//
Функция ЗагрузитьПКГС(ВыборкаПКГС, ТаблицаСвойств)

	//Если ВыборкаПКГС.Отключить Тогда
	//	Возврат;
	//КонецЕсли;
	
	НоваяСтрока               = ТаблицаСвойств.Добавить();
	НоваяСтрока.ЭтоГруппа     = Истина;
	НоваяСтрока.ПравилаГруппы = КоллекцияПравилаКонвертацииСвойств().Скопировать();
	
	// Значения по умолчанию
	НоваяСтрока.НеЗамещать               = Ложь;
	НоваяСтрока.ПолучитьИзВходящихДанных = Ложь;
	НоваяСтрока.УпрощеннаяВыгрузкаСвойства = Ложь;
	
	НоваяСтрока.Источник = ВыборкаПКГС.ИмяИсточника;
	НоваяСтрока.ВидИсточника = ВыборкаПКГС.ВидИсточника;
	НоваяСтрока.ТипИсточника = ВыборкаПКГС.ТипИсточника;
	
	НоваяСтрока.Приемник = ВыборкаПКГС.ИмяПриемника;
	НоваяСтрока.ВидПриемника = ВыборкаПКГС.ВидПриемника;
	НоваяСтрока.ТипПриемника = ВыборкаПКГС.ТипПриемника;
	
	НоваяСтрока.Имя = ВыборкаПКГС.Код;
	НоваяСтрока.Наименование = ВыборкаПКГС.Наименование;
	НоваяСтрока.Порядок = ВыборкаПКГС.Порядок;
	НоваяСтрока.НеЗамещать = ВыборкаПКГС.НеЗамещать;
	НоваяСтрока.Отключить = ВыборкаПКГС.Отключить;
	НоваяСтрока.ПравилоКонвертации = ВыборкаПКГС.ИмяПравилаКонвертации;
	НоваяСтрока.ВыгружатьГруппуЧерезФайл = ВыборкаПКГС.ВыгружатьГруппуЧерезФайл;
	НоваяСтрока.ПолучитьИзВходящихДанных = ВыборкаПКГС.ПолучитьИзВходящихДанных;
	
	// Обработчики
	НоваяСтрока.ПередОбработкойВыгрузки = ВыборкаПКГС.АлгоритмПередОбработкойВыгрузки;
	НоваяСтрока.ЕстьОбработчикПередОбработкойВыгрузки = Не ПустаяСтрока(НоваяСтрока.ПередОбработкойВыгрузки);
	
	НоваяСтрока.ПослеОбработкиВыгрузки = ВыборкаПКГС.АлгоритмПослеОбработкиВыгрузки;
	НоваяСтрока.ЕстьОбработчикПослеОбработкиВыгрузки = Не ПустаяСтрока(НоваяСтрока.ПослеОбработкиВыгрузки);
	
	НоваяСтрока.ПередВыгрузкой = ВыборкаПКГС.АлгоритмПередВыгрузкойСвойства;
	НоваяСтрока.ЕстьОбработчикПередВыгрузкой = Не ПустаяСтрока(НоваяСтрока.ПередВыгрузкой);
	
	НоваяСтрока.ПриВыгрузке = ВыборкаПКГС.АлгоритмПриВыгрузкеСвойства;
	НоваяСтрока.ЕстьОбработчикПриВыгрузке = Не ПустаяСтрока(НоваяСтрока.ПриВыгрузке);
	
	НоваяСтрока.ПослеВыгрузки = ВыборкаПКГС.АлгоритмПослеВыгрузкиСвойства;
	НоваяСтрока.ЕстьОбработчикПослеВыгрузки = Не ПустаяСтрока(НоваяСтрока.ПослеВыгрузки);
	
	//НоваяСтрока.НуженУзелXMLПриВыгрузке = НоваяСтрока.ЕстьОбработчикПриВыгрузке ИЛИ НоваяСтрока.ЕстьОбработчикПослеВыгрузки;
	//НоваяСтрока.НуженУзелXMLПриВыгрузкеГруппы = НоваяСтрока.ЕстьОбработчикПослеОбработкиВыгрузки;
	НоваяСтрока.НуженУзелXMLПриВыгрузке = Ложь;
	НоваяСтрока.НуженУзелXMLПриВыгрузкеГруппы = Ложь;
	
	
	
	Возврат НоваяСтрока;
	
КонецФункции

// Осуществляет загрузку правил конвертации значений.
//
// Параметры:
//  пкоСсылка  - СправочникСсылка.ПравилаКонвертацииОбъектов - ссылка на ПКО для полученияПКЗ.
//  Значения       - Соответствие - соответствие значений объекта источника - строковым
//                   представлениям объекта приемника.
//  ТипИсточника   - Строка - тип объекта источника.
//
Процедура ЗагрузитьЗначения(пкоСсылка, Значения, ТипПриемника);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПравилаКонвертацииЗначений.Ссылка КАК Ссылка,
	|	ПравилаКонвертацииЗначений.ВерсияДанных КАК ВерсияДанных,
	|	ПравилаКонвертацииЗначений.ПометкаУдаления КАК ПометкаУдаления,
	|	ПравилаКонвертацииЗначений.Владелец КАК Владелец,
	|	ПравилаКонвертацииЗначений.Родитель КАК Родитель,
	|	ПравилаКонвертацииЗначений.ЭтоГруппа КАК ЭтоГруппа,
	|	ПравилаКонвертацииЗначений.Код КАК Код,
	|	ПравилаКонвертацииЗначений.Наименование КАК Наименование,
	|	ПравилаКонвертацииЗначений.ЗначениеИсточник КАК ЗначениеИсточник,
	|	ПравилаКонвертацииЗначений.ЗначениеПриемник КАК ЗначениеПриемник,
	|	ПравилаКонвертацииЗначений.Источник КАК Источник,
	|	ПравилаКонвертацииЗначений.Комментарий КАК Комментарий,
	|	ПравилаКонвертацииЗначений.Описание КАК Описание,
	|	ПравилаКонвертацииЗначений.Порядок КАК Порядок,
	|	ПравилаКонвертацииЗначений.Приемник КАК Приемник,
	|	ПравилаКонвертацииЗначений.Предопределенный КАК Предопределенный,
	|	ПравилаКонвертацииЗначений.ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных
	|ИЗ
	|	Справочник.ПравилаКонвертацииЗначений КАК ПравилаКонвертацииЗначений
	|ГДЕ
	|	ПравилаКонвертацииЗначений.ПометкаУдаления = ЛОЖЬ
	|	И ПравилаКонвертацииЗначений.Владелец = &Владелец";
	Запрос.УстановитьПараметр("Владелец", пкоСсылка);
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	ВыборкаЗначений = Результат.Выбрать(ОбходРезультатаЗапроса.Прямой);
	Пока ВыборкаЗначений.Следующий() Цикл
		
		ЗагрузитьПКЗ(ВыборкаЗначений, Значения, ТипПриемника);
		
	КонецЦикла;
	
КонецПроцедуры

// Осуществляет загрузку правила конвертации значений.
//
// Параметры:
//  ВыборкаЗначений - ВыборкаИзРезультатаЗапроса - содержит данные конкретного ПКЗ.
//  Значения       - Соответствие - соответствие значений объекта источника - строковым
//                   представлениям объекта приемника.
//  ТипИсточника   - Строка - тип объекта источника.
//
Процедура ЗагрузитьПКЗ(ВыборкаЗначений, Значения, ТипПриемника)
	
	Источник = ВыборкаЗначений.ЗначениеИсточник;
	Приемник = ВыборкаЗначений.ЗначениеПриемник;
	
	//Значения[одПолучитьЗначениеПоСтроке(Источник, ТипИсточника)] = Приемник;
	Значения[Источник] = одПолучитьЗначениеПоСтроке(Приемник, ТипПриемника);
	
КонецПроцедуры

Процедура ДобавитьПолеКСтрокеПоиска(СтрокаПолейПоиска, ИмяПоля)
	
	Если ПустаяСтрока(ИмяПоля) Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(СтрокаПолейПоиска) Тогда
		СтрокаПолейПоиска = СтрокаПолейПоиска + ",";
	КонецЕсли;
	
	СтрокаПолейПоиска = СтрокаПолейПоиска + ИмяПоля;
	
КонецПроцедуры

// Осуществляет загрузку алгоритмов в соответствии с форматом правил обмена.
//
// Параметры:
//  ПравилаОбмена  - ЧтениеXML - объект типа ЧтениеXML.
//  ЗаписьXML      - ЗаписьXML - объект типа ЗаписьXML - правила, сохраняемые в файл обмена и
//                   используемые при загрузке данных.
//
Процедура ЗагрузитьАлгоритмы()

	Алгоритмы.Очистить();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Алгоритмы.Код КАК ИмяАлгоритма,
	|	Алгоритмы.Алгоритм КАК Алгоритм,
	|	Алгоритмы.ИспользуетсяПриЗагрузке КАК ИспользуетсяПриЗагрузке,
	|	Алгоритмы.Параметры КАК Параметры
	|ИЗ
	|	Справочник.Алгоритмы КАК Алгоритмы
	|ГДЕ
	|	Алгоритмы.ПометкаУдаления = ЛОЖЬ
	|	И Алгоритмы.Владелец = &УчетнаяЗаписьОбмена
	|	И Алгоритмы.ЭтоГруппа = ЛОЖЬ";
	Запрос.УстановитьПараметр("УчетнаяЗаписьОбмена", мУчетнаяЗаписьОбмена);
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	ВыборкаАлгоритмов = Результат.Выбрать(ОбходРезультатаЗапроса.Прямой);
	Пока ВыборкаАлгоритмов.Следующий() Цикл
		ЗагрузитьАлгоритм(ВыборкаАлгоритмов);
	КонецЦикла;
	
КонецПроцедуры

// Осуществляет загрузку алгоритма в соответствии с форматом правил обмена.
//
// Параметры:
//  ВыборкаАлгоритмов  - ВыборкаИзРезультатаЗапроса - информация по конкретному алгоритму.
//
Процедура ЗагрузитьАлгоритм(ВыборкаАлгоритмов)
	
	// to do: Проверить ситуацию с параметрами алгоритмов. Где они передаются?
	
	Если ВыборкаАлгоритмов.ИспользуетсяПриЗагрузке Тогда
		Алгоритмы.Вставить(ВыборкаАлгоритмов.ИмяАлгоритма, ВыборкаАлгоритмов.Алгоритм);
	КонецЕсли;
	
КонецПроцедуры

// Осуществляет загрузку запросов в соответствии с форматом правил обмена.
//
// Параметры:
//  ПравилаОбмена  - ЧтениеXML - объект типа ЧтениеXML.
//  ЗаписьXML      - ЗаписьXML - объект типа ЗаписьXML - правила, сохраняемые в файл обмена и
//                   используемые при загрузке данных.
//
Процедура ЗагрузитьЗапросы()

	//Запросы.Очистить();

	//ЗаписьXML.ЗаписатьНачалоЭлемента("Запросы");
	//
	//Пока ПравилаОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ПравилаОбмена.ЛокальноеИмя;
	//	
	//	Если      ИмяУзла = "Запрос" Тогда
	//		ЗагрузитьЗапрос(ПравилаОбмена, ЗаписьXML);
	//	ИначеЕсли (ИмяУзла = "Запросы") И (ПравилаОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		Прервать;
	//	КонецЕсли;
	//	
	//КонецЦикла;

	//ЗаписьXML.ЗаписатьКонецЭлемента();
	
КонецПроцедуры

// Осуществляет загрузку запроса в соответствии с форматом правил обмена.
//
// Параметры:
//  ПравилаОбмена  - ЧтениеXML - объект типа ЧтениеXML.
//  ЗаписьXML      - ЗаписьXML - объект типа ЗаписьXML - правила, сохраняемые в файл обмена и
//                   используемые при загрузке данных.
//
Процедура ЗагрузитьЗапрос()

	//ИспользуетсяПриЗагрузке = одАтрибут(ПравилаОбмена, одТипБулево, "ИспользуетсяПриЗагрузке");
	//Имя                     = одАтрибут(ПравилаОбмена, одТипСтрока, "Имя");
	//
	//Пока ПравилаОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ПравилаОбмена.ЛокальноеИмя;
	//	
	//	Если      ИмяУзла = "Текст" Тогда
	//		Текст = ПолучитьИзТекстаЗначениеОбработчика(ПравилаОбмена);
	//	ИначеЕсли (ИмяУзла = "Запрос") И (ПравилаОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		Прервать;
	//	Иначе
	//		одПропустить(ПравилаОбмена);
	//	КонецЕсли;
	//	
	//КонецЦикла;

	//Если ИспользуетсяПриЗагрузке Тогда
	//	Если РежимОбмена = "Загрузка" Тогда
	//		Запрос	= Новый Запрос(Текст);
	//		Запросы.Вставить(Имя, Запрос);
	//	Иначе
	//		ЗаписьXML.ЗаписатьНачалоЭлемента("Запрос");
	//		УстановитьАтрибут(ЗаписьXML, "ИспользуетсяПриЗагрузке", Истина);
	//		УстановитьАтрибут(ЗаписьXML, "Имя",   Имя);
	//		одЗаписатьЭлемент(ЗаписьXML, "Текст", Текст);
	//		ЗаписьXML.ЗаписатьКонецЭлемента();
	//	КонецЕсли;
	//Иначе
	//	Если РежимОбмена <> "Загрузка" Тогда
	//		Запрос	= Новый Запрос(Текст);
	//		Запросы.Вставить(Имя, Запрос);
	//	КонецЕсли;
	//КонецЕсли;
	
КонецПроцедуры

// Осуществляет загрузку внешних обработок в соответствии с форматом правил обмена.
//
// Параметры:
//  ПравилаОбмена  - ЧтениеXML - объект типа ЧтениеXML.
//  ЗаписьXML      - ЗаписьXML - объект типа ЗаписьXML - правила, сохраняемые в файл обмена и
//                   используемые при загрузке данных.
//
Процедура ЗагрузитьОбработки()

	//ДопОбработки.Очистить();
	//ПараметрыДопОбработок.Очистить();
	//
	//ОбработкиНастройкиВыгрузки.Очистить();
	//ОбработкиНастройкиЗагрузки.Очистить();

	//ЗаписьXML.ЗаписатьНачалоЭлемента("Обработки");
	//
	//Пока ПравилаОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ПравилаОбмена.ЛокальноеИмя;
	//	
	//	Если      ИмяУзла = "Обработка" Тогда
	//		ЗагрузитьОбработку(ПравилаОбмена, ЗаписьXML);
	//	ИначеЕсли (ИмяУзла = "Обработки") И (ПравилаОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		Прервать;
	//	КонецЕсли;
	//	
	//КонецЦикла;

	//ЗаписьXML.ЗаписатьКонецЭлемента();
	
КонецПроцедуры

// Осуществляет загрузку обработки в соответствии с форматом правил обмена.
//
// Параметры:
//  ПравилаОбмена  - ЧтениеXML - объект типа ЧтениеXML.
//  ЗаписьXML      - ЗаписьXML - объект типа ЗаписьXML - правила, сохраняемые в файл обмена и
//                   используемые при загрузке данных.
//
Процедура ЗагрузитьОбработку()

	//Имя                     = одАтрибут(ПравилаОбмена, одТипСтрока, "Имя");
	//Наименование            = одАтрибут(ПравилаОбмена, одТипСтрока, "Наименование");
	//ЭтоОбработкаНастройки   = одАтрибут(ПравилаОбмена, одТипБулево, "ЭтоОбработкаНастройки");
	//
	//ИспользуетсяПриВыгрузке = одАтрибут(ПравилаОбмена, одТипБулево, "ИспользуетсяПриВыгрузке");
	//ИспользуетсяПриЗагрузке = одАтрибут(ПравилаОбмена, одТипБулево, "ИспользуетсяПриЗагрузке");

	//СтрокаПараметров        = одАтрибут(ПравилаОбмена, одТипСтрока, "Параметры");
	//
	//ХранилищеОбработки      = одЗначениеЭлемента(ПравилаОбмена, одТипХранилищеЗначения);

	//ПараметрыДопОбработок.Вставить(Имя, МассивИзСтроки(СтрокаПараметров));
	//
	//
	//Если ИспользуетсяПриЗагрузке Тогда
	//	Если РежимОбмена = "Загрузка" Тогда
	//		
	//	Иначе
	//		ЗаписьXML.ЗаписатьНачалоЭлемента("Обработка");
	//		УстановитьАтрибут(ЗаписьXML, "ИспользуетсяПриЗагрузке", Истина);
	//		УстановитьАтрибут(ЗаписьXML, "Имя",                     Имя);
	//		УстановитьАтрибут(ЗаписьXML, "Наименование",            Наименование);
	//		УстановитьАтрибут(ЗаписьXML, "ЭтоОбработкаНастройки",   ЭтоОбработкаНастройки);
	//		ЗаписьXML.ЗаписатьТекст(XMLСтрока(ХранилищеОбработки));
	//		ЗаписьXML.ЗаписатьКонецЭлемента();
	//	КонецЕсли;
	//КонецЕсли;
	//
	//Если ЭтоОбработкаНастройки Тогда
	//	Если (РежимОбмена = "Загрузка") И ИспользуетсяПриЗагрузке Тогда
	//		ОбработкиНастройкиЗагрузки.Добавить(Имя, Наименование, , );
	//		
	//	ИначеЕсли (РежимОбмена = "Выгрузка") И ИспользуетсяПриВыгрузке Тогда
	//		ОбработкиНастройкиВыгрузки.Добавить(Имя, Наименование, , );
	//		
	//	КонецЕсли; 
	//КонецЕсли; 
	
КонецПроцедуры

#КонецОбласти

#Область ОписаниеТиповКоллекций

// Возвращаемое значение:
//   ТаблицаЗначений - коллекция правил конвертации данных:
//     * Имя - Строка
//     * Наименование - Строка
//     * Порядок - Число
//     * СинхронизироватьПоИдентификатору - Булево
//     * НеСоздаватьЕслиНеНайден - Булево
//     * НеВыгружатьОбъектыСвойствПоСсылкам - Булево
//     * ПродолжитьПоискПоПолямПоискаЕслиПоИдентификаторуНеНашли - Булево
//     * ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD - Булево
//     * ИспользоватьБыстрыйПоискПриЗагрузке - Булево
//     * ГенерироватьНовыйНомерИлиКодЕслиНеУказан - Булево
//     * МаленькоеКоличествоОбъектов - Булево
//     * КоличествоОбращенийДляВыгрузкиСсылки - Число
//     * КоличествоЭлементовВИБ - Число
//     * СпособВыгрузки - Произвольный
//     * Источник - Произвольный
//     * Приемник - Произвольный
//     * ТипИсточника - Строка
//     * ПередВыгрузкой - Произвольный
//     * ПриВыгрузке - Произвольный
//     * ПослеВыгрузки - Произвольный
//     * ПослеВыгрузкиВФайл - Произвольный
//     * ЕстьОбработчикПередВыгрузкой - Булево
//     * ЕстьОбработчикПриВыгрузке - Булево
//     * ЕстьОбработчикПослеВыгрузки - Булево
//     * ЕстьОбработчикПослеВыгрузкиВФайл - Булево
//     * ПередЗагрузкой - Произвольный
//     * ПриЗагрузке - Произвольный
//     * ПослеЗагрузки - Произвольный
//     * ПоследовательностьПолейПоиска - Произвольный
//     * ПоискПоТабличнымЧастям - см. КоллекцияПоискПоТабличнымЧастям
//     * ЕстьОбработчикПередЗагрузкой - Булево
//     * ЕстьОбработчикПриЗагрузке - Булево
//     * ЕстьОбработчикПослеЗагрузки - Булево
//     * ЕстьОбработчикПоследовательностьПолейПоиска - Булево
//     * СвойстваПоиска - см. КоллекцияПравилаКонвертацииСвойств
//     * Свойства - см. КоллекцияПравилаКонвертацииСвойств
//     * Выгруженные - ТаблицаЗначений
//     * ВыгружатьПредставлениеИсточника - Булево
//     * НеЗамещать - Булево
//     * ЗапоминатьВыгруженные - Булево
//     * ВсеОбъектыВыгружены - Булево
// 
Функция КоллекцияПравилаКонвертации()
	
	Возврат ТаблицаПравилКонвертации;
	
КонецФункции

// Возвращаемое значение:
//   ТаблицаЗначений - коллекция правил конвертации свойств данных:
//     * Имя - Строка
//     * Наименование - Строка
//     * Порядок - Число
//     * ЭтоГруппа - Булево
//     * ЭтоПолеПоиска - Булево
//     * ПравилаГруппы - см. КоллекцияПравилаКонвертацииСвойств
//     * ПравилаГруппыОтключенные - Произвольный
//     * ВидИсточника - Произвольный
//     * ВидПриемника - Произвольный
//     * УпрощеннаяВыгрузкаСвойства - Булево
//     * НуженУзелXMLПриВыгрузке - Булево
//     * НуженУзелXMLПриВыгрузкеГруппы - Булево
//     * ТипИсточника - Строка
//     * ТипПриемника - Строка
//     * Источник - Произвольный
//     * Приемник - Произвольный
//     * ПравилоКонвертации - Произвольный
//     * ПолучитьИзВходящихДанных - Булево
//     * НеЗамещать - Булево
//     * ЭтоОбязательноеСвойство - Булево
//     * ПередВыгрузкой - Произвольный
//     * ИмяОбработчикаПередВыгрузкой - Произвольный
//     * ПриВыгрузке - Произвольный
//     * ИмяОбработчикаПриВыгрузке - Произвольный
//     * ПослеВыгрузки - Произвольный
//     * ИмяОбработчикаПослеВыгрузки - Произвольный
//     * ПередОбработкойВыгрузки - Произвольный
//     * ИмяОбработчикаПередОбработкойВыгрузки - Произвольный
//     * ПослеОбработкиВыгрузки - Произвольный
//     * ИмяОбработчикаПослеОбработкиВыгрузки - Произвольный
//     * ЕстьОбработчикПередВыгрузкой - Булево
//     * ЕстьОбработчикПриВыгрузке - Булево
//     * ЕстьОбработчикПослеВыгрузки - Булево
//     * ЕстьОбработчикПередОбработкойВыгрузки - Булево
//     * ЕстьОбработчикПослеОбработкиВыгрузки - Булево
//     * ПриводитьКДлине - Число
//     * ИмяПараметраДляПередачи - Строка
//     * ПоискПоДатеНаРавенство - Булево
//     * ВыгружатьГруппуЧерезФайл - Булево
//     * СтрокаПолейПоиска - Произвольный
// 
Функция КоллекцияПравилаКонвертацииСвойств()
	
	Возврат мТаблицаПравилКонвертацииСвойств;
	
КонецФункции

// Возвращаемое значение:
//   ТаблицаЗначений - коллекция правил поиска по табличным частям:
//     * ИмяЭлемента - Произвольный
//     * ПоляПоискаТЧ - Массив из Произвольный
// 
Функция КоллекцияПоискПоТабличнымЧастям()
	
	ПоискПоТабличнымЧастям = Новый ТаблицаЗначений;
	ПоискПоТабличнымЧастям.Колонки.Добавить("ИмяЭлемента");
	ПоискПоТабличнымЧастям.Колонки.Добавить("ПоляПоискаТЧ");
	
	Возврат ПоискПоТабличнымЧастям;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыЗагрузкиДанных

// Читает очередной объект из файла обмена, производит загрузку.
//
// Параметры:
//   ДанныеОбъекта - Соответствие - данные загружаемого объекта преобразованные из строки JSON.
// 
Функция ПрочитатьОбъект(Знач ДанныеОбъекта)

	НПП						= одЗначениеСвойства(ДанныеОбъекта, одТипЧисло, "_Нпп");
	ГНПП					= одЗначениеСвойства(ДанныеОбъекта, одТипЧисло, "_Гнпп");
	Источник				= одЗначениеСвойства(ДанныеОбъекта, одТипСтрока, "_Тип");
	ИмяПравила				= "";
	ИмяПравилаИзОбъекта		= одЗначениеСвойства(ДанныеОбъекта, одТипСтрока, "_ИмяПКО");
	
	// Поиск правила по имени:
	СтрокаПКО 				= ТаблицаПравилКонвертации.Найти(ИмяПравилаИзОбъекта, "Имя");
	
	// Если у правило отсутствет - не грузим:
	Если СтрокаПКО = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяПравила 				= СтрокаПКО.Имя;
	НеЗамещатьОбъект 		= СтрокаПКО.НеЗамещать;
	ПрефиксАвтонумерации	= ""; // Пока не нужно
	ТипОбъектаСтрокой		= СтрокаПКО.Приемник;
	ТипОбъекта				= Тип(ТипОбъектаСтрокой);
	ИнформацияОТипах 		= мСоответствиеТиповДанныхДляЗагрузки[ТипОбъекта];

	КомментарииКЗагрузкеОбъекта(НПП, ИмяПравила, Источник, ТипОбъекта, ГНПП); // Протокол загрузки
	
	СтруктураСвойств = Менеджеры[ТипОбъекта];
	ИмяТипаОбъекта   = СтруктураСвойств.ИмяТипа;

	Если ИмяТипаОбъекта = "Документ" Тогда
		
		РежимЗаписи     = одЗначениеСвойства(ДанныеОбъекта, одТипСтрока, "_РежимЗаписи"); // добавить в будущем в конвертер JSON.
		РежимПроведения = одЗначениеСвойства(ДанныеОбъекта, одТипСтрока, "_РежимПроведения");
		
	КонецЕсли;
	
	Ссылка          = Неопределено;
	Объект          = Неопределено; // СправочникОбъект, ДокументОбъект, РегистрСведенийНаборЗаписей, и т.п.
	ОбъектНайден    = Истина;
	ПометкаУдаления = Неопределено;
	
	СвойстваПоиска  = Новый Соответствие; // Добавить свойства поиска из ПКО
	СвойстваПоискаНеЗамещать  = Новый Соответствие; // Добавить свойства поиска с признаком "НеЗамещать" из ПКО
	
	НужноЗаписатьОбъект = НЕ ЗаписыватьВИнформационнуюБазуТолькоИзмененныеОбъекты; // по-умолчанию пишем всегда, разобраться в будущем
	
	Если Не ПустаяСтрока(ИмяПравила) Тогда
		
		Правило = Правила[ИмяПравила];
		ЕстьОбработчикПередЗагрузкой = Правило.ЕстьОбработчикПередЗагрузкой;
		ЕстьОбработчикПриЗагрузке    = Правило.ЕстьОбработчикПриЗагрузке;
		ЕстьОбработчикПослеЗагрузки  = Правило.ЕстьОбработчикПослеЗагрузки;
		ГенерироватьНовыйНомерИлиКодЕслиНеУказан = Правило.ГенерироватьНовыйНомерИлиКодЕслиНеУказан;
		
	Иначе
		
		ЕстьОбработчикПередЗагрузкой = Ложь;
		ЕстьОбработчикПриЗагрузке    = Ложь;
		ЕстьОбработчикПослеЗагрузки  = Ложь;
		ГенерироватьНовыйНомерИлиКодЕслиНеУказан = Ложь;
		
	КонецЕсли;

	// Глобальный обработчик события ПередЗагрузкойОбъекта.
	Если ЕстьГлобальныйОбработчикПередЗагрузкойОбъекта Тогда
		
		Отказ = Ложь;
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Конвертация, "ПередЗагрузкойОбъекта"));
			//	
			//Иначе
				
				Выполнить(Конвертация.ПередЗагрузкойОбъекта);
				
			//КонецЕсли;
			
		Исключение
			
			ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(53, ОписаниеОшибки(), 
				ИмяПравила, Источник, ТипОбъекта, Неопределено, Нстр("ru = 'ПередЗагрузкойОбъекта (глобальный)'"));
			
		КонецПопытки;
		
		Если Отказ Тогда // Отказ от загрузки объекта
			
			Возврат Неопределено;
			
		КонецЕсли;
	КонецЕсли;
	
	// Обработчик события ПередЗагрузкойОбъекта у ПКО
	Если ЕстьОбработчикПередЗагрузкой Тогда
		
		Отказ = Ложь;
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПередЗагрузкой"));
			//	
			//Иначе
				
				Выполнить(Правило.ПередЗагрузкой);
				
			//КонецЕсли;
			
		Исключение
			
			ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(19, ОписаниеОшибки(), 
				ИмяПравила, Источник, ТипОбъекта, Неопределено, "ПередЗагрузкойОбъекта");
			
		КонецПопытки;
		
		Если Отказ Тогда // Отказ от загрузки объекта
			
			//одПропустить(ФайлОбмена, "Объект");
			Возврат Неопределено;
			
		КонецЕсли;
		
	КонецЕсли;
	
	СвойстваОбъектаМодифицированы = Ложь;
	НаборЗаписей = Неопределено;
	НППГлобальнойСсылки = 0;
	НППСсылки = 0;
	ПараметрыОбъекта = Неопределено;
	
	// SimplyUNF ++
	
	// Обработка Ссылки:
	ДанныеСсылки = мТекущийобъектДляЧтения.Получить("_Ссылка"); // Соответствие с данными ссылки
	Если ДанныеСсылки <> Неопределено Тогда
		
		// Ссылка на элемент - сначала получаем по ссылке объект, а потом устанавливаем свойства.
		СозданныйОбъект = Неопределено;
		НеСоздаватьОбъектЕслиНеНайден = Неопределено;
		ИзвестнаяСсылкаУникальногоИдентификатора = Неопределено;
		
		Ссылка = НайтиОбъектПоСсылке(ДанныеСсылки, 
		ТипОбъекта,
		ИмяПравила, 
		СвойстваПоиска,
		СвойстваПоискаНеЗамещать,
		ОбъектНайден,
		СозданныйОбъект,
		НеСоздаватьОбъектЕслиНеНайден,
		Истина,
		СвойстваОбъектаМодифицированы,
		НППГлобальнойСсылки,
		НППСсылки,
		ИзвестнаяСсылкаУникальногоИдентификатора,
		ПараметрыОбъекта);
		
		НужноЗаписатьОбъект = НужноЗаписатьОбъект ИЛИ СвойстваОбъектаМодифицированы;
		
		Если Ссылка = Неопределено
			И НеСоздаватьОбъектЕслиНеНайден = Истина Тогда
			
			Возврат Неопределено;
			
		ИначеЕсли ИмяТипаОбъекта = "Перечисление" Тогда
			
			Объект = Ссылка;
			
		Иначе
			
			Объект = ПолучитьОбъектПоСсылкеИДопИнформации(СозданныйОбъект, Ссылка);
			
			Если ОбъектНайден И НеЗамещатьОбъект И (Не ЕстьОбработчикПриЗагрузке) Тогда
				
				Возврат Объект;
				
			КонецЕсли;
			
			Если Ссылка = Неопределено Тогда
				
				ДополнитьСтекНеЗаписанныхОбъектов(НПП, ГНПП, СозданныйОбъект, ИзвестнаяСсылкаУникальногоИдентификатора, ТипОбъекта, ПараметрыОбъекта);
				
			КонецЕсли;
			
		КонецЕсли; 
		
		// Обработчик события ПриЗагрузкеОбъекта.
		Если ЕстьОбработчикПриЗагрузке Тогда
			
			НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
			ОбъектМодифицирован = Истина;
			
			Попытка
				
				//Если ФлагРежимОтладкиОбработчиков Тогда
				//	
				//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПриЗагрузке"));
				//	
				//Иначе
					
					Выполнить(Правило.ПриЗагрузке);
					
				//КонецЕсли;
				
				НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
				
			Исключение
				
				УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
				ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(20, ОписаниеОшибки(), 
				ИмяПравила, Источник, ТипОбъекта, Объект, "ПриЗагрузкеОбъекта");
				
			КонецПопытки;
			
			Если ОбъектНайден И НеЗамещатьОбъект Тогда
				
				Возврат Объект;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Обработка реквизитов:
	сСвойстваИсточника = мТекущийобъектДляЧтения.Получить("_Свойства");
	ТаблицаПКС = СтрокаПКО.Свойства;
	
	Для Каждого СтрокаПКС Из ТаблицаПКС Цикл // ДанныеРеквизита - Соответствие, ключ - имя реквизита, значение - набор свойств объекта, или значение простого типа.
		
		Если СтрокаПКС.ЭтоГруппа = Истина ИЛИ СтрокаПКС.Отключить = Истина Тогда
			Продолжить; // ТЧ обрабатываем ниже
		КонецЕсли;
		
		//ЭтоПараметрДляОбъекта = (ИмяУзла = "ЗначениеПараметра");
		ЭтоПараметрДляОбъекта = Ложь; // Пока что параметры не используем
		
		Если НЕ ЭтоПараметрДляОбъекта И Объект = Неопределено Тогда
			
			// Объект не нашли и не создали - попробуем сейчас это сделать.
			ОбъектНайден = Ложь;
			
			// Обработчик события ПриЗагрузкеОбъекта.
			Если ЕстьОбработчикПриЗагрузке Тогда
				
				// Если есть обработчик при загрузке, то объект нужно перезаписывать, так как могут быть изменения.
				НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
				ОбъектМодифицирован = Истина;
				
				Попытка
					
					//Если ФлагРежимОтладкиОбработчиков Тогда
					//	
					//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПриЗагрузке"));
					//	
					//Иначе
						
						Выполнить(Правило.ПриЗагрузке);
						
					//КонецЕсли;
					
					НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
					
				Исключение
					
					ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(20, ОписаниеОшибки(), 
					ИмяПравила, Источник, ТипОбъекта, Объект, "ПриЗагрузкеОбъекта");
					
				КонецПопытки;
				
			КонецЕсли;
			
			// Так как мы не смогли создать объект в событии - создаем его отдельно.
			Если Объект = Неопределено Тогда
				
				НужноЗаписатьОбъект = Истина;
				
				Если ИмяТипаОбъекта = "Константы" Тогда
					
					Объект = Константы.СоздатьНабор();
					Объект.Прочитать();
					
				Иначе
					
					СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, Объект, Ложь, НаборЗаписей, , НППСсылки, НППГлобальнойСсылки, ПараметрыОбъекта);
					
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		хДанныеСвойства = сСвойстваИсточника.Получить(СтрокаПКС.Источник);
		
		Если хДанныеСвойства = Неопределено Тогда // возможно старое описание правил на отправителе и для этого ПКС не выгрузились данные
			Продолжить;
		КонецЕсли;
		
		Имя = СтрокаПКС.Приемник; // Имя свойства-приемника
		НеЗамещатьСвойство = СтрокаПКС.НеЗамещать; // Также возможно переопределяется в обработчика ПКС
		Если НЕ ЭтоПараметрДляОбъекта И ((ОбъектНайден И НеЗамещатьСвойство) ИЛИ (Имя = "ЭтоГруппа") ИЛИ (Объект[Имя] = NULL)) Тогда
			
			// неизвестное свойство
			Продолжить;
			
		КонецЕсли;
		
		Значение = ПрочитатьСвойство_2(Объект, СтрокаПКС, хДанныеСвойства, НеЗамещатьСвойство, ИнформацияОТипах, СтрокаПКО);
		
		Если НеЗамещатьСвойство Тогда // Возможно было переопределено во время чтения свойства
			Продолжить;
		КонецЕсли;
		
		Если ЭтоПараметрДляОбъекта Тогда
			
			// Дополняем коллекцию параметров объекта.
			ДобавитьПараметрПриНеобходимости(ПараметрыОбъекта, Имя, Значение);
			
		Иначе
			
			Если Имя = "ПометкаУдаления" Тогда
				
				ПометкаУдаления = Значение;
				
				Если Объект.ПометкаУдаления <> ПометкаУдаления Тогда
					Объект.ПометкаУдаления = ПометкаУдаления;
					НужноЗаписатьОбъект = Истина;
				КонецЕсли;
				
			Иначе
				
				Попытка
					
					Если Не НужноЗаписатьОбъект Тогда
						
						НужноЗаписатьОбъект = (Объект[Имя] <> Значение);
						
					КонецЕсли;
					
					Объект[Имя] = Значение;
					
				Исключение
					
					ЗП = ПолучитьСтруктуруЗаписиПротокола(26, ОписаниеОшибки());
					ЗП.ИмяПКО           = ИмяПравила;
					ЗП.НПП              = НПП;
					ЗП.ГНПП             = ГНПП;
					ЗП.Источник         = Источник;
					ЗП.Объект           = Объект;
					ЗП.ТипОбъекта       = ТипОбъекта;
					ЗП.Свойство         = Имя;
					ЗП.Значение         = Значение;
					ЗП.ТипЗначения      = ТипЗнч(Значение);
					СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(26, ЗП, Истина);
					
					Если Не ФлагРежимОтладки Тогда
						ВызватьИсключение СтрокаСообщенияОбОшибке;
					КонецЕсли;
					
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Обработка табличных частей:
	ТабЧасти = мТекущийобъектДляЧтения.Получить("_ТабличныеЧасти"); // Соответствие, ключ - Имя ТЧ, значение - массив соответствий - строк ТЧ.
	Если ТабЧасти <> Неопределено Тогда
		
		МассивПКГС = СтрокаПКО.Свойства.НайтиСтроки(Новый Структура("ЭтоГруппа, ВидИсточника", Истина, "ТабличнаяЧасть"));
		
		Для Каждого стрПКГС Из МассивПКГС Цикл
			
			Если стрПКГС.Отключить = Истина Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяТч = стрПКГС.Источник;
			
			ДанныеТЧ = ТабЧасти.Получить(ИмяТЧ);
			Если ДанныеТЧ = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если Объект = Неопределено Тогда
				
				ОбъектНайден = Ложь;
				
				// Обработчик события ПриЗагрузкеОбъекта.
				Если ЕстьОбработчикПриЗагрузке Тогда
					
					НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
					ОбъектМодифицирован = Истина;
					
					Попытка
						
						//Если ФлагРежимОтладкиОбработчиков Тогда
						//	
						//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПриЗагрузке"));
						//	
						//Иначе
							
							Выполнить(Правило.ПриЗагрузке);
							
						//КонецЕсли;
						
						НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
						
					Исключение
						
						УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
						ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(20, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), 
						ИмяПравила, Источник, ТипОбъекта, Объект, "ПриЗагрузкеОбъекта");
						
					КонецПопытки;
				КонецЕсли;
			КонецЕсли;
			
			Имя                = стрПКГС.Приемник;
			НеЗамещатьСвойство = стрПКГС.НеЗамещать; //одАтрибут(ФайлОбмена, одТипБулево, "НеЗамещать"); // Брать из ПКГС
			НеОчищать          = Ложь; // В КД2 признак устанавливается в обработчике ПКГС "ПередОбработкой". Возможно нужно его вывести на форму ПКГС
			
			Если ОбъектНайден И НеЗамещатьСвойство Тогда
				Продолжить;
			КонецЕсли;
			
			Если Объект = Неопределено Тогда
				
				СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, Объект, Ложь, НаборЗаписей, , НППСсылки, НППГлобальнойСсылки, ПараметрыОбъекта);
				НужноЗаписатьОбъект = Истина;
				
			КонецЕсли;
			
			//Если ИмяУзла = "ТабличнаяЧасть" Тогда
				
				// Загрузка элементов из табличной части.
				ЗагрузитьТабличнуюЧасть(
				Объект, 
				Имя, 
				Не НеОчищать, 
				ИнформацияОТипах, 
				НужноЗаписатьОбъект, 
				ПараметрыОбъекта, 
				Правило, 
				ДанныеТЧ, 
				стрПКГС.ПравилаГруппы);
				
			//ИначеЕсли ИмяУзла = "НаборЗаписей" Тогда
				
				//// загрузка движений
				//ЗагрузитьДвижения(Объект, Имя, Не НеОчищать, ИнформацияОТипах, НужноЗаписатьОбъект, ПараметрыОбъекта, Правило);
				
			//КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	Отказ = Ложь;
	
	// Глобальный обработчик события ПослеЗагрузкиОбъекта.
	Если ЕстьГлобальныйОбработчикПослеЗагрузкиОбъекта Тогда
		
		НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
		ОбъектМодифицирован = Истина;
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Конвертация, "ПослеЗагрузкиОбъекта"));
			//	
			//Иначе
				
				Выполнить(Конвертация.ПослеЗагрузкиОбъекта);
				
			//КонецЕсли;
			
			НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
			
		Исключение
			
			УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
			
			ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(54, ОписаниеОшибки(), 
			ИмяПравила, Источник, ТипОбъекта, Объект, Нстр("ru = 'ПослеЗагрузкиОбъекта (глобальный)'"));
			
		КонецПопытки;
	КонецЕсли;
	
	// Обработчик события ПослеЗагрузкиОбъекта.
	Если ЕстьОбработчикПослеЗагрузки Тогда
		
		НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
		ОбъектМодифицирован = Истина;
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПослеЗагрузки"));
			//	
			//Иначе
				
				Выполнить(Правило.ПослеЗагрузки);
				
			//КонецЕсли;
			
			НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
			
		Исключение
			
			УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
			
			ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(21, ОписаниеОшибки(), 
				ИмяПравила, Источник, ТипОбъекта, Объект, "ПослеЗагрузкиОбъекта");
			
		КонецПопытки;
	КонецЕсли;
	
	Если ИмяТипаОбъекта <> "РегистрСведений"
		И ИмяТипаОбъекта <> "Константы"
		И ИмяТипаОбъекта <> "Перечисление" Тогда
		// Проверка даты запрета для всех объектов кроме регистров сведений и констант.
		Отказ = Отказ Или ЗапретИзмененияДанныхПоДате(Объект);
	КонецЕсли;
	
	Если Отказ Тогда
		
		ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, Неопределено);
		УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
		Возврат Неопределено;
		
	КонецЕсли;
	
	Если ИмяТипаОбъекта = "Документ" Тогда
		
		Если РежимЗаписи = "Проведение" Тогда
			
			РежимЗаписи = РежимЗаписиДокумента.Проведение;
			
		Иначе
			
			РежимЗаписи = ?(РежимЗаписи = "ОтменаПроведения", РежимЗаписиДокумента.ОтменаПроведения, РежимЗаписиДокумента.Запись);
			
		КонецЕсли;
		
		
		РежимПроведения = ?(РежимПроведения = "Оперативный", РежимПроведенияДокумента.Оперативный, РежимПроведенияДокумента.Неоперативный);
		
		
		// Если хотим провести документ помеченный на удаление, то пометку удаления снимаем ...
		Если Объект.ПометкаУдаления
			И (РежимЗаписи = РежимЗаписиДокумента.Проведение) Тогда
			
			Объект.ПометкаУдаления = Ложь;
			НужноЗаписатьОбъект = Истина;
			
			// Пометку удаления в любом случае нужно удалять.
			ПометкаУдаления = Ложь;
			
		КонецЕсли;
		
		Попытка
			
			НужноЗаписатьОбъект = НужноЗаписатьОбъект ИЛИ (РежимЗаписи <> РежимЗаписиДокумента.Запись);
			
			РежимОбменДанными = РежимЗаписи = РежимЗаписиДокумента.Запись;
			
			ПровестиГенерациюКодаНомераПриНеобходимости(ГенерироватьНовыйНомерИлиКодЕслиНеУказан, Объект, 
			ИмяТипаОбъекта, НужноЗаписатьОбъект, РежимОбменДанными);
			
			Если НужноЗаписатьОбъект Тогда
				
				УстановитьОбменДаннымиЗагрузка(Объект, РежимОбменДанными);
				Если Объект.Проведен Тогда
					Объект.ПометкаУдаления = Ложь;
				КонецЕсли;
				
				Объект.Записать(РежимЗаписи, РежимПроведения);
				
			КонецЕсли;
			
		Исключение
			
			// Не смогли выполнить необходимые действия для документа.
			ЗаписатьДокументВБезопасномРежиме(Объект, ТипОбъекта);
			
			ЗП                        = ПолучитьСтруктуруЗаписиПротокола(25, ОписаниеОшибки());
			ЗП.ИмяПКО                 = ИмяПравила;
			
			Если Не ПустаяСтрока(Источник) Тогда
				
				ЗП.Источник           = Источник;
				
			КонецЕсли;
			
			ЗП.ТипОбъекта             = ТипОбъекта;
			ЗП.Объект                 = Строка(Объект);
			РезультирующаяСтрокаОшибка = ЗаписатьВПротоколВыполнения(25, ЗП);
			мОшибки.Добавить(РезультирующаяСтрокаОшибка);
			
		КонецПопытки;
		
		ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, Объект.Ссылка);
		
		УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
		
	ИначеЕсли ИмяТипаОбъекта <> "Перечисление" Тогда
		
		Если ИмяТипаОбъекта = "РегистрСведений" Тогда
			
			НужноЗаписатьОбъект = НЕ ЗаписыватьВИнформационнуюБазуТолькоИзмененныеОбъекты;
			
			Если СтруктураСвойств.Периодический 
				И Не ЗначениеЗаполнено(Объект.Период) Тогда
				
				Объект.Период = ТекущаяДатаСеанса();
				НужноЗаписатьОбъект = Истина;
				
			КонецЕсли;
			
			Если ЗаписыватьРегистрыНаборамиЗаписей Тогда
				
				НужноПроверитьДанныеДляВременногоНабора = 
				(ЗаписыватьВИнформационнуюБазуТолькоИзмененныеОбъекты
				И НЕ НужноЗаписатьОбъект) 
				ИЛИ НеЗамещатьОбъект;
				
				Если НужноПроверитьДанныеДляВременногоНабора Тогда
					
					ВременныйНаборЗаписей = РегистрыСведений[СтруктураСвойств.Имя].СоздатьНаборЗаписей();
					
				КонецЕсли;
				
				// Нужно отбор установить у регистра.
				Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
					
					ЭлементОтбора.Установить(Объект[ЭлементОтбора.Имя]);
					Если НужноПроверитьДанныеДляВременногоНабора Тогда
						УстановитьЗначениеЭлементаОтбора(ВременныйНаборЗаписей.Отбор, ЭлементОтбора.Имя, Объект[ЭлементОтбора.Имя]);
					КонецЕсли;
					
				КонецЦикла;
				
				Если НужноПроверитьДанныеДляВременногоНабора Тогда
					
					ВременныйНаборЗаписей.Прочитать();
					
					Если ВременныйНаборЗаписей.Количество() = 0 Тогда
						НужноЗаписатьОбъект = Истина;
					Иначе
						
						// Не хотим замещать существующий набор.
						Если НеЗамещатьОбъект Тогда
							Возврат Неопределено;
						КонецЕсли;
						
						НужноЗаписатьОбъект = Ложь;
						ТаблицаНовая = НаборЗаписей.Выгрузить(); // ТаблицаЗначений
						ТаблицаСтарая = ВременныйНаборЗаписей.Выгрузить(); 
						
						СтрокаНовая = ТаблицаНовая[0]; 
						СтрокаСтарая = ТаблицаСтарая[0]; 
						
						Для Каждого КолонкаТаблицы Из ТаблицаНовая.Колонки Цикл
							
							НужноЗаписатьОбъект = СтрокаНовая[КолонкаТаблицы.Имя] <>  СтрокаСтарая[КолонкаТаблицы.Имя];
							Если НужноЗаписатьОбъект Тогда
								Прервать;
							КонецЕсли;
							
						КонецЦикла;
						
					КонецЕсли;
					
				КонецЕсли;
				
				Объект = НаборЗаписей;
				
				Если СтруктураСвойств.Периодический Тогда
					// Проверка даты запрета изменения для набора записей.
					// Если не проходит - не записывать набор.
					Если ЗапретИзмененияДанныхПоДате(Объект) Тогда
						Возврат Неопределено;
					КонецЕсли;
				КонецЕсли;
				
			Иначе
				
				// Регистр записываем не набором записей.
				Если НеЗамещатьОбъект Или СтруктураСвойств.Периодический Тогда
					
					// Возможно мы не хотим замещать существующую запись, либо нужна проверка на дату запрета.
					ВременныйНаборЗаписей = РегистрыСведений[СтруктураСвойств.Имя].СоздатьНаборЗаписей();
					
					// Нужно отбор установить у регистра.
					Для Каждого ЭлементОтбора Из ВременныйНаборЗаписей.Отбор Цикл
						
						ЭлементОтбора.Установить(Объект[ЭлементОтбора.Имя]);
						
					КонецЦикла;
					
					ВременныйНаборЗаписей.Прочитать();
					
					Если ВременныйНаборЗаписей.Количество() > 0
						Или ЗапретИзмененияДанныхПоДате(ВременныйНаборЗаписей) Тогда
						Возврат Неопределено;
					КонецЕсли;
					
				Иначе
					// Считаем что объект следует записать.
					НужноЗаписатьОбъект = Истина;
					
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		ЭтоСсылочныйТипОбъекта = НЕ( ИмяТипаОбъекта = "РегистрСведений"
		ИЛИ ИмяТипаОбъекта = "Константы"
		ИЛИ ИмяТипаОбъекта = "Перечисление");
		
		Если ЭтоСсылочныйТипОбъекта Тогда 
			
			ПровестиГенерациюКодаНомераПриНеобходимости(ГенерироватьНовыйНомерИлиКодЕслиНеУказан, Объект, ИмяТипаОбъекта, 
				НужноЗаписатьОбъект, ЗагружатьДанныеВРежимеОбмена);
			
			Если ПометкаУдаления = Неопределено Тогда
				ПометкаУдаления = Ложь;
			КонецЕсли;
			
			Если Объект.ПометкаУдаления <> ПометкаУдаления Тогда
				Объект.ПометкаУдаления = ПометкаУдаления;
				НужноЗаписатьОбъект = Истина;
			КонецЕсли;
			
		КонецЕсли;
		
		// Непосредственная запись самого объекта.
		Если НужноЗаписатьОбъект Тогда
			
			ЗаписатьОбъектВИБ(Объект, ТипОбъекта);
			
		КонецЕсли;
		
		Если ЭтоСсылочныйТипОбъекта Тогда
			
			ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, Объект.Ссылка);
			
		КонецЕсли;
		
		УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
		
	КонецЕсли;
	
	// SimplyUNF --
	Возврат Объект;
	
	////////////////////////////////////////////////////////////////////////////////////////
	
	#Область СтараяЛогика
	
	//Пока ФайлОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ФайлОбмена.ЛокальноеИмя;
	//			
	//	Если ИмяУзла = "Свойство"
	//		ИЛИ ИмяУзла = "ЗначениеПараметра" Тогда
	//		
	//		ЭтоПараметрДляОбъекта = (ИмяУзла = "ЗначениеПараметра");
	//		
	//		Если НЕ ЭтоПараметрДляОбъекта
	//			И Объект = Неопределено Тогда
	//			
	//			// Объект не нашли и не создали - попробуем сейчас это сделать.
	//			ОбъектНайден = Ложь;

	//		    // Обработчик события ПриЗагрузкеОбъекта.
	//			Если ЕстьОбработчикПриЗагрузке Тогда
	//				
	//				// Если есть обработчик при загрузке, то объект нужно перезаписывать, так как могут быть изменения.
	//				НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
	//  				ОбъектМодифицирован = Истина;
	//									
	//				Попытка
	//					
	//					Если ФлагРежимОтладкиОбработчиков Тогда
	//						
	//						Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПриЗагрузке"));
	//						
	//					Иначе
	//						
	//						Выполнить(Правило.ПриЗагрузке);
	//					
	//					КонецЕсли;
	//					НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
	//					
	//				Исключение
	//					
	//					ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(20, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ИмяПравила, Источник,
	//						ТипОбъекта, Объект, "ПриЗагрузкеОбъекта");
	//					
	//				КонецПопытки;
	//				
	//			КонецЕсли;

	//			// Так м не смогли создать объект в событии - создаем его отдельно.
	//			Если Объект = Неопределено Тогда
	//				
	//				НужноЗаписатьОбъект = Истина;
	//				
	//				Если ИмяТипаОбъекта = "Константы" Тогда
	//					
	//					Объект = Константы.СоздатьНабор();
	//					Объект.Прочитать();
	//					
	//				Иначе
	//					
	//					СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, Объект, Ложь, НаборЗаписей, , НППСсылки, НППГлобальнойСсылки, ПараметрыОбъекта);
	//											
	//				КонецЕсли;
	//				
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//		
	//		Имя                = одАтрибут(ФайлОбмена, одТипСтрока, "Имя");
	//		НеЗамещатьСвойство = одАтрибут(ФайлОбмена, одТипБулево, "НеЗамещать");
	//		ИмяПКО             = одАтрибут(ФайлОбмена, одТипСтрока, "ИмяПКО");
	//		
	//		Если НЕ ЭтоПараметрДляОбъекта
	//			И ((ОбъектНайден И НеЗамещатьСвойство) 
	//			ИЛИ (Имя = "ЭтоГруппа")
	//			ИЛИ (Объект[Имя] = NULL)) Тогда
	//			
	//			// неизвестное свойство
	//			одПропустить(ФайлОбмена, ИмяУзла);
	//			Продолжить;
	//			
	//		КонецЕсли; 

	//		
	//		// Читаем и устанавливаем значение свойства.
	//		ТипСвойства = ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, Имя);
	//		Значение    = ПрочитатьСвойство(ТипСвойства, ИмяПКО);
	//		
	//		Если ЭтоПараметрДляОбъекта Тогда
	//			
	//			// Дополняем коллекцию параметров объекта.
	//			ДобавитьПараметрПриНеобходимости(ПараметрыОбъекта, Имя, Значение);
	//			
	//		Иначе
	//		
	//			Если Имя = "ПометкаУдаления" Тогда
	//				
	//				ПометкаУдаления = Значение;
	//				
	//				Если Объект.ПометкаУдаления <> ПометкаУдаления Тогда
	//					Объект.ПометкаУдаления = ПометкаУдаления;
	//					НужноЗаписатьОбъект = Истина;
	//				КонецЕсли;
	//									
	//			Иначе
	//				
	//				Попытка
	//					
	//					Если Не НужноЗаписатьОбъект Тогда
	//						
	//						НужноЗаписатьОбъект = (Объект[Имя] <> Значение);
	//						
	//					КонецЕсли;
	//					
	//					Объект[Имя] = Значение;
	//					
	//				Исключение
	//					
	//					ЗП = ПолучитьСтруктуруЗаписиПротокола(26, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	//					ЗП.ИмяПКО           = ИмяПравила;
	//					ЗП.НПП              = НПП;
	//					ЗП.ГНПП             = ГНПП;
	//					ЗП.Источник         = Источник;
	//					ЗП.Объект           = Объект;
	//					ЗП.ТипОбъекта       = ТипОбъекта;
	//					ЗП.Свойство         = Имя;
	//					ЗП.Значение         = Значение;
	//					ЗП.ТипЗначения      = ТипЗнч(Значение);
	//					СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(26, ЗП, Истина);
	//					
	//					Если Не ФлагРежимОтладки Тогда
	//						ВызватьИсключение СтрокаСообщенияОбОшибке;
	//					КонецЕсли;
	//					
	//				КонецПопытки;					
	//								
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//		
	//	ИначеЕсли ИмяУзла = "Ссылка" Тогда
	//		
	//		// Ссылка на элемент - сначала получаем по ссылке объект, а потом устанавливаем свойства.
	//		СозданныйОбъект = Неопределено;
	//		НеСоздаватьОбъектЕслиНеНайден = Неопределено;
	//		ИзвестнаяСсылкаУникальногоИдентификатора = Неопределено;
	//		
	//		Ссылка = НайтиОбъектПоСсылке(ТипОбъекта,
	//							ИмяПравила, 
	//							СвойстваПоиска,
	//							СвойстваПоискаНеЗамещать,
	//							ОбъектНайден,
	//							СозданныйОбъект,
	//							НеСоздаватьОбъектЕслиНеНайден,
	//							Истина,
	//							СвойстваОбъектаМодифицированы,
	//							НППГлобальнойСсылки,
	//							НППСсылки,
	//							ИзвестнаяСсылкаУникальногоИдентификатора,
	//							ПараметрыОбъекта);
	//		
	//		НужноЗаписатьОбъект = НужноЗаписатьОбъект ИЛИ СвойстваОбъектаМодифицированы;
	//		
	//		Если Ссылка = Неопределено
	//			И НеСоздаватьОбъектЕслиНеНайден = Истина Тогда
	//			
	//			одПропустить(ФайлОбмена, "Объект");
	//			Прервать;
	//		
	//		ИначеЕсли ИмяТипаОбъекта = "Перечисление" Тогда
	//			
	//			Объект = Ссылка;
	//		
	//		Иначе
	//			
	//			Объект = ПолучитьОбъектПоСсылкеИДопИнформации(СозданныйОбъект, Ссылка);
	//			
	//			Если ОбъектНайден И НеЗамещатьОбъект И (Не ЕстьОбработчикПриЗагрузке) Тогда
	//				
	//				одПропустить(ФайлОбмена, "Объект");
	//				Прервать;
	//				
	//			КонецЕсли;
	//			
	//			Если Ссылка = Неопределено Тогда
	//				
	//				ДополнитьСтекНеЗаписанныхОбъектов(НПП, ГНПП, СозданныйОбъект, ИзвестнаяСсылкаУникальногоИдентификатора, ТипОбъекта, ПараметрыОбъекта);
	//				
	//			КонецЕсли;
	//						
	//		КонецЕсли; 
	//		
	//	    // Обработчик события ПриЗагрузкеОбъекта.
	//		Если ЕстьОбработчикПриЗагрузке Тогда
	//			
	//			НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
	//  			ОбъектМодифицирован = Истина;
	//			
	//			Попытка
	//				
	//				Если ФлагРежимОтладкиОбработчиков Тогда
	//					
	//					Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПриЗагрузке"));
	//					
	//				Иначе
	//					
	//					Выполнить(Правило.ПриЗагрузке);
	//					
	//				КонецЕсли;
	//				
	//				НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
	//				
	//			Исключение
	//				УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
	//				ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(20, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ИмяПравила, Источник, 
	//						ТипОбъекта, Объект, "ПриЗагрузкеОбъекта");
	//				
	//			КонецПопытки;
	//			
	//			Если ОбъектНайден И НеЗамещатьОбъект Тогда
	//				
	//				одПропустить(ФайлОбмена, "Объект");
	//				Прервать;
	//				
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//		
	//	ИначеЕсли ИмяУзла = "ТабличнаяЧасть"
	//		ИЛИ ИмяУзла = "НаборЗаписей" Тогда

	//		Если Объект = Неопределено Тогда
	//			
	//			ОбъектНайден = Ложь;

	//		    // Обработчик события ПриЗагрузкеОбъекта.
	//			
	//			Если ЕстьОбработчикПриЗагрузке Тогда
	//				
	//				НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
	//  				ОбъектМодифицирован = Истина;
	//				
	//				Попытка
	//					
	//					Если ФлагРежимОтладкиОбработчиков Тогда
	//						
	//						Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПриЗагрузке"));
	//						
	//					Иначе
	//						
	//						Выполнить(Правило.ПриЗагрузке);
	//						
	//					КонецЕсли;
	//					
	//					НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
	//					
	//				Исключение
	//					УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
	//					ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(20, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ИмяПравила, Источник, 
	//						ТипОбъекта, Объект, "ПриЗагрузкеОбъекта");
	//					
	//				КонецПопытки;
	//				
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//		
	//		Имя                = одАтрибут(ФайлОбмена, одТипСтрока, "Имя");
	//		НеЗамещатьСвойство = одАтрибут(ФайлОбмена, одТипБулево, "НеЗамещать");
	//		НеОчищать          = одАтрибут(ФайлОбмена, одТипБулево, "НеОчищать");

	//		Если ОбъектНайден И НеЗамещатьСвойство Тогда
	//			
	//			одПропустить(ФайлОбмена, ИмяУзла);
	//			Продолжить;
	//			
	//		КонецЕсли;
	//		
	//		Если Объект = Неопределено Тогда
	//				
	//			СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, Объект, Ложь, НаборЗаписей, , НППСсылки, НППГлобальнойСсылки, ПараметрыОбъекта);
	//			НужноЗаписатьОбъект = Истина;
	//								
	//		КонецЕсли;
	//		
	//		Если ИмяУзла = "ТабличнаяЧасть" Тогда
	//			
	//			// Загрузка элементов из табличной части.
	//			ЗагрузитьТабличнуюЧасть(Объект, Имя, Не НеОчищать, ИнформацияОТипах, НужноЗаписатьОбъект, ПараметрыОбъекта, Правило);
	//			
	//		ИначеЕсли ИмяУзла = "НаборЗаписей" Тогда
	//			
	//			// загрузка движений
	//			ЗагрузитьДвижения(Объект, Имя, Не НеОчищать, ИнформацияОТипах, НужноЗаписатьОбъект, ПараметрыОбъекта, Правило);
	//			
	//		КонецЕсли;			
	//		
	//	ИначеЕсли (ИмяУзла = "Объект") И (ФайлОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//		Отказ = Ложь;
	//		
	//	    // Глобальный обработчик события ПослеЗагрузкиОбъекта.
	//		Если ЕстьГлобальныйОбработчикПослеЗагрузкиОбъекта Тогда
	//			
	//			НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
	//  			ОбъектМодифицирован = Истина;
	//			
	//			Попытка
	//				
	//				Если ФлагРежимОтладкиОбработчиков Тогда
	//					
	//					Выполнить(ПолучитьСтрокуВызоваОбработчика(Конвертация, "ПослеЗагрузкиОбъекта"));
	//					
	//				Иначе
	//					
	//					Выполнить(Конвертация.ПослеЗагрузкиОбъекта);
	//					
	//				КонецЕсли;
	//				
	//				НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
	//				
	//			Исключение
	//				
	//				УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
	//				
	//				ИмяОбработчика = НСтр("ru = '%1 (глобальный)'");
	//				ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(54, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), 
	//						ИмяПравила, Источник, ТипОбъекта, Объект,
	//						ПодставитьПараметрыВСтроку(ИмяОбработчика, "ПослеЗагрузкиОбъекта"));
	//				
	//			КонецПопытки;
	//			
	//		КонецЕсли;
	//		
	//		// Обработчик события ПослеЗагрузкиОбъекта.
	//		Если ЕстьОбработчикПослеЗагрузки Тогда
	//			
	//			НужноБылоЗаписатьОбъект = НужноЗаписатьОбъект;
	//			ОбъектМодифицирован = Истина;
	//			
	//			Попытка
	//				
	//				Если ФлагРежимОтладкиОбработчиков Тогда
	//					
	//					Выполнить(ПолучитьСтрокуВызоваОбработчика(Правило, "ПослеЗагрузки"));
	//					
	//				Иначе
	//					
	//					Выполнить(Правило.ПослеЗагрузки);
	//			
	//				КонецЕсли;
	//				
	//				НужноЗаписатьОбъект = ОбъектМодифицирован ИЛИ НужноБылоЗаписатьОбъект;
	//				
	//			Исключение
	//				УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
	//				ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(21, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ИмяПравила, Источник,
	//											ТипОбъекта, Объект, "ПослеЗагрузкиОбъекта");
	//					
	//			КонецПопытки;
	//			
	//		КонецЕсли;
	//		
	//		Если ИмяТипаОбъекта <> "РегистрСведений"
	//			И ИмяТипаОбъекта <> "Константы"
	//			И ИмяТипаОбъекта <> "Перечисление" Тогда
	//			// Проверка даты запрета для всех объектов кроме регистров сведений и констант.
	//			Отказ = Отказ Или ЗапретИзмененияДанныхПоДате(Объект);
	//		КонецЕсли;
	//		
	//		Если Отказ Тогда
	//			
	//			ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, Неопределено);
	//			УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
	//			Возврат Неопределено;
	//			
	//		КонецЕсли;
	//		
	//		Если ИмяТипаОбъекта = "Документ" Тогда
	//			
	//			Если РежимЗаписи = "Проведение" Тогда
	//				
	//				РежимЗаписи = РежимЗаписиДокумента.Проведение;
	//				
	//			Иначе
	//				
	//				РежимЗаписи = ?(РежимЗаписи = "ОтменаПроведения", РежимЗаписиДокумента.ОтменаПроведения, РежимЗаписиДокумента.Запись);
	//				
	//			КонецЕсли;
	//			
	//			
	//			РежимПроведения = ?(РежимПроведения = "Оперативный", РежимПроведенияДокумента.Оперативный, РежимПроведенияДокумента.Неоперативный);
	//			

	//			// Если хотим провести документ помеченный на удаление, то пометку удаления снимаем ...
	//			Если Объект.ПометкаУдаления
	//				И (РежимЗаписи = РежимЗаписиДокумента.Проведение) Тогда
	//				
	//				Объект.ПометкаУдаления = Ложь;
	//				НужноЗаписатьОбъект = Истина;
	//				
	//				// Пометку удаления в любом случае нужно удалять.
	//				ПометкаУдаления = Ложь;
	//								
	//			КонецЕсли;				
	//			
	//			Попытка
	//				
	//				НужноЗаписатьОбъект = НужноЗаписатьОбъект ИЛИ (РежимЗаписи <> РежимЗаписиДокумента.Запись);
	//				
	//				РежимОбменДанными = РежимЗаписи = РежимЗаписиДокумента.Запись;
	//				
	//				ПровестиГенерациюКодаНомераПриНеобходимости(ГенерироватьНовыйНомерИлиКодЕслиНеУказан, Объект, 
	//					ИмяТипаОбъекта, НужноЗаписатьОбъект, РежимОбменДанными);
	//				
	//				Если НужноЗаписатьОбъект Тогда
	//				
	//					УстановитьОбменДаннымиЗагрузка(Объект, РежимОбменДанными);
	//					Если Объект.Проведен Тогда
	//						Объект.ПометкаУдаления = Ложь;
	//					КонецЕсли;
	//					
	//					Объект.Записать(РежимЗаписи, РежимПроведения);
	//					
	//				КонецЕсли;					
	//					
	//			Исключение
	//					
	//				// Не смогли выполнить необходимые действия для документа.
	//				ЗаписатьДокументВБезопасномРежиме(Объект, ТипОбъекта);
	//					
	//					
	//				ЗП                        = ПолучитьСтруктуруЗаписиПротокола(25, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	//				ЗП.ИмяПКО                 = ИмяПравила;
	//					
	//				Если Не ПустаяСтрока(Источник) Тогда
	//						
	//					ЗП.Источник           = Источник;
	//						
	//				КонецЕсли;
	//					
	//				ЗП.ТипОбъекта             = ТипОбъекта;
	//				ЗП.Объект                 = Строка(Объект);
	//				ЗаписатьВПротоколВыполнения(25, ЗП);
	//					
	//			КонецПопытки;
	//			
	//			ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, Объект.Ссылка);
	//								
	//			УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
	//			
	//		ИначеЕсли ИмяТипаОбъекта <> "Перечисление" Тогда
	//			
	//			Если ИмяТипаОбъекта = "РегистрСведений" Тогда
	//				
	//				НужноЗаписатьОбъект = НЕ ЗаписыватьВИнформационнуюБазуТолькоИзмененныеОбъекты;
	//				
	//				Если СтруктураСвойств.Периодический 
	//					И Не ЗначениеЗаполнено(Объект.Период) Тогда
	//					
	//					Объект.Период = ТекущаяДатаСеанса();
	//					НужноЗаписатьОбъект = Истина;
	//					
	//				КонецЕсли;
	//				
	//				Если ЗаписыватьРегистрыНаборамиЗаписей Тогда
	//					
	//					НужноПроверитьДанныеДляВременногоНабора = 
	//						(ЗаписыватьВИнформационнуюБазуТолькоИзмененныеОбъекты
	//							И НЕ НужноЗаписатьОбъект) 
	//						ИЛИ НеЗамещатьОбъект;
	//					
	//					Если НужноПроверитьДанныеДляВременногоНабора Тогда
	//						
	//						ВременныйНаборЗаписей = РегистрыСведений[СтруктураСвойств.Имя].СоздатьНаборЗаписей();
	//						
	//					КонецЕсли;
	//					
	//					// Нужно отбор установить у регистра.
	//					Для Каждого ЭлементОтбора Из НаборЗаписей.Отбор Цикл
	//						
	//						ЭлементОтбора.Установить(Объект[ЭлементОтбора.Имя]);
	//						Если НужноПроверитьДанныеДляВременногоНабора Тогда
	//							УстановитьЗначениеЭлементаОтбора(ВременныйНаборЗаписей.Отбор, ЭлементОтбора.Имя, Объект[ЭлементОтбора.Имя]);
	//						КонецЕсли;
	//						
	//					КонецЦикла;
	//					
	//					Если НужноПроверитьДанныеДляВременногоНабора Тогда
	//						
	//						ВременныйНаборЗаписей.Прочитать();
	//						
	//						Если ВременныйНаборЗаписей.Количество() = 0 Тогда
	//							НужноЗаписатьОбъект = Истина;
	//						Иначе
	//							
	//							// Не хотим замещать существующий набор.
	//							Если НеЗамещатьОбъект Тогда
	//								Возврат Неопределено;
	//							КонецЕсли;
	//							
	//							НужноЗаписатьОбъект = Ложь;
	//							ТаблицаНовая = НаборЗаписей.Выгрузить(); // ТаблицаЗначений
	//							ТаблицаСтарая = ВременныйНаборЗаписей.Выгрузить(); 
	//							
	//							СтрокаНовая = ТаблицаНовая[0]; 
	//							СтрокаСтарая = ТаблицаСтарая[0]; 
	//							
	//							Для Каждого КолонкаТаблицы Из ТаблицаНовая.Колонки Цикл
	//								
	//								НужноЗаписатьОбъект = СтрокаНовая[КолонкаТаблицы.Имя] <>  СтрокаСтарая[КолонкаТаблицы.Имя];
	//								Если НужноЗаписатьОбъект Тогда
	//									Прервать;
	//								КонецЕсли;
	//								
	//							КонецЦикла;
	//							
	//						КонецЕсли;
	//						
	//					КонецЕсли;
	//					
	//					Объект = НаборЗаписей;
	//					
	//					Если СтруктураСвойств.Периодический Тогда
	//						// Проверка даты запрета изменения для набора записей.
	//						// Если не проходит - не записывать набор.
	//						Если ЗапретИзмененияДанныхПоДате(Объект) Тогда
	//							Возврат Неопределено;
	//						КонецЕсли;
	//					КонецЕсли;
	//					
	//				Иначе
	//					
	//					// Регистр записываем не набором записей.
	//					Если НеЗамещатьОбъект Или СтруктураСвойств.Периодический Тогда
	//						
	//						// Возможно мы не хотим замещать существующую запись, либо нужна проверка на дату запрета.
	//						ВременныйНаборЗаписей = РегистрыСведений[СтруктураСвойств.Имя].СоздатьНаборЗаписей();
	//						
	//						// Нужно отбор установить у регистра.
	//						Для Каждого ЭлементОтбора Из ВременныйНаборЗаписей.Отбор Цикл
	//						
	//							ЭлементОтбора.Установить(Объект[ЭлементОтбора.Имя]);
	//															
	//						КонецЦикла;
	//						
	//						ВременныйНаборЗаписей.Прочитать();
	//						
	//						Если ВременныйНаборЗаписей.Количество() > 0
	//							Или ЗапретИзмененияДанныхПоДате(ВременныйНаборЗаписей) Тогда
	//							Возврат Неопределено;
	//						КонецЕсли;
	//						
	//					Иначе
	//						// Считаем что объект следует записать.
	//						НужноЗаписатьОбъект = Истина;
	//					КонецЕсли;
	//					
	//				КонецЕсли;
	//				
	//			КонецЕсли;
	//			
	//			ЭтоСсылочныйТипОбъекта = НЕ( ИмяТипаОбъекта = "РегистрСведений"
	//				ИЛИ ИмяТипаОбъекта = "Константы"
	//				ИЛИ ИмяТипаОбъекта = "Перечисление");
	//				
	//			Если ЭтоСсылочныйТипОбъекта Тогда 	
	//				
	//				ПровестиГенерациюКодаНомераПриНеобходимости(ГенерироватьНовыйНомерИлиКодЕслиНеУказан, Объект, ИмяТипаОбъекта, НужноЗаписатьОбъект, ЗагружатьДанныеВРежимеОбмена);
	//				
	//				Если ПометкаУдаления = Неопределено Тогда
	//					ПометкаУдаления = Ложь;
	//				КонецЕсли;
	//				
	//				Если Объект.ПометкаУдаления <> ПометкаУдаления Тогда
	//					Объект.ПометкаУдаления = ПометкаУдаления;
	//					НужноЗаписатьОбъект = Истина;
	//				КонецЕсли;
	//				
	//			КонецЕсли;
	//			
	//			// Непосредственная запись самого объекта.
	//			Если НужноЗаписатьОбъект Тогда
	//			
	//				ЗаписатьОбъектВИБ(Объект, ТипОбъекта);
	//				
	//			КонецЕсли;
	//			
	//			Если ЭтоСсылочныйТипОбъекта Тогда
	//				
	//				ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, Объект.Ссылка);
	//				
	//			КонецЕсли;
	//			
	//			УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП);
	//							
	//		КонецЕсли;
	//		
	//		Прервать;
	//		
	//	ИначеЕсли ИмяУзла = "НаборЗаписейПоследовательности" Тогда
	//		
	//		одПропустить(ФайлОбмена);
	//		
	//	ИначеЕсли ИмяУзла = "Типы" Тогда

	//		Если Объект = Неопределено Тогда
	//			
	//			ОбъектНайден = Ложь;
	//			Ссылка       = СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, Объект, , , , НППСсылки, НППГлобальнойСсылки, ПараметрыОбъекта);
	//							
	//		КонецЕсли; 

	//		ОписаниеТиповОбъекта = ЗагрузитьТипыОбъекта(ФайлОбмена);

	//		Если ОписаниеТиповОбъекта <> Неопределено Тогда
	//			
	//			Объект.ТипЗначения = ОписаниеТиповОбъекта;
	//			
	//		КонецЕсли; 
	//		
	//	Иначе
	//		
	//		ЗаписатьВПротоколВыполнения(9);
	//		Прервать;
	//		
	//	КонецЕсли;
	//	
	//КонецЦикла;
	//
	//Возврат Объект;
	
	#КонецОбласти

КонецФункции

// Синтез типовых процедур выгрузки и загрузки свойств.
//
// Параметры:
//   Объект - ДокументОбъект, СправочникОбъект, Структура - объект который наполняется свойствами.
//   Добавлен для возможного использования в обработчиках ПКС (Перед/При/ПослеЗагрузки).
//   ПКС - СтрокаТаблицыЗначений - описание правила конвертации свойства определенного ПКО.
//   ДанныеСвойства - Произвольный - "сырые данные" свойства которые нужно конвертировать/обработать.
//   НеЗамещатьСвойство - Булево - может быть переопределено в обработчиках ПКС.
//   ИнформацияОТипах - Структура - содержит описание типов для каждого свойства приемника
//
Функция ПрочитатьСвойство_2(Объект, ПКС, Знач ДанныеСвойства, НеЗамещатьСвойство, ИнформацияОТипах, Знач ПКОРодитель) 
	
	// Контейнер свойств - это соответствие. Ключ - имя свойства в источнике. Значение - значение свойства в источнике. 
	// Если ключ был не найден - будет Неопределено. Это отсекается на предыдущем этапе в "ПрочитатьОбъект".
	// Также, само значение может быть Неопределено.
	// Ситуация неоднозначная.
	// Поэтому, на стороне отправителя, Неопределено будем передавать как строку "_ТипНеопределено".
	Если ТипЗнч(ДанныеСвойства) = Тип("Строка") И ДанныеСвойства = "_ТипНеопределено" Тогда
		ДанныеСвойства = Неопределено;
	КонецЕсли;
	
	Имя = ПКС.Приемник; // Переопределяем. Это имя свойства уже в приемнике.
	ТипИсточникаСтрокой = ?(ЗначениеЗаполнено(ПКС.ТипИсточника), ПКС.ТипИсточника, "");
	ТипПриемникаСтрокой = ?(ЗначениеЗаполнено(ПКС.ТипПриемника), ПКС.ТипПриемника, "");
	
	ИмяПКО = ?(Значениезаполнено(ПКС.ПравилоКонвертации), СокрЛП(ПКС.ПравилоКонвертации.Код), "");
	
	// Получим описание типов свойства приемника.
	отСвойства = ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, Имя);
	
	// Обработка упрощенной загрузки:
	// Отсутсвуют обработчики ПКС и совпадают типы даных источника и приемника и это простой тип даных (число, строка, дата, булево)
	Если ПКС.УпрощеннаяЗагрузкаСвойства И ДанныеСвойства <> Неопределено Тогда 
		
		Если отСвойства.СодержитТип(одТипДата) 
			И ТипИсточникаСтрокой = "Дата" 
			И ТипЗнч(ДанныеСвойства) = одТипСтрока Тогда // Для дат отдельный случай
			
			Значение = ПрочитатьДатуJSON(ДанныеСвойства, ФорматДатыJSON.ISO);
		Иначе
			Значение = ДанныеСвойства;
		КонецЕсли;
		
		Если ПКС.ПоискПоДатеНаРавенство Тогда
			// to do: доработать!
		КонецЕсли;
		
		Если ПКС.ПриводитьКДлине <> 0 Тогда
			
			ВыполнитьПриведениеЗначенияКДлине(Значение, ПКС);
			
		КонецЕсли;
		
		Возврат Значение;
		
	КонецЕсли;
	
	// to do: доработать для случая, если это передача уникального идентификатора в уникальный идентификатор
	
	// Инициализируем значение, которое будем конвертировать:
	Значение  = Неопределено;
	Пусто     = Ложь; // для записи пустого значения определенного типа
	Выражение = Неопределено; // для выполнения выражения определенного в обработчике
	ЭтоNULL   = Ложь;
	
	// Обработчики ПКС:
	
	// Обработчик ПередЗагрузкой
	Если ПКС.ЕстьОбработчикПередЗагрузкой Тогда
		
		Отказ = Ложь;
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			
			//Выполнить(ПолучитьСтрокуВызоваОбработчика(ПКС, "ПередВыгрузкой"));
			
			//Иначе
			
			Выполнить(ПКС.ПередЗагрузкой);
			
			//КонецЕсли;
			
		Исключение
			
			ЗаписатьИнформациюОбОшибкеОбработчикиПКС(55, ОписаниеОшибки(), ПКОРодитель, ПКС, ДанныеСвойства, 
					"ПередЗагрузкойСвойства", Значение);
			
		КонецПопытки;
		
		Если Отказ Тогда // Отказ от загрузки свойства
			
			НеЗамещатьСвойство = Истина;
			Возврат Значение;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ПКС.ПоискПоДатеНаРавенство Тогда
		// to do: доработать!
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ИмяПКО) Тогда
		ПКОСвойств = Правила[ИмяПКО];
	Иначе
		ПКОСвойств = Неопределено;
	КонецЕсли;
	
	Если Выражение <> Неопределено Тогда
		
		Значение = Вычислить(Выражение);
		
		Возврат Значение;
		
	ИначеЕсли Пусто Тогда
		
		Если ПКОСвойств <> Неопределено Тогда
			ТипСвойстваСтрокой = ПКОСвойств.Приемник;
			ТипСвойства = Тип(ТипСвойстваСтрокой);
		ИначеЕсли НЕ ПустаяСтрока(ТипПриемникаСтрокой) И отСвойства.СодержитТип(Тип(ТипПриемникаСтрокой)) Тогда
			ТипСвойства = Тип(ТипПриемникаСтрокой);
		Иначе
			
			мТипыСвойства = отСвойства.Типы();
			ТипСвойства = мТипыСвойства[0];
			
		КонецЕсли;
		
		Значение = одПолучитьПустоеЗначение(ТипСвойства);
		Возврат Значение;
		
	Иначе
		
		// Основное чтение свойства:
		Если НЕ отСвойства.СодержитТип(ТипЗнч(Значение)) Тогда // Возможно раннее значение было определено в обработчике
			Значение = ПрочитатьСвойство(отСвойства, ИмяПКО, ДанныеСвойства, ТипПриемникаСтрокой, ТипИсточникаСтрокой);
		КонецЕсли;
		
		Если ПКС.ПриводитьКДлине <> 0 Тогда
			
			ВыполнитьПриведениеЗначенияКДлине(Значение, ПКС);
			
		КонецЕсли;
		
	КонецЕсли;
	
	СтароеЗначениеДоОбработчикаПриЗагрузке = Значение;
	Пусто = одПустое(Значение, ЭтоNULL);
	
	// Обработчик ПриЗагрузке
	Если ПКС.ЕстьОбработчикПриЗагрузке Тогда
		
		Отказ = Ложь;
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(ПКС, "ПриВыгрузке"));
			//	
			//Иначе
				
				Выполнить(ПКС.ПриЗагрузке);
				
			//КонецЕсли;
			
		Исключение
			
			ЗаписатьИнформациюОбОшибкеОбработчикиПКС(56, ОписаниеОшибки(), ПКОРодитель, ПКС, ДанныеСвойства, 
			"ПриЗагрузкеСвойства", Значение);
			
		КонецПопытки;
		
		Если Отказ Тогда // Отказ от загрузки свойства
			
			НеЗамещатьСвойство = Истина;
			Возврат Значение;
			
		КонецЕсли;
	КонецЕсли;
	
	// Инициализируем еще раз переменную Пусто, может быть Значение было изменено 
	// в обработчике "При выгрузке"
	Если СтароеЗначениеДоОбработчикаПриЗагрузке <> Значение Тогда
		Пусто = одПустое(Значение, ЭтоNULL);
	КонецЕсли;
	
	Если Пусто Тогда
		Возврат Значение;
	КонецЕсли;
	
	// Обработчик ПослеЗагрузки
	Если ПКС.ЕстьОбработчикПослеЗагрузки Тогда
		
		Отказ = Ложь;
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(ПКС, "ПослеВыгрузки"));
			//	
			//Иначе
				
				Выполнить(ПКС.ПослеВыгрузки);
				
			//КонецЕсли;
			
		Исключение
			
			ЗаписатьИнформациюОбОшибкеОбработчикиПКС(57, ОписаниеОшибки(), ПКОРодитель, ПКС, ДанныеСвойства, 
			"ПослеЗагрузкиСвойства", Значение);
			
		КонецПопытки;
		
		Если Отказ Тогда // Отказ от загрузки свойства
			
			НеЗамещатьСвойство = Истина;
			Возврат Значение;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции //ПрочитатьСвойство_2

Процедура ВыполнитьПриведениеЗначенияКДлине(Значение, ПКС)
	
	Значение = ПривестиНомерКДлине(Строка(Значение), ПКС.ПриводитьКДлине);
		
КонецПроцедуры

// Приводит номер (код) к требуемой длине. При этом выделяется префикс
// и числовая часть номера, остальное пространство между префиксом и
// номером заполняется нулями.
// Функция может быть использована в обработчиках событий, программный код 
// которых хранится в правила обмена данными. Вызывается методом Выполнить()
// Сообщение "Не обнаружено ссылок на функцию" при проверке конфигурации 
// не является ошибкой проверки конфигурации
//
// Параметры:
//  Стр          - преобразовываемая строка;
//  Длина        - требуемая длина строки.
//
// Возвращаемое значение:
//  Строка       - код или номер, приведенная к требуемой длине.
// 
Функция ПривестиНомерКДлине(Знач Стр, Длина, ДобавлятьНулиЕслиДлинаНеМеньшеТекущейДлиныНомера = Истина, Префикс = "") Экспорт

	Если ПустаяСтрока(Стр)
		ИЛИ СтрДлина(Стр) = Длина Тогда
		
		Возврат Стр;
		
	КонецЕсли;
	
	Стр             = СокрЛП(Стр);
	ВходящаяДлинаНомера = СтрДлина(Стр);

	ЧисловаяЧасть   = "";
	ПрефиксНомераСтроки   = ПолучитьПрефиксЧислоНомера(Стр, ЧисловаяЧасть);
	
	ИтоговыйПрефикс = ?(ПустаяСтрока(Префикс), ПрефиксНомераСтроки, Префикс);
	ДлинаИтоговогоПрефикса = СтрДлина(ИтоговыйПрефикс);
	
	СтрокаЧисловойЧасти = Формат(ЧисловаяЧасть, "ЧГ=0");
	ДлинаЧисловойЧасти = СтрДлина(СтрокаЧисловойЧасти);

	Если (Длина >= ВходящаяДлинаНомера И ДобавлятьНулиЕслиДлинаНеМеньшеТекущейДлиныНомера)
		ИЛИ (Длина < ВходящаяДлинаНомера) Тогда
		
		Для ВременнаяПеременная = 1 По Длина - ДлинаИтоговогоПрефикса - ДлинаЧисловойЧасти Цикл
			
			СтрокаЧисловойЧасти = "0" + СтрокаЧисловойЧасти;
			
		КонецЦикла;
	
	КонецЕсли;
	
	// обрезаем лишние символы
	СтрокаЧисловойЧасти = Прав(СтрокаЧисловойЧасти, Длина - ДлинаИтоговогоПрефикса);
		
	Результат = ИтоговыйПрефикс + СтрокаЧисловойЧасти;

	Возврат Результат;

КонецФункции // ПривестиНомерКДлине()

// Разбирает строку, выделяя из нее префикс и числовую часть.
//
// Параметры:
//  Стр            - Строка. Разбираемая строка;
//  ЧисловаяЧасть  - Число. Переменная, в которую возвратится числовая часть строки;
//  Режим          - Строка. Если "Число", то возвратит числовую часть, иначе - префикс.
//
// Возвращаемое значение:
//  Префикс строки
//
Функция ПолучитьПрефиксЧислоНомера(Знач Стр, ЧисловаяЧасть = "", Режим = "") Экспорт

	ЧисловаяЧасть = 0;
	Префикс = "";
	Стр = СокрЛП(Стр);
	Длина   = СтрДлина(Стр);
	
	СтроковыйНомерБезПрефикса = ПолучитьСтроковыйНомерБезПрефиксов(Стр);
	ДлинаСтроковойЧасти = СтрДлина(СтроковыйНомерБезПрефикса);
	Если ДлинаСтроковойЧасти > 0 Тогда
		ЧисловаяЧасть = Число(СтроковыйНомерБезПрефикса);
		Префикс = Сред(Стр, 1, Длина - ДлинаСтроковойЧасти);
	Иначе
		Префикс = Стр;	
	КонецЕсли;

	Если Режим = "Число" Тогда
		Возврат(ЧисловаяЧасть);
	Иначе
		Возврат(Префикс);
	КонецЕсли;

КонецФункции

// Возвращает строку номера без символьных префиксов
// Например:
//  ПолучитьСтроковыйНомерБезПрефиксов("УТ0000001234") = "0000001234"
//
// Параметры:
//  Номер - Строка - номер, из которого необходимо вычислить результат функции
// 
//  Возвращаемое значение:
//  строка номера без символьных префиксов
//
Функция ПолучитьСтроковыйНомерБезПрефиксов(Номер) Экспорт
	
	НомерБезПрефиксов = "";
	Сч = СтрДлина(Номер);
	
	Пока Сч > 0 Цикл
		
		Символ = Сред(Номер, Сч, 1);
		
		Если (Символ >= "0" И Символ <= "9") Тогда
			
			НомерБезПрефиксов = Символ + НомерБезПрефиксов;
			
		Иначе
			
			Возврат НомерБезПрефиксов;
			
		КонецЕсли;
		
		Сч = Сч - 1;
		
	КонецЦикла;
	
	Возврат НомерБезПрефиксов;
	
КонецФункции

// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение       - значение, заполнение которого надо проверить
//
// Возвращаемое значение:
//  Истина         - значение не заполнено, ложь - иначе.
//
Функция одПустое(Значение, ЭтоNULL=Ложь) Экспорт

	// Сначала примитивные типы
	Если Значение = Неопределено Тогда
		Возврат Истина;
	ИначеЕсли Значение = NULL Тогда
		ЭтоNULL   = Истина;
		Возврат Истина;
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Значение);
	
	//Если ТипЗначения = одТипБулево Тогда
	//	
	//	Возврат НЕ Значение;
		
	//Иначе
	Если ТипЗначения = одТипХранилищеЗначения Тогда
		
		Результат = одПустое(Значение.Получить());
		Возврат Результат;		
		
	ИначеЕсли ТипЗначения = одТипДвоичныеДанные Тогда
		
		Возврат Ложь;
		
	Иначе

		// Для остальных будем считать значение пустым, если оно равно
		// значению по умолчанию своего типа.
		Попытка
			Результат = Не ЗначениеЗаполнено(Значение);
			Возврат Результат;
		Исключение
			Возврат Ложь;
		КонецПопытки;
			
	КонецЕсли;
	
КонецФункции

Функция ПроверитьСуществованиеСсылки(Ссылка, Менеджер, НайденныйОбъектПоУникальномуИдентификатору,
	СтрокаЗапросаПоискаПоУникальномуИдентификатору)
	
	Попытка
			
		Если ПустаяСтрока(СтрокаЗапросаПоискаПоУникальномуИдентификатору) Тогда
			
			НайденныйОбъектПоУникальномуИдентификатору = Ссылка.ПолучитьОбъект();
			
			Если НайденныйОбъектПоУникальномуИдентификатору = Неопределено Тогда
			
				Возврат Менеджер.ПустаяСсылка();
				
			КонецЕсли;
			
		Иначе
			// Это режим поиска по ссылке - достаточно сделать запрос к информационной базе
			// шаблон для запроса СтруктураСвойств.СтрокаПоиска.
			
			Запрос = Новый Запрос();
			Запрос.Текст = СтрокаЗапросаПоискаПоУникальномуИдентификатору + "  Ссылка = &Ссылка ";
			Запрос.УстановитьПараметр("Ссылка", Ссылка);
			
			РезультатЗапроса = Запрос.Выполнить();
			
			Если РезультатЗапроса.Пустой() Тогда
			
				Возврат Менеджер.ПустаяСсылка();
				
			КонецЕсли;
			
		КонецЕсли;
		
		Возврат Ссылка;	
		
	Исключение
			
		Возврат Менеджер.ПустаяСсылка();
		
	КонецПопытки;
	
КонецФункции

// Производит поиск объекта в информационной базе, если не найден создает новый.
//
// Параметры:
//  ДанныеСсылки - Соответствие:
//		* Тип - Строка - тип ссылки источника. Например: "ДокументСсылка.ЗаказПокупателя", "СправочникСсылка.Номенклатура".
//		* Гнпп - Число - глобальный порядковый номер ссылки объекта в рамках пакета загружаемых данных.
//		* УникальныйИдентификатор - Строка - УИД ссылки строкой.
//  ТипОбъекта     - тип искомого объекта приемника.
//  ИмяПКО - Строка - имя правила конвертации объекта.
//  СвойстваПоиска - Структура - содержащая свойства по которым производится поиск объекта.
//  ОбъектНайден   - если Ложь, то объект не найден, а создан новый.
//
// Возвращаемое значение:
//  Новый или найденный объект информационной базы.
//  
Функция НайтиОбъектПоСсылке(ДанныеСсылки,
							ТипОбъекта,
							ИмяПКО = "",
							СвойстваПоиска = "", 
							СвойстваПоискаНеЗамещать = "", 
							ОбъектНайден = Истина, 
							СозданныйОбъект = Неопределено, 
							НеСоздаватьОбъектЕслиНеНайден = Неопределено,
							РежимПоискаОсновногоОбъекта = Ложь, 
							СвойстваОбъектаМодифицированы = Ложь,
							НППГлобальнойСсылки = 0,
							НППСсылки = 0,
							ИзвестнаяСсылкаУникальногоИдентификатора = Неопределено,
							ПараметрыОбъекта = Неопределено)

	Если БезопасныйРежим Тогда
		УстановитьБезопасныйРежим(Истина);
		Для Каждого ИмяРазделителя Из РазделителиКонфигурации Цикл
			УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		КонецЦикла;
	КонецЕсли;
	
	ПоискПоДатеНаРавенство = Ложь;
	СсылкаНаОбъект = Неопределено;
	СтруктураСвойств = Неопределено;
	ИмяТипаОбъекта = Неопределено;
	СсылкаНаОбъектФиктивная = Ложь;
	ПКО = Неопределено;
	АлгоритмПоиска = "";
	
	// SimplyUNF ++
	// повторный поиск ПКО:
	Если НЕ ПустаяСтрока(ИмяПКО) Тогда
		ПКО = Правила[ИмяПКО];
	КонецЕсли;
	
	// SimplyUNF --
	
	Если ЗапоминатьЗагруженныеОбъекты Тогда
		
		// Есть номер по порядку из файла - по нему и ищем.
		НППГлобальнойСсылки = одЗначениеСвойства(ДанныеСсылки, одТипЧисло, "Гнпп");
		
		Если НППГлобальнойСсылки <> 0 Тогда
			
			СсылкаНаОбъект = ОбработатьПоискОбъектаПоСтруктуре(
				НППГлобальнойСсылки, 
				ТипОбъекта, 
				СозданныйОбъект,
				РежимПоискаОсновногоОбъекта, 
				СвойстваОбъектаМодифицированы, 
				ОбъектНайден, 
				Истина, 
				ПараметрыОбъекта, 
				ДанныеСсылки, 
				ИмяПКО);
			
			Если СсылкаНаОбъект <> Неопределено Тогда
				Возврат СсылкаНаОбъект;
			КонецЕсли;
			
		КонецЕсли;
		
		// Есть номер по порядку из файла - по нему и ищем.
		НППСсылки = одЗначениеСвойства(ДанныеСсылки, одТипЧисло, "Нпп");
		
		Если НППСсылки <> 0 Тогда
		
			СсылкаНаОбъект = ОбработатьПоискОбъектаПоСтруктуре(
				НППСсылки, 
				ТипОбъекта, 
				СозданныйОбъект,
				РежимПоискаОсновногоОбъекта, 
				СвойстваОбъектаМодифицированы, 
				ОбъектНайден, 
				Ложь, 
				ПараметрыОбъекта,
				ДанныеСсылки, 
				ИмяПКО);
				
			Если СсылкаНаОбъект <> Неопределено Тогда
				Возврат СсылкаНаОбъект;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	НеСоздаватьОбъектЕслиНеНайден = ПКО.НеСоздаватьЕслиНеНайден;
	ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD = НЕ РежимПоискаОсновногоОбъекта 
		И ПКО.ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD;
	
	// Создаем свойства поиска объектов.
	ПрочитатьИнформациюОСвойствахПоиска(ТипОбъекта, СвойстваПоиска, СвойстваПоискаНеЗамещать, ПоискПоДатеНаРавенство, ПараметрыОбъекта, ДанныеСсылки, ИмяПКО);
		
	СозданныйОбъект = Неопределено;
	
	Если Не ОбъектНайден Тогда
		
		СсылкаНаОбъект = СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, СозданныйОбъект, , , , НППСсылки, НППГлобальнойСсылки);
		ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, СсылкаНаОбъект);
		Возврат СсылкаНаОбъект;
		
	КонецЕсли;	
		
	СтруктураСвойств   = Менеджеры[ТипОбъекта];
	ИмяТипаОбъекта     = СтруктураСвойств.ИмяТипа;
		
	СвойствоУникальныйИдентификатор = СвойстваПоиска["{УникальныйИдентификатор}"];
	СвойствоИмяПредопределенного = СвойстваПоиска["{ИмяПредопределенногоЭлемента}"];
	
	ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD = ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD
		И СвойствоУникальныйИдентификатор <> Неопределено;
		
	// Если это предопределенный элемент ищем по имени.
	Если СвойствоИмяПредопределенного <> Неопределено Тогда
		
		АвтоматическиСоздаватьНовыйОбъект = НЕ НеСоздаватьОбъектЕслиНеНайден
			И НЕ ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD;
		
		СсылкаНаОбъект = НайтиИлиСоздатьОбъектПоСвойству(СтруктураСвойств, ТипОбъекта, СвойстваПоиска, СвойстваПоискаНеЗамещать,
			ИмяТипаОбъекта, "{ИмяПредопределенногоЭлемента}", СвойствоИмяПредопределенного, ОбъектНайден, 
			АвтоматическиСоздаватьНовыйОбъект, СозданныйОбъект, РежимПоискаОсновногоОбъекта, СвойстваОбъектаМодифицированы,
			НППСсылки, НППГлобальнойСсылки, ПараметрыОбъекта);
			
	ИначеЕсли (СвойствоУникальныйИдентификатор <> Неопределено) Тогда
			
		// Не всегда нужно по уникальному идентификатору новый элемент создавать, возможно нужно продолжить поиск.
		НужноПродолжитьПоискЕслиЭлементПоGUIDНеНайден = ОпределитьПоТипуОбъектаИспользоватьДополнительныйПоискПоПолямПоиска(СтруктураСвойств.ТипСсылкиСтрокой);
		
		АвтоматическиСоздаватьНовыйОбъект = (НЕ НеСоздаватьОбъектЕслиНеНайден
			И НЕ НужноПродолжитьПоискЕслиЭлементПоGUIDНеНайден)
			И НЕ ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD;
			
		СсылкаНаОбъект = НайтиИлиСоздатьОбъектПоСвойству(СтруктураСвойств, ТипОбъекта, СвойстваПоиска, СвойстваПоискаНеЗамещать,
			ИмяТипаОбъекта, "{УникальныйИдентификатор}", СвойствоУникальныйИдентификатор, ОбъектНайден, 
			АвтоматическиСоздаватьНовыйОбъект, СозданныйОбъект, 
			РежимПоискаОсновногоОбъекта, СвойстваОбъектаМодифицированы,
			НППСсылки, НППГлобальнойСсылки, ПараметрыОбъекта, ИзвестнаяСсылкаУникальногоИдентификатора);
			
		Если Не НужноПродолжитьПоискЕслиЭлементПоGUIDНеНайден Тогда

			Если Не ЗначениеЗаполнено(СсылкаНаОбъект)
				И ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD Тогда
				
				СсылкаНаОбъект = СтруктураСвойств.Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(СвойствоУникальныйИдентификатор));
				ОбъектНайден = Ложь;
				СсылкаНаОбъектФиктивная = Истина;
			
			КонецЕсли;
			
			Если СсылкаНаОбъект <> Неопределено 
				И СсылкаНаОбъект.Пустая() Тогда
						
				СсылкаНаОбъект = Неопределено;
						
			КонецЕсли;
			
			Если СсылкаНаОбъект <> Неопределено
				ИЛИ СозданныйОбъект <> Неопределено Тогда

				ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, СсылкаНаОбъект, СсылкаНаОбъектФиктивная);
				
			КонецЕсли;
			
			Возврат СсылкаНаОбъект;
			
		КонецЕсли;
		
	КонецЕсли;
		
	Если СсылкаНаОбъект <> Неопределено И СсылкаНаОбъект.Пустая() Тогда
		
		СсылкаНаОбъект = Неопределено;
		
	КонецЕсли;
		
	// СсылкаНаОбъект пока не найден.
	Если СсылкаНаОбъект <> Неопределено ИЛИ СозданныйОбъект <> Неопределено Тогда
		
		ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, СсылкаНаОбъект);
		Возврат СсылкаНаОбъект;
		
	КонецЕсли;
	
	НомерВариантаПоиска = 1;
	СтрокаИменСвойствПоиска = "";
	ПредыдущаяСтрокаПоиска = Неопределено;
	ПрекратитьПоиск = Ложь;
	УстанавливатьУОбъектаВсеСвойстваПоиска = Истина;
	
	Если Не ПустаяСтрока(ИмяПКО) Тогда
		
		ПКО = Правила[ИмяПКО];
		
	КонецЕсли;
	
	Если ПКО = Неопределено Тогда
		
		ПКО = ОпределитьПоТипуОбъектаПриемникаПравилоКонвертацииКотороеСодержитАлгоритмПоиска(СтруктураСвойств.ТипСсылкиСтрокой);
		
	КонецЕсли;
	
	Если ПКО <> Неопределено Тогда
		
		АлгоритмПоиска = ПКО.ПоследовательностьПолейПоиска;
		
	КонецЕсли;
	
	ЕстьАлгоритмПоиска = Не ПустаяСтрока(АлгоритмПоиска);
	
	Пока НомерВариантаПоиска <= 10
		И ЕстьАлгоритмПоиска Цикл
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(ПКО, "ПоследовательностьПолейПоиска"));
			//		
			//Иначе
				
				Выполнить(АлгоритмПоиска);
			
			//КонецЕсли;
			
		Исключение
			
			ЗаписатьИнформациюОбОшибкеЗагрузкиОбработчикаПКО(73, ОписаниеОшибки(), "", "",
				ТипОбъекта, Неопределено, Нстр("ru = 'Последовательность полей поиска'"));
				
		КонецПопытки;
		
		НеНужноВыполнятьПоиск = ПрекратитьПоиск = Истина 
			ИЛИ СтрокаИменСвойствПоиска = ПредыдущаяСтрокаПоиска
			ИЛИ ЗначениеЗаполнено(СсылкаНаОбъект);
		
		Если НЕ НеНужноВыполнятьПоиск Тогда
		
			// сам поиск непосредственно
			СсылкаНаОбъект = НайтиЭлементПоСвойствамПоиска(ТипОбъекта, ИмяТипаОбъекта, СвойстваПоиска, СтруктураСвойств, 
				СтрокаИменСвойствПоиска, ПоискПоДатеНаРавенство);
				
			НеНужноВыполнятьПоиск = ЗначениеЗаполнено(СсылкаНаОбъект);
			
			Если СсылкаНаОбъект <> Неопределено
				И СсылкаНаОбъект.Пустая() Тогда
				СсылкаНаОбъект = Неопределено;
			КонецЕсли;
			
		КонецЕсли;
			
		Если НеНужноВыполнятьПоиск Тогда
			
			Если РежимПоискаОсновногоОбъекта И УстанавливатьУОбъектаВсеСвойстваПоиска = Истина Тогда
				
				ОбработатьУстановкуСвойствПоискаУОбъекта(УстанавливатьУОбъектаВсеСвойстваПоиска, ТипОбъекта, СвойстваПоиска, СвойстваПоискаНеЗамещать,
					СсылкаНаОбъект, СозданныйОбъект, НЕ РежимПоискаОсновногоОбъекта, СвойстваОбъектаМодифицированы);
				
			КонецЕсли;
			
			Прервать;
			
		КонецЕсли;
		
		НомерВариантаПоиска = НомерВариантаПоиска + 1;
		ПредыдущаяСтрокаПоиска = СтрокаИменСвойствПоиска;
		
	КонецЦикла;
	
	Если Не ЕстьАлгоритмПоиска Тогда
		
		// Сам поиск непосредственно и без алгоритма поиска.
		СсылкаНаОбъект = НайтиЭлементПоСвойствамПоиска(ТипОбъекта, ИмяТипаОбъекта, СвойстваПоиска, СтруктураСвойств, 
					СтрокаИменСвойствПоиска, ПоискПоДатеНаРавенство);
		
	КонецЕсли;
	
	ОбъектНайден = ЗначениеЗаполнено(СсылкаНаОбъект);
	
	Если РежимПоискаОсновногоОбъекта
		И ЗначениеЗаполнено(СсылкаНаОбъект)
		И (ИмяТипаОбъекта = "Документ" 
		ИЛИ ИмяТипаОбъекта = "Задача"
		ИЛИ ИмяТипаОбъекта = "БизнесПроцесс") Тогда
		
		// Если у документа дата есть в свойствах поиска - то устанавливаем ее.
		ДатаПустая = Не ЗначениеЗаполнено(СвойстваПоиска["Дата"]);
		МожноЗамещать = (Не ДатаПустая) 
			И (СвойстваПоискаНеЗамещать["Дата"] = Неопределено);
			
		Если МожноЗамещать Тогда
			
			Если СозданныйОбъект = Неопределено Тогда
				СозданныйОбъект = СсылкаНаОбъект.ПолучитьОбъект();
			КонецЕсли;
			
			СозданныйОбъект.Дата = СвойстваПоиска["Дата"];
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Создавать новый объект нужно не всегда.
	Если Не ЗначениеЗаполнено(СсылкаНаОбъект)
		И СозданныйОбъект = Неопределено Тогда 
		
		Если ПриПереносеОбъектаПоСсылкеУстанавливатьТолькоGIUD Тогда
			
			СсылкаНаОбъект = СтруктураСвойств.Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(СвойствоУникальныйИдентификатор));
			СсылкаНаОбъектФиктивная = Истина;
			
		ИначеЕсли НЕ НеСоздаватьОбъектЕслиНеНайден Тогда
		
			СсылкаНаОбъект = СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, СозданныйОбъект, НЕ РежимПоискаОсновногоОбъекта, , ИзвестнаяСсылкаУникальногоИдентификатора, НППСсылки, 
				НППГлобальнойСсылки, ,УстанавливатьУОбъектаВсеСвойстваПоиска);
				
			СвойстваОбъектаМодифицированы = Истина;
				
		КонецЕсли;
			
		ОбъектНайден = Ложь;
		
	Иначе
		
		ОбъектНайден = ЗначениеЗаполнено(СсылкаНаОбъект);
		
	КонецЕсли;
	
	Если СсылкаНаОбъект <> Неопределено
		И СсылкаНаОбъект.Пустая() Тогда
		
		СсылкаНаОбъект = Неопределено;
		
	КонецЕсли;
	
	ДобавитьСсылкуВСписокЗагруженныхОбъектов(НППГлобальнойСсылки, НППСсылки, СсылкаНаОбъект, СсылкаНаОбъектФиктивная);
		
	Возврат СсылкаНаОбъект;
	
КонецФункции

// Получает значение свойства по имени из указанного объекта, приводит значение
// к указанному примитивному типу.
//
// Параметры:
//  ДанныеОбъекта - Соответствие - данные загружаемого объекта.
//                свойство которого требуется получить.
//  Тип - Тип - тип свойства.
//  Имя - Строка - имя свойства.
//
// Возвращаемое значение:
//  Произвольный - значение атрибута полученное по имени и приведенное к указанному типу.
//
Функция одЗначениеСвойства(ДанныеОбъекта, Тип, Имя) Экспорт
	
	мЗначение = ДанныеОбъекта[Имя];
	Если мЗначение <> Неопределено Тогда
		Возврат мЗначение;
	ИначеЕсли Тип = одТипСтрока Тогда
		Возврат "";
	ИначеЕсли Тип = одТипБулево Тогда
		Возврат Ложь;
	ИначеЕсли Тип = одТипЧисло Тогда
		Возврат 0;
	ИначеЕсли Тип = одТипДата Тогда
		Возврат ЗначениеПустаяДата;
	КонецЕсли;
	
КонецФункции

Функция ОбработатьПоискОбъектаПоСтруктуре(
										НомерОбъекта, 
										ТипОбъекта, 
										СозданныйОбъект,
										РежимПоискаОсновногоОбъекта, 
										СвойстваОбъектаМодифицированы, 
										ОбъектНайден,
										ЭтоГлобальныйНомер, 
										ПараметрыОбъекта, 
										ДанныеСсылки = Неопределено,
										ИмяПКО = "")
	
	СтруктураДанных = мГлобальныйСтекНеЗаписанныхОбъектов[НомерОбъекта];
	
	Если СтруктураДанных <> Неопределено Тогда
		
		СвойстваОбъектаМодифицированы = Истина;
		СозданныйОбъект = СтруктураДанных.Объект;
		
		Если СтруктураДанных.ИзвестнаяСсылка = Неопределено Тогда
			
			УстановитьСсылкуДляОбъекта(СтруктураДанных);
			
		КонецЕсли;
			
		СсылкаНаОбъект = СтруктураДанных.ИзвестнаяСсылка;
		ПараметрыОбъекта = СтруктураДанных.ПараметрыОбъекта;
		
		ОбъектНайден = Ложь;
		
	Иначе
		
		СозданныйОбъект = Неопределено;
		
		Если ЭтоГлобальныйНомер Тогда
			СсылкаНаОбъект = НайтиОбъектПоГлобальномуНомеру(НомерОбъекта, РежимПоискаОсновногоОбъекта);
		Иначе
			СсылкаНаОбъект = НайтиОбъектПоНомеру(НомерОбъекта, РежимПоискаОсновногоОбъекта);
		КонецЕсли;
		
	КонецЕсли;
	
	Если СсылкаНаОбъект <> Неопределено Тогда
		
		Если РежимПоискаОсновногоОбъекта Тогда
			
			СвойстваПоиска = "";
			СвойстваПоискаНеЗамещать = "";
			ПрочитатьИнформациюОСвойствахПоиска(
				ТипОбъекта, СвойстваПоиска, СвойстваПоискаНеЗамещать, , ПараметрыОбъекта, ДанныеСсылки, ИмяПКО);
			
			// Для основного поиска нужно поля поиска еще раз проверить, возможно нужно их переустановить...
			Если СозданныйОбъект = Неопределено Тогда
				
				СозданныйОбъект = СсылкаНаОбъект.ПолучитьОбъект();
				
			КонецЕсли;
			
			СвойстваОбъектаМодифицированы = УстановитьРеквизитыПоискаУОбъекта(СозданныйОбъект, СвойстваПоиска, СвойстваПоискаНеЗамещать);
			
		Иначе
			
			//одПропустить(ФайлОбмена);
			
		КонецЕсли;
		
		Возврат СсылкаНаОбъект;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Процедура УстановитьСсылкуДляОбъекта(СтрокаСтекаНезаписанныхОбъектов)
	
	// Объект еще не записан, а на него ссылаются.
	ОбъектДляЗаписи = СтрокаСтекаНезаписанныхОбъектов.Объект;
	
	СвойстваМД      = Менеджеры[СтрокаСтекаНезаписанныхОбъектов.ТипОбъекта];
	Менеджер        = СвойстваМД.Менеджер;
		
	НовыйУникальныйИдентификатор = Новый УникальныйИдентификатор;
	НоваяСсылка = Менеджер.ПолучитьСсылку(НовыйУникальныйИдентификатор);
		
	ОбъектДляЗаписи.УстановитьСсылкуНового(НоваяСсылка);
	СтрокаСтекаНезаписанныхОбъектов.ИзвестнаяСсылка = НоваяСсылка;
	
КонецПроцедуры

// Ищет объект по номеру в списке уже загруженных объектов.
//
// Параметры:
//   НПП - Число - номер искомого объекта в файле обмена.
//
// Возвращаемое значение:
//   - ЛюбаяСсылка - ссылка на найденный объект.
//   - Неопределено - если объект не найден.
// 
Функция НайтиОбъектПоНомеру(НПП, РежимПоискаОсновногоОбъекта = Ложь)

	Если НПП = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураРезультата = ЗагруженныеОбъекты[НПП];
	
	Если СтруктураРезультата = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если РежимПоискаОсновногоОбъекта И СтруктураРезультата.СсылкаФиктивная Тогда
		Возврат Неопределено;
	Иначе
		Возврат СтруктураРезультата.СсылкаНаОбъект;
	КонецЕсли; 

КонецФункции

Функция НайтиОбъектПоГлобальномуНомеру(НПП, РежимПоискаОсновногоОбъекта = Ложь)

	СтруктураРезультата = ЗагруженныеГлобальныеОбъекты[НПП];
	
	Если СтруктураРезультата = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если РежимПоискаОсновногоОбъекта И СтруктураРезультата.СсылкаФиктивная Тогда
		Возврат Неопределено;
	Иначе
		Возврат СтруктураРезультата.СсылкаНаОбъект;
	КонецЕсли;
	
КонецФункции

Процедура ПрочитатьИнформациюОСвойствахПоиска(
											ТипОбъекта, 
											СвойстваПоиска, 
											СвойстваПоискаНеЗамещать, 
											ПоискПоДатеНаРавенство = Ложь, 
											ПараметрыОбъекта = Неопределено, 
											ДанныеСсылки = Неопределено, 
											ИмяПКО = "")
	
	Если СвойстваПоиска = "" Тогда
		СвойстваПоиска = Новый Соответствие;
	КонецЕсли;
	
	Если СвойстваПоискаНеЗамещать = "" Тогда
		СвойстваПоискаНеЗамещать = Новый Соответствие;
	КонецЕсли;
	
	ИнформацияОТипах = мСоответствиеТиповДанныхДляЗагрузки[ТипОбъекта];
	ПрочитатьСвойстваПоискаИзФайла(
		СвойстваПоиска, СвойстваПоискаНеЗамещать, ИнформацияОТипах, ПоискПоДатеНаРавенство, ПараметрыОбъекта, ДанныеСсылки, ИмяПКО);
	
КонецПроцедуры

Процедура ПрочитатьСвойстваПоискаИзФайла(
										СвойстваПоиска, 
										СвойстваПоискаНеЗамещать, 
										ИнформацияОТипах, 
										ПоискПоДатеНаРавенство = Ложь, 
										ПараметрыОбъекта = Неопределено,
										ДанныеСсылки = Неопределено, 
										ИмяПКО = "")
	
	ПоискПоДатеНаРавенство = Ложь;
	
	ПКО = Правила[ИмяПКО];
	
	Если ПКО.СинхронизироватьПоИдентификатору Тогда 
		Если ДанныеСсылки <> Неопределено Тогда
			Имя = "{УникальныйИдентификатор}";
			Значение = ДанныеСсылки.Получить("УникальныйИдентификатор");
			СвойстваПоиска.Вставить(Имя, Значение);
		КонецЕсли;
	КонецЕсли;
	
	мСвойстваПоиска = ДанныеСсылки.Получить("_СвойстваПоиска");
	Если мСвойстваПоиска = Неопределено ИЛИ мСвойстваПоиска.Количество() = 0 Тогда
		Возврат; // На случай, когда объект выгружается в сокращенном виде
	КонецЕсли;
	
	пксСвойстваПоиска = ПКО.СвойстваПоиска;
	Для Каждого стрПКС Из пксСвойстваПоиска Цикл
		
		Если стрПКС.Имя = "{УникальныйИдентификатор}" Тогда
			Продолжить;
		КонецЕсли;
		
		ЭтоПараметр = Ложь; // Заглушка, на будущее.
		
		Имя = стрПКС.Приемник;
		ТипСвойства = ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, Имя);
		ИмяИсточник = стрПКС.Источник;
		
		ЗначениеИсточник = мСвойстваПоиска.Получить(ИмяИсточник);
		
		Если ЗначениеИсточник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		НеЗамещатьСвойство = стрПКС.НеЗамещать;
		ПоискПоДатеНаРавенство = стрПКС.ПоискПоДатеНаРавенство; // Пока не используется
		СвойствоИмяПКО = ?(ЗначениеЗаполнено(стрПКС.ПравилоКонвертации), СокрЛП(стрПКС.ПравилоКонвертации.Код), "");
		
		// Попробуем получить тип свойства из ПКО по типу источника...
		// Вариант так себе - для одного источника может быть несколько разных ПКО...
		//Если ТипСвойства = Неопределено Тогда
		//	
		//	Если ТипЗнч(ЗначениеИсточник) = Тип("Соответствие")Тогда // скорее всего это сериализованная ссылка
		//		
		//		мТипИзСсылки = ЗначениеИсточник["Тип"];
		//		Если мТипИзСсылки <> Неопределено Тогда
		//			
		//			МассивПКО = ТаблицаПравилКонвертации.НайтиСтроки(Новый Структура("Источник", мТипИзСсылки));
		//			Попытка
		//				ТипСвойства = Тип(МассивПКО[0].Источник);
		//				СвойствоИмяПКО = МассивПКО[0].Имя;
		//			Исключение
		//			    ТипСвойства = Тип("Неопределено");
		//			КонецПопытки;
		//			
		//		КонецЕсли;
		//		
		//	КонецЕсли;
		//	
		//КонецЕсли;
		
		//ЗначениеСвойства = ПрочитатьСвойство(ТипСвойства, СвойствоИмяПКО, ЗначениеИсточник, стрПКС.ТипПриемника, стрПКС.ТипИсточника);
		ЗначениеСвойства = ПрочитатьСвойство_2(Неопределено, стрПКС, ЗначениеИсточник, НеЗамещатьСвойство, ИнформацияОТипах, ПКО);
		
		Если (Имя = "ЭтоГруппа") И (ЗначениеСвойства <> Истина) Тогда
			
			ЗначениеСвойства = Ложь;
			
		КонецЕсли;
		
		Если ЭтоПараметр Тогда
			
			//// to do: В КД2 можно было передавать свойства в параметры - нужнто будет продумать эту логику,
			//// когда на стороне отправителя тоже будем выгружать по правилам.
			//ДобавитьПараметрПриНеобходимости(ПараметрыОбъекта, Имя, ЗначениеСвойства);
			
		Иначе
			
			СвойстваПоиска[Имя] = ЗначениеСвойства;
			
			Если НеЗамещатьСвойство Тогда
				
				СвойстваПоискаНеЗамещать[Имя] = Истина;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	
#Область СтараяЛогика
	
	//Пока ФайлОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ФайлОбмена.ЛокальноеИмя;
	//			
	//	Если ИмяУзла = "Свойство"
	//		ИЛИ ИмяУзла = "ЗначениеПараметра" Тогда
	//				
	//		ЭтоПараметр = (ИмяУзла = "ЗначениеПараметра");
	//		
	//		Имя = одАтрибут(ФайлОбмена, одТипСтрока, "Имя");
	//		
	//		Если Имя = "{УникальныйИдентификатор}" 
	//			ИЛИ Имя = "{ИмяПредопределенногоЭлемента}" Тогда
	//			
	//			ТипСвойства = одТипСтрока;
	//			
	//		Иначе
	//		
	//			ТипСвойства = ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, Имя);
	//		
	//		КонецЕсли;
	//		
	//		НеЗамещатьСвойство = одАтрибут(ФайлОбмена, одТипБулево, "НеЗамещать");
	//		ПоискПоДатеНаРавенство = ПоискПоДатеНаРавенство 
	//				ИЛИ одАтрибут(ФайлОбмена, одТипБулево, "ПоискПоДатеНаРавенство");
	//		//
	//		ИмяПКО = одАтрибут(ФайлОбмена, одТипСтрока, "ИмяПКО");
	//		
	//		ЗначениеСвойства = ПрочитатьСвойство(ТипСвойства, ИмяПКО);
	//		
	//		Если (Имя = "ЭтоГруппа") И (ЗначениеСвойства <> Истина) Тогда
	//			
	//			ЗначениеСвойства = Ложь;
	//											
	//		КонецЕсли;
	//		
	//		Если ЭтоПараметр Тогда
	//			
	//			
	//			ДобавитьПараметрПриНеобходимости(ПараметрыОбъекта, Имя, ЗначениеСвойства);
	//			
	//		Иначе
	//		
	//			СвойстваПоиска[Имя] = ЗначениеСвойства;
	//			
	//			Если НеЗамещатьСвойство Тогда
	//				
	//				СвойстваПоискаНеЗамещать[Имя] = Истина;
	//				
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//		
	//	ИначеЕсли (ИмяУзла = "Ссылка") И (ФайлОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//		Прервать;
	//		
	//	Иначе
	//		
	//		ЗаписатьВПротоколВыполнения(9);
	//		Прервать;
	//		
	//	КонецЕсли;
	//	
	//КонецЦикла;
	
#КонецОбласти
	
КонецПроцедуры

Функция ПолучитьТипСвойства()
	
	СтроковыйТипСвойства = "";//одАтрибут(ФайлОбмена, одТипСтрока, "Тип");
	Если ПустаяСтрока(СтроковыйТипСвойства) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Тип(СтроковыйТипСвойства);
	
КонецФункции

Функция ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, ИмяСвойства)
	
	ТипСвойства = ПолучитьТипСвойства();
				
	Если ТипСвойства = Неопределено
		И ИнформацияОТипах <> Неопределено Тогда
		
		ТипСвойства = ИнформацияОТипах[ИмяСвойства];
		
	КонецЕсли;
	
	Возврат ТипСвойства;
	
КонецФункции

// Читает из файла узел свойства объекта, устанавливает значение свойства.
//
// Параметры:
//  Тип - Тип - тип значения свойства.
//  ОбъектНайден - Булево - если после выполнения функции - Ложь, то значит
//                 объект свойства не найден в информационной базе и создан новый.
//  ИмяИсточник - Строка - имя свойства в объекте-источнике.
//
// Возвращаемое значение:
//   Произвольный - значение свойства.
// 
Функция ПрочитатьСвойство(отСвойства, ИмяПКО = "", ЗначениеИсточник, Знач ТипПриемникаСтрокой = "", Знач ТипИсточникаСтрокой = "")
	
	Значение = Неопределено;
	НаличиеСвойств = Ложь;
	
	ТипЗначенияИсточник = ТипЗнч(ЗначениеИсточник); // Простой тип даных / Неопределено / Соответствие
	
	Если ЭтоПростойТипДанных(ТипЗначенияИсточник) Тогда // обработка простых типов (число, строка, дата, булево)
		
		Если ТипИсточникаСтрокой = "Дата" И ТипЗначенияИсточник = одТипСтрока И отСвойства.СодержитТип(одТипДата) Тогда
			
			Значение = ПрочитатьДатуJSON(ЗначениеИсточник, ФорматДатыJSON.ISO);
			НаличиеСвойств = Истина;
			
		ИначеЕсли отСвойства.СодержитТип(ТипЗначенияИсточник) Тогда //Идеальный случай.
			
			Значение = ЗначениеИсточник;
			НаличиеСвойств = Истина;
			
		Иначе // приводим значение
			
			Значение = отСвойства.ПривестиЗначение(ЗначениеИсточник);
			
		КонецЕсли;
		
	ИначеЕсли ТипЗначенияИсточник = одТипСоответствие Тогда // обработка сложных типов (пока что только ссылки)
		
		ТипСтрокой = ЗначениеИсточник.Получить("Тип"); // Этот ключ всегда присутствует. Если его нет - значит некорректно сериализовано свойство на стороне отправителя.
		Если ТипСтрокой = Неопределено Тогда
			
			НаличиеСвойств = Ложь;
			
		ИначеЕсли СтрНачинаетсяС(ТипСтрокой, "ПеречислениеСсылка")
			И ТипСтрокой = ТипИсточникаСтрокой Тогда // Это ссылка на значение перечисления
			
			ЗначениеСтрокой = ЗначениеИсточник.Получить("Значение");
			
			Правило = Правила[ИмяПКО];
			СоответствиеЗначений = Правило.Значения;
			Значение = СоответствиеЗначений.Получить(ЗначениеСтрокой);
			
			Если Значение = Неопределено Тогда
				НаличиеСвойств = Ложь;
			Иначе
				НаличиеСвойств = Истина;
			КонецЕсли;
			
		ИначеЕсли СтрНайти(ТипСтрокой, "Ссылка") Тогда 
			
			Если НЕ ПустаяСтрока(ИмяПКО) Тогда // Сначала берём тип из ПКО
				
				Правило = Правила[ИмяПКО];
				Тип = Тип(Правило.Приемник);
				
			ИначеЕсли НЕ ПустаяСтрока(ТипПриемникаСтрокой) Тогда // ищем первое попавшееся правило... Возможно переделать в будущем
				
				СтрокаПКО = ТаблицаПравилКонвертации.Найти(ТипПриемникаСтрокой, "Приемник");
				ИмяПКО = СтрокаПКО.Имя;
				Тип = Тип(ТипПриемникаСтрокой);
				
			ИначеЕсли НЕ ПустаяСтрока(ТипИсточникаСтрокой) Тогда // Поищем ПКО по типу источника
				
				МассивПКО = ТаблицаПравилКонвертации.НайтиСтроки(Новый Структура("Источник", ТипИсточникаСтрокой));
				Для Каждого СтрокаПКО Из МассивПКО Цикл
					
					ТипПриемникаСтрокой = СтрокаПКО.Приемник;
					Тип = Тип(ТипПриемникаСтрокой);
					Если отСвойства.СодержитТип(Тип) Тогда
						
						ИмяПКО = СтрокаПКО.Имя;
						Прервать;
						
					КонецЕсли;
				КонецЦикла;
				
			Иначе // В ПКС не было указано конкретное ПКО и приемник может принимать разные значения
				
				
				//мТипыПриемника = отСвойства.Типы();
				//Если мТипыПриемника.Количество() = 1 Тогда
				//	Тип = мТипыПриемника[0];
				//	сДанныеМенеджера = Менеджеры.Получить(Тип);
				//	ТипПриемникаСтрокой = сДанныеМенеджера.ТипСсылкиСтрокой;
				//	СтрокаПКО = ТаблицаПравилКонвертации.Найти(ТипПриемникаСтрокой, "Приемник");
				//	
				//	Если СтрокаПКО <> Неопределено Тогда
				//		ИмяПКО = СтрокаПКО.Имя;
				//	КонецЕсли;
				//	
				//КонецЕсли;
				
				НаличиеСвойств = Ложь;
				
			КонецЕсли;
			
			Значение = НайтиОбъектПоСсылке(ЗначениеИсточник, Тип, ИмяПКО);
			НаличиеСвойств = Истина;
			
		Иначе
			
		КонецЕсли;
		
	ИначеЕсли ТипЗначенияИсточник = Тип("Неопределено") Тогда
		НаличиеСвойств = Ложь;
	Иначе
		
	КонецЕсли;
	
	Если Не НаличиеСвойств Тогда
		
		мТипы = отСвойства.Типы();
		Если мТипы.Количество() = 1 Тогда
			Тип = мТипы[0];
		Иначе
			Тип = Тип("Неопределено");
		КонецЕсли;
		
		// Если вообще ничего нет - значит пустое значение.
		Значение = одПолучитьПустоеЗначение(Тип);
		
	КонецЕсли;
	
	Возврат Значение;
		
	//ТекОбъектСвойства = мТекущийобъектДляЧтения.Получить("_Свойства");
	//ИскатьПоСвойству = ""; // Заглушка на будущее
	//Значение = одЗначениеЭлемента(ТекОбъектСвойства, ИмяИсточник, Тип, ИскатьПоСвойству, ОбрезатьСтрокиСправа);
	
	
#Область СтараяЛогика
	
	//Пока ФайлОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ФайлОбмена.ЛокальноеИмя;
	//	
	//	Если ИмяУзла = "Значение" Тогда
	//		
	//		ИскатьПоСвойству = одАтрибут(ФайлОбмена, одТипСтрока, "Свойство");
	//		Значение         = одЗначениеЭлемента(ФайлОбмена, Тип, ИскатьПоСвойству, ОбрезатьСтрокиСправа);
	//		НаличиеСвойств = Истина;
	//		
	//	ИначеЕсли ИмяУзла = "Ссылка" Тогда
	//		
	//		Значение       = НайтиОбъектПоСсылке(Тип, ИмяПКО);
	//		НаличиеСвойств = Истина;
	//		
	//	ИначеЕсли ИмяУзла = "Нпп" Тогда
	//		
	//		одПропустить(ФайлОбмена);
	//		
	//	ИначеЕсли ИмяУзла = "ГНпп" Тогда
	//		
	//		ФайлОбмена.Прочитать();
	//		ГНПП = Число(ФайлОбмена.Значение);
	//		Если ГНПП <> 0 Тогда
	//			Значение  = НайтиОбъектПоГлобальномуНомеру(ГНПП);
	//			НаличиеСвойств = Истина;
	//		КонецЕсли;
	//		
	//		ФайлОбмена.Прочитать();
	//		
	//	ИначеЕсли (ИмяУзла = "Свойство" ИЛИ ИмяУзла = "ЗначениеПараметра") И (ФайлОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//		Если Не НаличиеСвойств
	//			И ЗначениеЗаполнено(Тип) Тогда
	//			
	//			// Если вообще ничего нет - значит пустое значение.
	//			Значение = одПолучитьПустоеЗначение(Тип);
	//			
	//		КонецЕсли;
	//		
	//		Прервать;
	//		
	//	ИначеЕсли ИмяУзла = "Выражение" Тогда
	//		
	//		Выражение = одЗначениеЭлемента(ФайлОбмена, одТипСтрока, , Ложь);
	//		Значение  = ВычислитьВыражение(Выражение);
	//		
	//		НаличиеСвойств = Истина;
	//		
	//	ИначеЕсли ИмяУзла = "Пусто" Тогда
	//		
	//		Значение = одПолучитьПустоеЗначение(Тип);
	//		НаличиеСвойств = Истина;		
	//		
	//	Иначе
	//		
	//		ЗаписатьВПротоколВыполнения(9);
	//		Прервать;
	//		
	//	КонецЕсли;
	//	
	//КонецЦикла;
	
#КонецОбласти
	
КонецФункции

// Читает текст элемента и приводит значение к указанному типу.
//
// Параметры:
//  Объект           - ЧтениеXML - объект типа XMLЧтение, из которого осуществляется чтение.
//  Тип              - Тип - тип получаемого значения.
//  ИскатьПоСвойству - Строка - для ссылочных типов может быть указано свойство, по которому.
//                     следует искать объект: "Код", "Наименование", <ИмяРеквизита>, "Имя" (предопределенного значения).
//  ОбрезатьСтрокуСправа - Булево - признак необходимости обрезать строку справа.
//
// Возвращаемое значение:
//  Произвольный - значение xml-элемента, приведенное к соответствующему типу.
//
Функция одЗначениеЭлемента(СвойстваОбъекта, ИмяСвойства, Тип, ИскатьПоСвойству = "", ОбрезатьСтрокуСправа = Истина) Экспорт
	
	Значение = "";
	Значение = СвойстваОбъекта.Получить(ИмяСвойства);
	
	Если Значение = Неопределено Тогда // Указанного свойства может не быть или оно пустое на этапе выгрузки
		Значение = одПолучитьПустоеЗначение(Тип);
		Возврат Значение;
	КонецЕсли;
	
	ТипСвойства = ТипЗнч(Значение);
	
	Если (ТипСвойства = одТипСтрока)
		ИЛИ (ТипСвойства = одТипБулево)
		ИЛИ (ТипСвойства = одТипЧисло)
		ИЛИ (ТипСвойства = одТипДата) Тогда // Это значение простого типа данных
		
		Значение = одОписаниеТипа(Тип).ПривестиЗначение(Значение);
		
		Если ТипСвойства = одТипСтрока И ОбрезатьСтрокуСправа Тогда
			Значение = СокрП(Значение);
		КонецЕсли;
		
		Возврат Значение;
		
	ИначеЕсли ТипСвойства = одТипСоответствие Тогда // Это данные ссылки/ХранилищеЗначения/УникальныйИдентификатор/ДвоичныеДанные...
		
	КонецЕсли;
	
#Область СтараяЛогика
	
	//Значение = "";
	//Имя      = Объект.ЛокальноеИмя;

	//Пока Объект.Прочитать() Цикл
	//	
	//	ТипУзла = Объект.ТипУзла;
	//	
	//	Если ТипУзла = одТипУзлаXML_Текст Тогда
	//		
	//		Значение = Объект.Значение;
	//		
	//		Если ОбрезатьСтрокуСправа Тогда
	//			
	//			Значение = СокрП(Значение);
	//			
	//		КонецЕсли;
	//					
	//	ИначеЕсли (Объект.ЛокальноеИмя = Имя) И (ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//		Прервать;
	//		
	//	Иначе
	//		
	//		Возврат Неопределено;
	//		
	//	КонецЕсли;
	//	
	//КонецЦикла;

	//
	//Если (Тип = одТипСтрока)
	//	ИЛИ (Тип = одТипБулево)
	//	ИЛИ (Тип = одТипЧисло)
	//	ИЛИ (Тип = одТипДата)
	//	ИЛИ (Тип = одТипХранилищеЗначения)
	//	ИЛИ (Тип = одТипУникальныйИдентификатор)
	//	ИЛИ (Тип = одТипВидДвиженияНакопления)
	//	ИЛИ (Тип = одТипВидСчета) Тогда
	//	
	//	Возврат XMLЗначение(Тип, Значение);
	//	
	//Иначе
	//	
	//	Возврат одПолучитьЗначениеПоСтроке(Значение, Тип, ИскатьПоСвойству);
	//	
	//КонецЕсли;
	
#КонецОбласти
	
КонецФункции

// Возвращает пустое (дефолтное) значение указанного типа.
//
// Параметры:
//  Тип          - Строка
//               - Тип - имя типа или значение типа Тип.
//
// Возвращаемое значение:
//  Произвольный - пустое значение указанного типа.
// 
Функция одПолучитьПустоеЗначение(Тип) Экспорт

	ПустоеЗначениеТипа = мСоответствиеПустыхЗначенийТипов[Тип];
	
	Если ПустоеЗначениеТипа = Неопределено Тогда
		
		ПустоеЗначениеТипа = одОписаниеТипа(Тип).ПривестиЗначение(Неопределено);
		мСоответствиеПустыхЗначенийТипов.Вставить(Тип, ПустоеЗначениеТипа);
		
	КонецЕсли;
	
	Возврат ПустоеЗначениеТипа;

КонецФункции

Процедура ПровестиЗаписьНеЗаписанныхОбъектов()
	
	Если мГлобальныйСтекНеЗаписанныхОбъектов = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаДанных Из мГлобальныйСтекНеЗаписанныхОбъектов Цикл
		
		// отложенная запись объектов
		Объект = СтрокаДанных.Значение.Объект; // СправочникОбъект, ДокументОбъект, и т.п.
		НППСсылки = СтрокаДанных.Ключ;
		
		ЗаписатьОбъектВИБ(Объект, СтрокаДанных.Значение.ТипОбъекта);
		
		ДобавитьСсылкуВСписокЗагруженныхОбъектов(0, НППСсылки, Объект.Ссылка);
		
	КонецЦикла;
	
	мГлобальныйСтекНеЗаписанныхОбъектов.Очистить();
	
КонецПроцедуры

Процедура ЗаписатьОбъектВИБ(Объект, Тип)
		
	Попытка
		
		УстановитьОбменДаннымиЗагрузка(Объект);
		Объект.Записать();
		
	Исключение
		
		СтрокаСообщенияОбОшибке = ЗаписатьИнформациюОбОшибкеВПротокол(26, ОписаниеОшибки(), Объект, Тип);
		
		Если Не ФлагРежимОтладки Тогда
			ВызватьИсключение СтрокаСообщенияОбОшибке;
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

Процедура ДобавитьСсылкуВСписокЗагруженныхОбъектов(ГНППСсылки, НППСсылки, СсылкаНаОбъект, СсылкаФиктивная = Ложь)
	
	// Запоминаем ссылку на объект.
	Если НЕ ЗапоминатьЗагруженныеОбъекты 
		ИЛИ СсылкаНаОбъект = Неопределено Тогда
		
		Возврат;
		
	КонецЕсли;
	
	СтруктураЗаписи = Новый Структура("СсылкаНаОбъект, СсылкаФиктивная", СсылкаНаОбъект, СсылкаФиктивная);
	
	// Запоминаем ссылку на объект.
	Если ГНППСсылки <> 0 Тогда
		
		ЗагруженныеГлобальныеОбъекты[ГНППСсылки] = СтруктураЗаписи;
		
	ИначеЕсли НППСсылки <> 0 Тогда
		
		ЗагруженныеОбъекты[НППСсылки] = СтруктураЗаписи;
						
	КонецЕсли;	
	
КонецПроцедуры

// Устанавливает значение параметра "Загрузка" для свойства объекта "ОбменДанными".
//
// Параметры:
//  Объект   - объект, для которого устанавливается свойство.
//  Значение - значение устанавливаемого свойства "Загрузка".
// 
Процедура УстановитьОбменДаннымиЗагрузка(Объект, Значение = Истина) Экспорт
	
	Если Не ЗагружатьДанныеВРежимеОбмена Тогда
		Возврат;
	КонецЕсли;
	
	Если ЕстьРеквизитИлиСвойствоОбъекта(Объект, "ОбменДанными") Тогда
		СтруктураДляЗаполнения = Новый Структура("Загрузка", Значение);
		ЗаполнитьЗначенияСвойств(Объект.ОбменДанными, СтруктураДляЗаполнения);
	КонецЕсли;
	
КонецПроцедуры

// Процедура выполняет действия после итерации загрузки данных:
// - фиксация транзакции (при необходимости)
// - закрытие файла сообщения обмена
// - выполнение обработчика конвертации ПослеЗагрузкиДанных
// - завершение ведения протокола обмена (при необходимости).
//
// Параметры:
//  Нет.
// 
Процедура ВыполнитьДействияПослеЗавершенияЧтенияДанных() Экспорт
	
	Если БезопасныйРежим Тогда
		УстановитьБезопасныйРежим(Истина);
		Для Каждого ИмяРазделителя Из РазделителиКонфигурации Цикл
			УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		КонецЦикла;
	КонецЕсли;
	
	//ФайлОбмена.Закрыть();
	
	// Обработчик ПослеЗагрузкиДанных
	Если Не ПустаяСтрока(Конвертация.ПослеЗагрузкиДанных) Тогда
		
		Попытка
			
			//Если ФлагРежимОтладкиОбработчиков Тогда
			//	
			//	Выполнить(ПолучитьСтрокуВызоваОбработчика(Конвертация, "ПослеЗагрузкиДанных"));
			//	
			//Иначе
				
				Выполнить(Конвертация.ПослеЗагрузкиДанных);
				
			//КонецЕсли;
			
		Исключение
			
			СтрокаСообщенияОбОшибке = ЗаписатьИнформациюОбОшибкеОбработчикиКонвертации(23, ОписаниеОшибки(), Нстр("ru = 'ПослеЗагрузкиДанных (конвертация)'"));
			мОшибки.Добавить(СтрокаСообщенияОбОшибке);
			
		КонецПопытки;
		
	КонецЕсли;
	
	// Пока что не используется:
	//ДеструкторВнешнейОбработкиОбработчиковСобытий();
	
	ЗаписатьВПротоколВыполнения(СтрШаблон(НСтр("ru = 'Окончание загрузки: %1'"), ТекущаяДатаСеанса()), , Ложь, , , Истина);
	ЗаписатьВПротоколВыполнения(СтрШаблон(НСтр("ru = 'Загружено объектов: %1'"), мСчетчикЗагруженныхОбъектов), , Ложь, , , Истина);
	ЗавершитьВедениеПротоколаОбмена();
	
	//Если ЭтоИнтерактивныйРежим Тогда
		Сообщить("Загрузка данных завершена.");
	//КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьОкончаниеЧтенияНовогоЭлемента(ПоследнийОбъектЗагрузки)
	
	мСчетчикЗагруженныхОбъектов = 1 + мСчетчикЗагруженныхОбъектов;
	
	// Использовать в будущем:
	
	//Если ЗапоминатьЗагруженныеОбъекты
	//	И мСчетчикЗагруженныхОбъектов % 100 = 0 Тогда
	//	
	//	Если ЗагруженныеОбъекты.Количество() > ЧислоХранимыхЗагруженныхОбъектов Тогда
	//		ЗагруженныеОбъекты.Очистить();
	//	КонецЕсли;
	//	
	//КонецЕсли;
	//
	//Если мСчетчикЗагруженныхОбъектов % 100 = 0
	//	И мГлобальныйСтекНеЗаписанныхОбъектов.Количество() > 100 Тогда
	//	
	//	ПровестиЗаписьНеЗаписанныхОбъектов();
	//	
	//КонецЕсли;
	//
	//Если ИспользоватьТранзакции
	//	И КоличествоОбъектовНаТранзакцию > 0 
	//	И мСчетчикЗагруженныхОбъектов % КоличествоОбъектовНаТранзакцию = 0 Тогда
	//	
	//	ЗафиксироватьТранзакцию();
	//	НачатьТранзакцию();
	//	
	//КонецЕсли;

КонецПроцедуры

Функция ПолучитьОбъектПоСсылкеИДопИнформации(СозданныйОбъект, Ссылка)
	
	// Если объект создали, то работаем с ним, если нашли - получаем объект.
	Если СозданныйОбъект <> Неопределено Тогда
		Объект = СозданныйОбъект;
	Иначе
		Если Ссылка.Пустая() Тогда
			Объект = Неопределено;
		Иначе
			Объект = Ссылка.ПолучитьОбъект();
		КонецЕсли;		
	КонецЕсли;
	
	Возврат Объект;
	
КонецФункции

Процедура ДополнитьСтекНеЗаписанныхОбъектов(НПП, ГНПП, Объект, ИзвестнаяСсылка, ТипОбъекта, ПараметрыОбъекта)
	
	НомерДляСтека = ?(НПП = 0, ГНПП, НПП);
	
	СтрокаСтека = мГлобальныйСтекНеЗаписанныхОбъектов[НомерДляСтека];
	Если СтрокаСтека <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	СтруктураПараметров = Новый Структура();
	СтруктураПараметров.Вставить("Объект", Объект);
	СтруктураПараметров.Вставить("ИзвестнаяСсылка", ИзвестнаяСсылка);
	СтруктураПараметров.Вставить("ТипОбъекта", ТипОбъекта);
	СтруктураПараметров.Вставить("ПараметрыОбъекта", ПараметрыОбъекта);

	мГлобальныйСтекНеЗаписанныхОбъектов.Вставить(НомерДляСтека, СтруктураПараметров);
	
КонецПроцедуры

Процедура УдалитьИзСтекаНеЗаписанныхОбъектов(НПП, ГНПП)
	
	НомерДляСтека = ?(НПП = 0, ГНПП, НПП);
	СтрокаСтека = мГлобальныйСтекНеЗаписанныхОбъектов[НомерДляСтека];
	Если СтрокаСтека = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	мГлобальныйСтекНеЗаписанныхОбъектов.Удалить(НомерДляСтека);
	
КонецПроцедуры

// Создает новый объект указанного типа, устанавливает реквизиты, указанные
// в структуре СвойстваПоиска.
//
// Параметры:
//  Тип - Тип - тип создаваемого объекта.
//  СвойстваПоиска - Структура - содержит устанавливаемые реквизиты нового объекта.
//
// Возвращаемое значение:
//   Произвольный - новый объект информационной базы.
// 
Функция СоздатьНовыйОбъект(Тип, СвойстваПоиска, Объект = Неопределено, 
	ЗаписыватьОбъектСразуПослеСоздания = Истина, НаборЗаписейРегистра = Неопределено,
	НоваяСсылка = Неопределено, НПП = 0, ГНПП = 0, ПараметрыОбъекта = Неопределено,
	УстанавливатьУОбъектаВсеСвойстваПоиска = Истина)

	СвойстваМД      = Менеджеры[Тип];
	ИмяТипа         = СвойстваМД.ИмяТипа;
	Менеджер        = СвойстваМД.Менеджер; // СправочникМенеджер, ДокументМенеджер, РегистрСведенийМенеджер, ПланСчетовМенеджер, ПланВидовРасчетаМенеджер, ПланОбменаМенеджер

	Если ИмяТипа = "Справочник"
		ИЛИ ИмяТипа = "ПланВидовХарактеристик" Тогда
		
		ЭтоГруппа = СвойстваПоиска["ЭтоГруппа"];
		
		Если ЭтоГруппа = Истина Тогда
			
			Объект = Менеджер.СоздатьГруппу();
						
		Иначе
			
			Объект = Менеджер.СоздатьЭлемент();
			
		КонецЕсли;		
				
	ИначеЕсли ИмяТипа = "Документ" Тогда
		
		Объект = Менеджер.СоздатьДокумент();
				
	ИначеЕсли ИмяТипа = "ПланСчетов" Тогда
		
		Объект = Менеджер.СоздатьСчет();
				
	ИначеЕсли ИмяТипа = "ПланВидовРасчета" Тогда
		
		Объект = Менеджер.СоздатьВидРасчета();
				
	ИначеЕсли ИмяТипа = "РегистрСведений" Тогда
		
		Если ЗаписыватьРегистрыНаборамиЗаписей Тогда
			
			НаборЗаписейРегистра = Менеджер.СоздатьНаборЗаписей();
			Объект = НаборЗаписейРегистра.Добавить();
			
		Иначе
			
			Объект = Менеджер.СоздатьМенеджерЗаписи();
						
		КонецЕсли;
		
		Возврат Объект;
		
	ИначеЕсли ИмяТипа = "ПланОбмена" Тогда
		
		Объект = Менеджер.СоздатьУзел();
				
	ИначеЕсли ИмяТипа = "Задача" Тогда
		
		Объект = Менеджер.СоздатьЗадачу();
		
	ИначеЕсли ИмяТипа = "БизнесПроцесс" Тогда
		
		Объект = Менеджер.СоздатьБизнесПроцесс();
		
	ИначеЕсли ИмяТипа = "Перечисление" Тогда
		
		Объект = СвойстваМД.ПустаяСсылка;	
		Возврат Объект;
		
	ИначеЕсли ИмяТипа = "ТочкаМаршрутаБизнесПроцесса" Тогда
		
		Возврат Неопределено;
				
	КонецЕсли;
	
	НоваяСсылка = УстановитьСсылкуНового(Объект, Менеджер, СвойстваПоиска);
	
	Если УстанавливатьУОбъектаВсеСвойстваПоиска Тогда
		УстановитьРеквизитыПоискаУОбъекта(Объект, СвойстваПоиска, Неопределено, Ложь, Ложь);
	КонецЕсли;
	
	// Проверки
	Если ИмяТипа = "Документ"
		ИЛИ ИмяТипа = "Задача"
		ИЛИ ИмяТипа = "БизнесПроцесс" Тогда
		
		Если НЕ ЗначениеЗаполнено(Объект.Дата) Тогда
			
			Объект.Дата = ТекущаяДатаСеанса();
			
		КонецЕсли;
		
	КонецЕсли;
		
	// Если Владелец не установлен, то нужно поле добавить
	// в возможные поля поиска, а в событии ПОЛЯПОИСКА указать поля без Владельца, если по нему поиск реально не нужен.
	
	Если ЗаписыватьОбъектСразуПослеСоздания Тогда
		
		Если НЕ ОбъектыПоСсылкеЗагружатьБезПометкиУдаления Тогда
			Объект.ПометкаУдаления = Истина;
		КонецЕсли;
		
		Если ГНПП <> 0
			ИЛИ Не ОптимизированнаяЗаписьОбъектов Тогда
		
			ЗаписатьОбъектВИБ(Объект, Тип);
			
		Иначе
			
			// Записывать объект сразу не будем, а только запомним что нужно записать
			// сохраним эту информацию в специальном стеке объектов для записи
			// вернем и новую ссылку и сам объект, хотя он еще не записан.
			Если НоваяСсылка = Неопределено Тогда
				
				// Самостоятельно генерируем новую ссылку.
				НовыйУникальныйИдентификатор = Новый УникальныйИдентификатор;
				НоваяСсылка = Менеджер.ПолучитьСсылку(НовыйУникальныйИдентификатор);
				Объект.УстановитьСсылкуНового(НоваяСсылка);
				
			КонецЕсли;
			
			ДополнитьСтекНеЗаписанныхОбъектов(НПП, ГНПП, Объект, НоваяСсылка, Тип, ПараметрыОбъекта);
			
			Возврат НоваяСсылка;
			
		КонецЕсли;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат Объект.Ссылка;
	
КонецФункции

Процедура ДобавитьПараметрПриНеобходимости(ПараметрыДанных, ИмяПараметра, ЗначениеПараметра)
	
	Если ПараметрыДанных = Неопределено Тогда
		ПараметрыДанных = Новый Соответствие;
	КонецЕсли;
	
	ПараметрыДанных.Вставить(ИмяПараметра, ЗначениеПараметра);
	
КонецПроцедуры

// Загружает табличную часть объекта.
//
// Параметры:
//  Объект         - объект, табличную часть которого загружаем.
//  Имя            - имя табличной части.
//  Очистить       - если Истина, то табличная часть предварительно очищается.
// 
Процедура ЗагрузитьТабличнуюЧасть(Объект, Имя, Очистить, ОбщаяИнформацияОТипеДокумента, НужноЗаписатьОбъект, 
	ПараметрыОбъекта, Правило, ДанныеТЧ, ПравилаГруппы)

	ИмяТабличнойЧасти = Имя + "ТабличнаяЧасть";
	Если ОбщаяИнформацияОТипеДокумента <> Неопределено Тогда
		ИнформацияОТипах = ОбщаяИнформацияОТипеДокумента[ИмяТабличнойЧасти];
	Иначе
	    ИнформацияОТипах = Неопределено;
	КонецЕсли;
			
	ДанныеПоискаПоТЧ = Неопределено;
	Если Правило <> Неопределено Тогда
		ДанныеПоискаПоТЧ = Правило.ПоискПоТабличнымЧастям.Найти("ТабличнаяЧасть." + Имя, "ИмяЭлемента");
	КонецЕсли;
	
	КопияТЧДляПоиска = Неопределено;
	
	ТЧ = Объект[Имя];

	Если Очистить
		И ТЧ.Количество() <> 0 Тогда
		
		НужноЗаписатьОбъект = Истина;
		
		Если ДанныеПоискаПоТЧ <> Неопределено Тогда
			КопияТЧДляПоиска = ТЧ.Выгрузить();
		КонецЕсли;
		ТЧ.Очистить();
		
	ИначеЕсли ДанныеПоискаПоТЧ <> Неопределено Тогда
		
		КопияТЧДляПоиска = ТЧ.Выгрузить();
		
	КонецЕсли;
	
	МассивСтрокТЧ = ДанныеТЧ;
	НомерЗаписи = 0;
	
	Для Каждого ДанныеСтрокиТЧ Из МассивСтрокТЧ Цикл
		
		НужноЗаписатьОбъект = Истина;
		Запись = ТЧ.Добавить();
		УстановитьСвойстваЗаписи(
			Объект, 
			Запись, 
			ИнформацияОТипах, 
			ПараметрыОбъекта, 
			ИмяТабличнойЧасти, 
			ДанныеПоискаПоТЧ, 
			КопияТЧДляПоиска, 
			НомерЗаписи, 
			ДанныеСтрокиТЧ, 
			ПравилаГруппы, 
			Правило);
		
		НомерЗаписи = НомерЗаписи + 1;
		
	КонецЦикла;
	
#Область СтараяЛогика
	
	//НомерЗаписи = 0;
	//Пока ФайлОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ФайлОбмена.ЛокальноеИмя;
	//	
	//	Если ИмяУзла = "Запись" Тогда
	//		Попытка
	//			
	//			НужноЗаписатьОбъект = Истина;
	//			Запись = ТЧ.Добавить();
	//			
	//		Исключение
	//			Запись = Неопределено;
	//		КонецПопытки;
	//		
	//		Если Запись = Неопределено Тогда
	//			одПропустить(ФайлОбмена);
	//		Иначе
	//			УстановитьСвойстваЗаписи(Объект, Запись, ИнформацияОТипах, ПараметрыОбъекта, ИмяТабличнойЧасти, ДанныеПоискаПоТЧ, КопияТЧДляПоиска, НомерЗаписи);
	//		КонецЕсли;
	//		
	//		НомерЗаписи = НомерЗаписи + 1;
	//		
	//	ИначеЕсли (ИмяУзла = "ТабличнаяЧасть") И (ФайлОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//		Прервать;
	//		
	//	Иначе
	//		
	//		ЗаписатьВПротоколВыполнения(9);
	//		Прервать;
	//		
	//	КонецЕсли;
	//	
	//КонецЦикла;
	
#КонецОбласти

КонецПроцедуры

// Устанавливает свойства объекта (записи).
//
// Параметры:
//  Запись         - объект, свойства которого устанавливаем.
//                   Например, строка табличной части или запись регистра.
//
Процедура УстановитьСвойстваЗаписи(Объект, Запись, ИнформацияОТипах,
	ПараметрыОбъекта, ИмяВетки, ДанныеПоискаПоТЧ, КопияТЧДляПоиска, НомерЗаписи, ДанныеСтрокиТЧ, ПравилаГруппы, ПКОРодитель)
	
	НужноОрганизоватьПоискПоТЧ = (ДанныеПоискаПоТЧ <> Неопределено)
								И (КопияТЧДляПоиска <> Неопределено)
								И КопияТЧДляПоиска.Количество() <> 0;
								
	Если НужноОрганизоватьПоискПоТЧ Тогда
		
		СтруктураЧтенияСвойств = Новый Структура();
		СтруктураЧтенияСубконто = Новый Структура();
		
	КонецЕсли;
	
	Для Каждого СтрокаПКС ИЗ ПравилаГруппы Цикл
		
		Если СтрокаПКС.Отключить Тогда
			Продолжить;
		КонецЕсли;
		
		НеЗамещатьСвойство = СтрокаПКС.НеЗамещать;
		
		хДанныеРеквизитаТЧ = ДанныеСтрокиТЧ.Получить(СтрокаПКС.Источник);
		
		Если хДанныеРеквизитаТЧ = Неопределено Тогда // Возможно на стороне отправителя старое описание правил
			Продолжить;
		КонецЕсли;
		
		Имя = СтрокаПКС.Приемник;
		
		ЭтоПараметр = Ложь; //(ИмяУзла = "ЗначениеПараметра"); // Заглушка на будущее
		
		ИмяПКО = ?(ЗначениеЗаполнено(СтрокаПКС.ПравилоКонвертации), сокрЛП(СтрокаПКС.ПравилоКонвертации.Код), "");
		
		//Если Имя = "ВидДвижения" И СтрНайти(Метаданные.НайтиПоТипу(ТипЗнч(Запись)).ПолноеИмя(), "РегистрНакопления") Тогда
		//	
		//	ТипСвойства = одТипВидДвиженияНакопления;
		//	
		//Иначе
		//	
		//	ТипСвойства = ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, Имя);
		//	
		//КонецЕсли;
		
		//ЗначениеСвойства = ПрочитатьСвойство(ТипСвойства, ИмяПКО, ДанныеРеквизитаТЧ.Значение, стрПКС.ТипПриемника, стрПКС.ТипИсточника);
		ЗначениеСвойства = ПрочитатьСвойство_2(Запись, СтрокаПКС, хДанныеРеквизитаТЧ, НеЗамещатьСвойство, ИнформацияОТипах, ПКОРодитель);
		
		Если НеЗамещатьСвойство Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоПараметр Тогда
			//ДобавитьСложныйПараметрПриНеобходимости(ПараметрыОбъекта, ИмяВетки, НомерЗаписи, Имя, ЗначениеСвойства);
		ИначеЕсли НужноОрганизоватьПоискПоТЧ Тогда 
			СтруктураЧтенияСвойств.Вставить(Имя, ЗначениеСвойства);
		Иначе
			
			Попытка
				
				Запись[Имя] = ЗначениеСвойства;
				
			Исключение
				
				ЗП = ПолучитьСтруктуруЗаписиПротокола(26, ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ЗП.ИмяПКО           = ИмяПКО;
				ЗП.Объект           = Объект;
				ЗП.ТипОбъекта       = ТипЗнч(Объект);
				ЗП.Свойство         = Строка(Запись) + "." + Имя;
				ЗП.Значение         = ЗначениеСвойства;
				ЗП.ТипЗначения      = ТипЗнч(ЗначениеСвойства);
				СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(26, ЗП, Истина);
				
				Если Не ФлагРежимОтладки Тогда
					ВызватьИсключение СтрокаСообщенияОбОшибке;
				КонецЕсли;
				
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если НужноОрганизоватьПоискПоТЧ Тогда
		
		СтруктураПоиска = Новый Структура();
		
		Для Каждого ЭлементПоиска Из  ДанныеПоискаПоТЧ.ПоляПоискаТЧ Цикл
			
			ЗначениеЭлемента = Неопределено;
			СтруктураЧтенияСвойств.Свойство(ЭлементПоиска, ЗначениеЭлемента);
			
			СтруктураПоиска.Вставить(ЭлементПоиска, ЗначениеЭлемента);		
			
		КонецЦикла;		
		
		МассивРезультатовПоиска = КопияТЧДляПоиска.НайтиСтроки(СтруктураПоиска);
		
		НайденаЗапись = МассивРезультатовПоиска.Количество() > 0;
		Если НайденаЗапись Тогда
			ЗаполнитьЗначенияСвойств(Запись, МассивРезультатовПоиска[0]);
		КонецЕсли;
		
		// Поверх заполнение свойствами и значением субконто.
		Для Каждого КлючИЗначение Из СтруктураЧтенияСвойств Цикл
			
			Запись[КлючИЗначение.Ключ] = КлючИЗначение.Значение;
			
		КонецЦикла;
		
		Для Каждого ЭлементИмя Из СтруктураЧтенияСубконто Цикл
			
			Для Каждого ЭлементКлюч Из ЭлементИмя.Значение Цикл
			
				Запись[ЭлементИмя.Ключ][ЭлементКлюч.Ключ] = ЭлементКлюч.Значение;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
#Область СтараяЛогика
	
	//Пока ФайлОбмена.Прочитать() Цикл
	//	
	//	ИмяУзла = ФайлОбмена.ЛокальноеИмя;
	//	
	//	Если ИмяУзла = "Свойство"
	//		ИЛИ ИмяУзла = "ЗначениеПараметра" Тогда
	//		
	//		ЭтоПараметр = (ИмяУзла = "ЗначениеПараметра");
	//		
	//		Имя    = одАтрибут(ФайлОбмена, одТипСтрока, "Имя");
	//		ИмяПКО = одАтрибут(ФайлОбмена, одТипСтрока, "ИмяПКО");
	//		
	//		Если Имя = "ВидДвижения" И СтрНайти(Метаданные.НайтиПоТипу(ТипЗнч(Запись)).ПолноеИмя(), "РегистрНакопления") Тогда
	//			
	//			ТипСвойства = одТипВидДвиженияНакопления;
	//			
	//		Иначе
	//			
	//			ТипСвойства = ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, Имя);
	//			
	//		КонецЕсли;
	//		
	//		ЗначениеСвойства = ПрочитатьСвойство(ТипСвойства, ИмяПКО);
	//		
	//		Если ЭтоПараметр Тогда
	//			ДобавитьСложныйПараметрПриНеобходимости(ПараметрыОбъекта, ИмяВетки, НомерЗаписи, Имя, ЗначениеСвойства);			
	//		ИначеЕсли НужноОрганизоватьПоискПоТЧ Тогда 
	//			СтруктураЧтенияСвойств.Вставить(Имя, ЗначениеСвойства);	
	//		Иначе
	//			
	//			Попытка
	//				
	//				Запись[Имя] = ЗначениеСвойства;
	//				
	//			Исключение
	//				
	//				ЗП = ПолучитьСтруктуруЗаписиПротокола(26, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	//				ЗП.ИмяПКО           = ИмяПКО;
	//				ЗП.Объект           = Объект;
	//				ЗП.ТипОбъекта       = ТипЗнч(Объект);
	//				ЗП.Свойство         = Строка(Запись) + "." + Имя;
	//				ЗП.Значение         = ЗначениеСвойства;
	//				ЗП.ТипЗначения      = ТипЗнч(ЗначениеСвойства);
	//				СтрокаСообщенияОбОшибке = ЗаписатьВПротоколВыполнения(26, ЗП, Истина);
	//				
	//				Если Не ФлагРежимОтладки Тогда
	//					ВызватьИсключение СтрокаСообщенияОбОшибке;
	//				КонецЕсли;
	//			КонецПопытки;
	//			
	//		КонецЕсли;
	//		
	//	ИначеЕсли ИмяУзла = "СубконтоДт" ИЛИ ИмяУзла = "СубконтоКт" Тогда
	//		
	//		// Поиск по субконто не реализован.
	//		
	//		Ключ = Неопределено;
	//		Значение = Неопределено;
	//		
	//		Пока ФайлОбмена.Прочитать() Цикл
	//			
	//			ИмяУзла = ФайлОбмена.ЛокальноеИмя;
	//							
	//			Если ИмяУзла = "Свойство" Тогда
	//				
	//				Имя    = одАтрибут(ФайлОбмена, одТипСтрока, "Имя");
	//				ИмяПКО = одАтрибут(ФайлОбмена, одТипСтрока, "ИмяПКО");
	//				ТипСвойства = ПолучитьТипСвойстваПоДополнительнымДанным(ИнформацияОТипах, Имя);
	//									
	//				Если Имя = "Ключ" Тогда
	//					
	//					Ключ = ПрочитатьСвойство(ТипСвойства);
	//					
	//				ИначеЕсли Имя = "Значение" Тогда
	//					
	//					Значение = ПрочитатьСвойство(ТипСвойства, ИмяПКО);
	//					
	//				КонецЕсли;
	//				
	//			ИначеЕсли (ИмяУзла = "СубконтоДт" ИЛИ ИмяУзла = "СубконтоКт") И (ФайлОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//				
	//				Прервать;
	//				
	//			Иначе
	//				
	//				ЗаписатьВПротоколВыполнения(9);
	//				Прервать;
	//				
	//			КонецЕсли;
	//			
	//		КонецЦикла;
	//		
	//		Если Ключ <> Неопределено 
	//			И Значение <> Неопределено Тогда
	//			
	//			Если НЕ НужноОрганизоватьПоискПоТЧ Тогда
	//			
	//				Запись[ИмяУзла][Ключ] = Значение;
	//				
	//			Иначе
	//				
	//				СоответствиеЗаписи = Неопределено;
	//				Если НЕ СтруктураЧтенияСубконто.Свойство(ИмяУзла, СоответствиеЗаписи) Тогда
	//					СоответствиеЗаписи = Новый Соответствие;
	//					СтруктураЧтенияСубконто.Вставить(ИмяУзла, СоответствиеЗаписи);
	//				КонецЕсли;
	//				
	//				СоответствиеЗаписи.Вставить(Ключ, Значение);
	//				
	//			КонецЕсли;
	//			
	//		КонецЕсли;
	//			
	//	ИначеЕсли (ИмяУзла = "Запись") И (ФайлОбмена.ТипУзла = одТипУзлаXML_КонецЭлемента) Тогда
	//		
	//		Прервать;
	//		
	//	Иначе
	//		
	//		ЗаписатьВПротоколВыполнения(9);
	//		Прервать;
	//		
	//	КонецЕсли;
	//	
	//КонецЦикла;
	//
	//Если НужноОрганизоватьПоискПоТЧ Тогда
	//	
	//	СтруктураПоиска = Новый Структура();
	//	
	//	Для Каждого ЭлементПоиска Из  ДанныеПоискаПоТЧ.ПоляПоискаТЧ Цикл
	//		
	//		ЗначениеЭлемента = Неопределено;
	//		СтруктураЧтенияСвойств.Свойство(ЭлементПоиска, ЗначениеЭлемента);
	//		
	//		СтруктураПоиска.Вставить(ЭлементПоиска, ЗначениеЭлемента);		
	//		
	//	КонецЦикла;		
	//	
	//	МассивРезультатовПоиска = КопияТЧДляПоиска.НайтиСтроки(СтруктураПоиска);
	//	
	//	НайденаЗапись = МассивРезультатовПоиска.Количество() > 0;
	//	Если НайденаЗапись Тогда
	//		ЗаполнитьЗначенияСвойств(Запись, МассивРезультатовПоиска[0]);
	//	КонецЕсли;
	//	
	//	// Поверх заполнение свойствами и значением субконто.
	//	Для Каждого КлючИЗначение Из СтруктураЧтенияСвойств Цикл
	//		
	//		Запись[КлючИЗначение.Ключ] = КлючИЗначение.Значение;
	//		
	//	КонецЦикла;
	//	
	//	Для Каждого ЭлементИмя Из СтруктураЧтенияСубконто Цикл
	//		
	//		Для Каждого ЭлементКлюч Из ЭлементИмя.Значение Цикл
	//		
	//			Запись[ЭлементИмя.Ключ][ЭлементКлюч.Ключ] = ЭлементКлюч.Значение;
	//			
	//		КонецЦикла;
	//		
	//	КонецЦикла;
	//	
	//КонецЕсли;
	
#КонецОбласти

	
КонецПроцедуры

// Выполняет проверку на наличие запрета загрузки по дате.
//
// Параметры:
//   ЭлементДанных	  - СправочникОбъект, ДокументОбъект, РегистрСведенийНаборЗаписей и др. данные.
//                      Данные, которые были зачитаны из сообщения обмена, но еще не были записаны в ИБ.
//   ПолучениеЭлемента - ПолучениеЭлементаДанных.
//
// Возвращаемое значение:
//   Булево - Истина - установлена дата запрета изменения и загружаемый объект имеет дату меньше установленной, иначе Ложь.
//
Функция ЗапретИзмененияДанныхПоДате(ЭлементДанных)
	
	ИзменениеЗапрещено = Ложь;
	
	Если МодульДатыЗапретаИзменения <> Неопределено
		И Не Метаданные.Константы.Содержит(ЭлементДанных.Метаданные()) Тогда
		Попытка
			Если МодульДатыЗапретаИзменения.ИзменениеЗапрещено(ЭлементДанных) Тогда
				ИзменениеЗапрещено = Истина;
			КонецЕсли;
		Исключение
			ИзменениеЗапрещено = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	ЭлементДанных.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения");
	
	Возврат ИзменениеЗапрещено;
	
КонецФункции

Процедура ПровестиГенерациюКодаНомераПриНеобходимости(ГенерироватьНовыйНомерИлиКодЕслиНеУказан, Объект, ИмяТипаОбъекта, НужноЗаписатьОбъект, 
	РежимОбменДанными)
	
	Если Не ГенерироватьНовыйНомерИлиКодЕслиНеУказан
		ИЛИ НЕ РежимОбменДанными Тогда
		
		// Если номер не нужно генерировать, или не в режиме обмена данными то ничего не нужно делать... платформа сама все
		// сгенерирует.
		Возврат;
	КонецЕсли;
	
	// По типу документа смотрим заполнен кол или номер.
	Если ИмяТипаОбъекта = "Документ"
		ИЛИ ИмяТипаОбъекта =  "БизнесПроцесс"
		ИЛИ ИмяТипаОбъекта = "Задача" Тогда
		
		Если НЕ ЗначениеЗаполнено(Объект.Номер) Тогда
			
			Объект.УстановитьНовыйНомер();
			НужноЗаписатьОбъект = Истина;
			
		КонецЕсли;
		
	ИначеЕсли ИмяТипаОбъекта = "Справочник"
		ИЛИ ИмяТипаОбъекта = "ПланВидовХарактеристик"
		ИЛИ ИмяТипаОбъекта = "ПланОбмена" Тогда
		
		Если НЕ ЗначениеЗаполнено(Объект.Код) Тогда
			
			Объект.УстановитьНовыйКод();
			НужноЗаписатьОбъект = Истина;
			
		КонецЕсли;	
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьДокументВБезопасномРежиме(Документ, ТипОбъекта)
	
	Если Документ.Проведен Тогда
						
		Документ.Проведен = Ложь;
			
	КонецЕсли;		
								
	ЗаписатьОбъектВИБ(Документ, ТипОбъекта);
	
КонецПроцедуры

// Параметры:
//   Отбор - Отбор - произвольный отбор.
//   КлючЭлемента - Строка - имя элемента отбора.
//   ЗначениеЭлемента - Произвольный - значение элемента отбора.
//
Процедура УстановитьЗначениеЭлементаОтбора(Отбор, КлючЭлемента, ЗначениеЭлемента)
	
	ЭлементОтбора = Отбор.Найти(КлючЭлемента);
	Если ЭлементОтбора <> Неопределено Тогда
		ЭлементОтбора.Установить(ЗначениеЭлемента);
	КонецЕсли;
	
КонецПроцедуры

Функция НайтиИлиСоздатьОбъектПоСвойству(СтруктураСвойств, ТипОбъекта, СвойстваПоиска, СвойстваПоискаНеЗамещать,
	ИмяТипаОбъекта, СвойствоПоиска, ЗначениеСвойстваПоиска, ОбъектНайден,
	СоздаватьНовыйЭлементЕслиНеНайден, НайденныйИлиСозданныйОбъект,
	РежимПоискаОсновногоОбъекта, СвойстваОбъектаМодифицированы, НПП, ГНПП,
	ПараметрыОбъекта, НоваяСсылкаУникальногоИдентификатора = Неопределено)
	
	ЭтоПеречисление = СтруктураСвойств.ИмяТипа = "Перечисление";
	
	Если ЭтоПеречисление Тогда
		
		СтрокаПоиска = "";
		
	Иначе
		
		СтрокаПоиска = СтруктураСвойств.СтрокаПоиска;
		
	КонецЕсли;
	
	Если РежимПоискаОсновногоОбъекта Или ПустаяСтрока(СтрокаПоиска) Тогда
		СтрокаЗапросаПоискаПоУникальномуИдентификатору = "";
	КонецЕсли;
	
	Объект = НайтиОбъектПоСвойству(СтруктураСвойств.Менеджер, СвойствоПоиска, ЗначениеСвойстваПоиска,
		НайденныйИлиСозданныйОбъект, , , СтрокаЗапросаПоискаПоУникальномуИдентификатору);
		
	ОбъектНайден = НЕ (Объект = Неопределено ИЛИ Объект.Пустая());
		
	Если Не ОбъектНайден Тогда
		Если СоздаватьНовыйЭлементЕслиНеНайден Тогда
		
			Объект = СоздатьНовыйОбъект(ТипОбъекта, СвойстваПоиска, НайденныйИлиСозданныйОбъект, 
				НЕ РежимПоискаОсновногоОбъекта,,НоваяСсылкаУникальногоИдентификатора, НПП, ГНПП, ПараметрыОбъекта);
				
			СвойстваОбъектаМодифицированы = Истина;
		КонецЕсли;
		Возврат Объект;
	
	КонецЕсли;
	
	Если ЭтоПеречисление Тогда
		Возврат Объект;
	КонецЕсли;			
	
	Если РежимПоискаОсновногоОбъекта Тогда
		
		Если НайденныйИлиСозданныйОбъект = Неопределено Тогда
			НайденныйИлиСозданныйОбъект = Объект.ПолучитьОбъект();
		КонецЕсли;
			
		СвойстваОбъектаМодифицированы = УстановитьРеквизитыПоискаУОбъекта(НайденныйИлиСозданныйОбъект, СвойстваПоиска, СвойстваПоискаНеЗамещать);
				
	КонецЕсли;
		
	Возврат Объект;
	
КонецФункции

Функция ОпределитьПоТипуОбъектаИспользоватьДополнительныйПоискПоПолямПоиска(ТипСсылкиСтрокой)
	
	ЗначениеСоответствия = мСоответствиеДопПараметровПоиска.Получить(ТипСсылкиСтрокой);
	
	Если ЗначениеСоответствия <> Неопределено Тогда
		Возврат ЗначениеСоответствия;
	КонецЕсли;
	
	Попытка
	
		Для Каждого Элемент Из Правила Цикл
			
			Если Элемент.Значение.Приемник = ТипСсылкиСтрокой Тогда
				
				Если Элемент.Значение.СинхронизироватьПоИдентификатору = Истина Тогда
					
					НужноПродолжитьПоиск = (Элемент.Значение.ПродолжитьПоискПоПолямПоискаЕслиПоИдентификаторуНеНашли = Истина);
					мСоответствиеДопПараметровПоиска.Вставить(ТипСсылкиСтрокой, НужноПродолжитьПоиск);
					
					Возврат НужноПродолжитьПоиск;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		мСоответствиеДопПараметровПоиска.Вставить(ТипСсылкиСтрокой, Ложь);
		Возврат Ложь;
	
	Исключение
		
		мСоответствиеДопПараметровПоиска.Вставить(ТипСсылкиСтрокой, Ложь);
		Возврат Ложь;
	
    КонецПопытки;
	
КонецФункции

// Определяет по типу объекта приемника правило конвертации объекта (ПКО).
//
// Параметры:
//  ТипСсылкиСтрокой - Строка - тип объекта в строковом представлении, например, "СправочникСсылка.Номенклатура".
// 
// Возвращаемое значение:
//  ЗначениеСоответствия = Правило конвертации объекта.
// 
Функция ОпределитьПоТипуОбъектаПриемникаПравилоКонвертацииКотороеСодержитАлгоритмПоиска(ТипСсылкиСтрокой)
	
	ЗначениеСоответствия = мСоответствиеПравилКонвертации.Получить(ТипСсылкиСтрокой);
	
	Если ЗначениеСоответствия <> Неопределено Тогда
		Возврат ЗначениеСоответствия;
	КонецЕсли;
	
	Попытка
	
		Для Каждого Элемент Из Правила Цикл
			
			Если Элемент.Значение.Приемник = ТипСсылкиСтрокой Тогда
				
				Если Элемент.Значение.ЕстьОбработчикПоследовательностьПолейПоиска = Истина Тогда
					
					Правило = Элемент.Значение;
					
					мСоответствиеПравилКонвертации.Вставить(ТипСсылкиСтрокой, Правило);
					
					Возврат Правило;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		мСоответствиеПравилКонвертации.Вставить(ТипСсылкиСтрокой, Неопределено);
		Возврат Неопределено;
	
	Исключение
		
		мСоответствиеПравилКонвертации.Вставить(ТипСсылкиСтрокой, Неопределено);
		Возврат Неопределено;
	
	КонецПопытки;
	
КонецФункции

Функция НайтиЭлементПоСвойствамПоиска(ТипОбъекта, ИмяТипаОбъекта, СвойстваПоиска, 
	СтруктураСвойств, СтрокаИменСвойствПоиска, ПоискПоДатеНаРавенство)
	
	// Не нужно искать по имени предопределенного элемента и по уникальной ссылке на объект
	// нужно искать только по тем свойствам, которые имеются в строке имен свойств. Если там пусто, то по
	// всем имеющимся свойствам поиска.
		
	ИскатьЗапросом = Ложь;	
	
	Если ПустаяСтрока(СтрокаИменСвойствПоиска) Тогда
		
		ВременныеСвойстваПоиска = СвойстваПоиска;
		
	Иначе
		
		ВыбранныеСвойства = СтрРазделить(СтрокаИменСвойствПоиска, ", ", Ложь);
		
		ВременныеСвойстваПоиска = Новый Соответствие;
		Для Каждого ЭлементСвойств Из СвойстваПоиска Цикл
			
			Если ВыбранныеСвойства.Найти(ЭлементСвойств.Ключ) <> Неопределено Тогда
				ВременныеСвойстваПоиска.Вставить(ЭлементСвойств.Ключ, ЭлементСвойств.Значение);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	СвойствоУникальныйИдентификатор = ВременныеСвойстваПоиска["{УникальныйИдентификатор}"];
	СвойствоИмяПредопределенного = ВременныеСвойстваПоиска["{ИмяПредопределенногоЭлемента}"];
	
	КоличествоРеальныхСвойствДляПоиска = ВременныеСвойстваПоиска.Количество();
	КоличествоРеальныхСвойствДляПоиска = КоличествоРеальныхСвойствДляПоиска - ?(СвойствоУникальныйИдентификатор <> Неопределено, 1, 0);
	КоличествоРеальныхСвойствДляПоиска = КоличествоРеальныхСвойствДляПоиска - ?(СвойствоИмяПредопределенного <> Неопределено, 1, 0);
	
	
	Если КоличествоРеальныхСвойствДляПоиска = 1 Тогда
				
		СсылкаНаОбъект = НайтиСсылкуНаОбъектПоОдномуСвойству(ВременныеСвойстваПоиска, СтруктураСвойств);
																						
	ИначеЕсли ИмяТипаОбъекта = "Документ" Тогда
				
		СсылкаНаОбъект = НайтиСсылкуНаДокумент(ВременныеСвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом, ПоискПоДатеНаРавенство);
											
	ИначеЕсли ИмяТипаОбъекта = "Справочник" Тогда
				
		СсылкаНаОбъект = НайтиСсылкуНаСправочник(ВременныеСвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом);
								
	ИначеЕсли ИмяТипаОбъекта = "ПланВидовХарактеристик" Тогда
				
		СсылкаНаОбъект = НайтиСсылкуНаПВХ(ВременныеСвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом);
							
	ИначеЕсли ИмяТипаОбъекта = "ПланОбмена" Тогда
				
		СсылкаНаОбъект = НайтиСсылкуНаПланОбмена(ВременныеСвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом);
							
	ИначеЕсли ИмяТипаОбъекта = "Задача" Тогда
				
		СсылкаНаОбъект = НайтиСсылкуНаЗадачу(ВременныеСвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом);
												
	ИначеЕсли ИмяТипаОбъекта = "БизнесПроцесс" Тогда
				
		СсылкаНаОбъект = НайтиСсылкуНаБизнесПроцесс(ВременныеСвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом);
									
	Иначе
				
		ИскатьЗапросом = Истина;
				
	КонецЕсли;
		
	Если ИскатьЗапросом Тогда
			
		СсылкаНаОбъект = НайтиЭлементЗапросом(СтруктураСвойств, ВременныеСвойстваПоиска, ТипОбъекта, , КоличествоРеальныхСвойствДляПоиска);
				
	КонецЕсли;
	
	Возврат СсылкаНаОбъект;
	
КонецФункции

Процедура ОбработатьУстановкуСвойствПоискаУОбъекта(УстанавливатьУОбъектаВсеСвойстваПоиска, ТипОбъекта, СвойстваПоиска, 
	СвойстваПоискаНеЗамещать, СсылкаНаОбъект, СозданныйОбъект, ЗаписыватьНовыйОбъектВИнформационнуюБазу = Истина, ИзмененыРеквизитыОбъекта = Ложь)
	
	Если УстанавливатьУОбъектаВсеСвойстваПоиска <> Истина Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
		Возврат;
	КонецЕсли;
	
	Если СозданныйОбъект = Неопределено Тогда
		СозданныйОбъект = СсылкаНаОбъект.ПолучитьОбъект();
	КонецЕсли;
	
	ИзмененыРеквизитыОбъекта = УстановитьРеквизитыПоискаУОбъекта(СозданныйОбъект, СвойстваПоиска, СвойстваПоискаНеЗамещать);
	
	// Если было то что изменено, тогда перезаписываем объект.
	Если ИзмененыРеквизитыОбъекта
		И ЗаписыватьНовыйОбъектВИнформационнуюБазу Тогда
		
		ЗаписатьОбъектВИБ(СозданныйОбъект, ТипОбъекта);
		
	КонецЕсли;
	
КонецПроцедуры

Функция УстановитьРеквизитыПоискаУОбъекта(НайденныйОбъект, СвойстваПоиска, СвойстваПоискаНеЗамещать, 
	НужноСравниватьСТекущимиРеквизитами = Истина, НЕЗаменятьСвойстваНеПодлежащиеИзменению = Истина)
	
	ИзмененыРеквизитыОбъекта = Ложь;
				
	Для каждого Свойство Из СвойстваПоиска Цикл
					
		Имя      = Свойство.Ключ;
		Значение = Свойство.Значение;
		
		Если НЕЗаменятьСвойстваНеПодлежащиеИзменению
			И СвойстваПоискаНеЗамещать[Имя] <> Неопределено Тогда
			
			Продолжить;
			
		КонецЕсли;
					
		Если Имя = "ЭтоГруппа" 
			ИЛИ Имя = "{УникальныйИдентификатор}" 
			ИЛИ Имя = "{ИмяПредопределенногоЭлемента}" Тогда
						
			Продолжить;
						
		ИначеЕсли Имя = "ПометкаУдаления" Тогда
						
			Если НЕ НужноСравниватьСТекущимиРеквизитами
				ИЛИ НайденныйОбъект.ПометкаУдаления <> Значение Тогда
							
				НайденныйОбъект.ПометкаУдаления = Значение;
				ИзмененыРеквизитыОбъекта = Истина;
							
			КонецЕсли;
						
		Иначе
				
			// Отличные реквизиты устанавливаем.
			Если НайденныйОбъект[Имя] <> NULL Тогда
			
				Если НЕ НужноСравниватьСТекущимиРеквизитами
					ИЛИ НайденныйОбъект[Имя] <> Значение Тогда
						
					НайденныйОбъект[Имя] = Значение;
					ИзмененыРеквизитыОбъекта = Истина;
						
				КонецЕсли;
				
			КонецЕсли;
				
		КонецЕсли;
					
	КонецЦикла;
	
	Возврат ИзмененыРеквизитыОбъекта;
	
КонецФункции

Функция ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита)
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

Функция УстановитьСсылкуНового(Объект, Менеджер, СвойстваПоиска)
	
	УИ = СвойстваПоиска["{УникальныйИдентификатор}"];
	
	Если УИ <> Неопределено Тогда
		
		НоваяСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(УИ));
		
		Объект.УстановитьСсылкуНового(НоваяСсылка);
		
		СвойстваПоиска.Удалить("{УникальныйИдентификатор}");
		
	Иначе
		
		НоваяСсылка = Неопределено;
		
	КонецЕсли;
	
	Возврат НоваяСсылка;
	
КонецФункции

Функция НайтиСсылкуНаОбъектПоОдномуСвойству(СвойстваПоиска, СтруктураСвойств)
	
	Для каждого Свойство Из СвойстваПоиска Цикл
					
		ИмяПараметра      = Свойство.Ключ;
					
		// Не по всем параметрам можно искать.
		Если ИмяПараметра = "{УникальныйИдентификатор}"
			ИЛИ ИмяПараметра = "{ИмяПредопределенногоЭлемента}" Тогда
						
			Продолжить;
						
		КонецЕсли;
					
		ЗначениеПараметра = Свойство.Значение;
		СсылкаНаОбъект = НайтиОбъектПоСвойству(СтруктураСвойств.Менеджер, ИмяПараметра, ЗначениеПараметра, Неопределено, СтруктураСвойств, СвойстваПоиска);
		
	КонецЦикла;
	
	Возврат СсылкаНаОбъект;
	
КонецФункции

Функция НайтиСсылкуНаДокумент(СвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом, ПоискПоДатеНаРавенство)
	
	// Попробуем документ по дате и номеру найти.
	ИскатьЗапросом = ПоискПоДатеНаРавенство ИЛИ (КоличествоРеальныхСвойствДляПоиска <> 2);
				
	Если ИскатьЗапросом Тогда
		Возврат Неопределено;
	КонецЕсли;
					
	НомерДокумента = СвойстваПоиска["Номер"];
	ДатаДокумента  = СвойстваПоиска["Дата"];
					
	Если (НомерДокумента <> Неопределено) И (ДатаДокумента <> Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоНомеру(НомерДокумента, ДатаДокумента);
																		
	Иначе
						
		// По дате и номеру найти не удалось - надо искать запросом.
		ИскатьЗапросом = Истина;
		СсылкаНаОбъект = Неопределено;
						
	КонецЕсли;
	
	Возврат СсылкаНаОбъект;
	
КонецФункции

Функция НайтиСсылкуНаСправочник(СвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом)
	
	Владелец     = СвойстваПоиска["Владелец"];
	Родитель     = СвойстваПоиска["Родитель"];
	Код          = СвойстваПоиска["Код"];
	Наименование = СвойстваПоиска["Наименование"];
				
	Кол          = 0;
				
	Если Владелец <> Неопределено Тогда	Кол = 1 + Кол; КонецЕсли;
	Если Родитель <> Неопределено Тогда	Кол = 1 + Кол; КонецЕсли;
	Если Код <> Неопределено Тогда Кол = 1 + Кол; КонецЕсли;
	Если Наименование <> Неопределено Тогда	Кол = 1 + Кол; КонецЕсли;
				
	ИскатьЗапросом = (Кол <> КоличествоРеальныхСвойствДляПоиска);
				
	Если ИскатьЗапросом Тогда
		Возврат Неопределено;
	КонецЕсли;
					
	Если (Код <> Неопределено) И (Наименование = Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоКоду(Код, , Родитель, Владелец);
																		
	ИначеЕсли (Код = Неопределено) И (Наименование <> Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоНаименованию(Наименование, ИСТИНА, Родитель, Владелец);
											
	Иначе
						
		ИскатьЗапросом = Истина;
		СсылкаНаОбъект = Неопределено;
						
	КонецЕсли;
															
	Возврат СсылкаНаОбъект;
	
КонецФункции

Функция НайтиСсылкуНаПВХ(СвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом)
	
	Родитель     = СвойстваПоиска["Родитель"];
	Код          = СвойстваПоиска["Код"];
	Наименование = СвойстваПоиска["Наименование"];
	Кол          = 0;
				
	Если Родитель     <> Неопределено Тогда	Кол = 1 + Кол КонецЕсли;
	Если Код          <> Неопределено Тогда Кол = 1 + Кол КонецЕсли;
	Если Наименование <> Неопределено Тогда	Кол = 1 + Кол КонецЕсли;
				
	ИскатьЗапросом = (Кол <> КоличествоРеальныхСвойствДляПоиска);
				
	Если ИскатьЗапросом Тогда
		Возврат Неопределено;
	КонецЕсли;
					
	Если     (Код <> Неопределено) И (Наименование = Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоКоду(Код, Родитель);
												
	ИначеЕсли (Код = Неопределено) И (Наименование <> Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоНаименованию(Наименование, ИСТИНА, Родитель);
																	
	Иначе
						
		ИскатьЗапросом = Истина;
		СсылкаНаОбъект = Неопределено;
			
	КонецЕсли;
															
	Возврат СсылкаНаОбъект;
	
КонецФункции

Функция НайтиСсылкуНаПланОбмена(СвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом)
	
	Код          = СвойстваПоиска["Код"];
	Наименование = СвойстваПоиска["Наименование"];
	Кол          = 0;
				
	Если Код          <> Неопределено Тогда Кол = 1 + Кол КонецЕсли;
	Если Наименование <> Неопределено Тогда	Кол = 1 + Кол КонецЕсли;
				
	ИскатьЗапросом = (Кол <> КоличествоРеальныхСвойствДляПоиска);
				
	Если ИскатьЗапросом Тогда
		Возврат Неопределено;
	КонецЕсли;
					
	Если     (Код <> Неопределено) И (Наименование = Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоКоду(Код);
												
	ИначеЕсли (Код = Неопределено) И (Наименование <> Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоНаименованию(Наименование, ИСТИНА);
																	
	Иначе
						
		ИскатьЗапросом = Истина;
		СсылкаНаОбъект = Неопределено;
						
	КонецЕсли;
															
	Возврат СсылкаНаОбъект;
	
КонецФункции

Функция НайтиСсылкуНаЗадачу(СвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом)
	
	Код          = СвойстваПоиска["Номер"];
	Наименование = СвойстваПоиска["Наименование"];
	Кол          = 0;
				
	Если Код          <> Неопределено Тогда Кол = 1 + Кол КонецЕсли;
	Если Наименование <> Неопределено Тогда	Кол = 1 + Кол КонецЕсли;
				
	ИскатьЗапросом = (Кол <> КоличествоРеальныхСвойствДляПоиска);
				
	Если ИскатьЗапросом Тогда
		Возврат Неопределено;
	КонецЕсли;
	
					
	Если     (Код <> Неопределено) И (Наименование = Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоНомеру(Код);
												
	ИначеЕсли (Код = Неопределено) И (Наименование <> Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоНаименованию(Наименование, ИСТИНА);
																	
	Иначе
						
		ИскатьЗапросом = Истина;
		СсылкаНаОбъект = Неопределено;
						
	КонецЕсли;
															
	Возврат СсылкаНаОбъект;
	
КонецФункции

Функция НайтиСсылкуНаБизнесПроцесс(СвойстваПоиска, СтруктураСвойств, КоличествоРеальныхСвойствДляПоиска, ИскатьЗапросом)
	
	Код          = СвойстваПоиска["Номер"];
	Кол          = 0;
				
	Если Код <> Неопределено Тогда Кол = 1 + Кол КонецЕсли;
								
	ИскатьЗапросом = (Кол <> КоличествоРеальныхСвойствДляПоиска);
				
	Если ИскатьЗапросом Тогда
		Возврат Неопределено;
	КонецЕсли;
					
	Если  (Код <> Неопределено) Тогда
						
		СсылкаНаОбъект = СтруктураСвойств.Менеджер.НайтиПоНомеру(Код);
												
	Иначе
						
		ИскатьЗапросом = Истина;
		СсылкаНаОбъект = Неопределено;
						
	КонецЕсли;
															
	Возврат СсылкаНаОбъект;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Инициализация

ИнициализацияРеквизитовИМодульныхПеременных();
ДополнитьСлужебныеТаблицыКолонками();
ИнициализацияСтруктурыИменОбработчиков();

#КонецОбласти